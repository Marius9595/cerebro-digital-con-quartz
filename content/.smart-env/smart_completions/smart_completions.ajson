
"smart_completions:Untitled Chat 1749506146201-1749506170827": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"c√≥mo se complementan?"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ An√°lisis sint√°ctico de una f√≥rmula.md\n    ‚îî‚îÄ‚îÄ √Årbol sint√°ctico.md\n\nNOTES/√Årbol sint√°ctico.md\n```md\n---\nlibro: \"[[L√≥gica y estructuras discretas 2024-2025]]\"\ncap√≠tulo: 1-Logica Proposicional\npaginas: An√°lisis sint√°ctico de f√≥rmulas proposicionales\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una representaci√≥n gr√°fica, en forma de √°rbol invertido, que describe cualquier sistema compuesto de bloques dentro de otros bloques. Esta representaci√≥n es el c√≥mo resultado de un [[An√°lisis sint√°ctico de una f√≥rmula]] X.\nPara navegar en el se usa la siguiente notaci√≥n:\n- _Nodo ra√≠z y nodos hoja_: la f√≥rmula¬†X¬†original es la ra√≠z del √°rbol y cada una de las f√≥rmulas at√≥micas inferiores es una hoja del √°rbol.\n- _Nodos del √°rbol_: cada una de las f√≥rmulas que aparecen en ese √°rbol est√° situada en un nodo del √°rbol, desde el nodo ra√≠z hasta los nodos hoja, pasando por los nodos intermedios.\n- _Ramas del √°rbol_: cada uno de los caminos de nodos que empieza en el nodo ra√≠z y finaliza en un nodo hoja, inclusive ambos, se denomina rama del √°rbol.\n- _Sub√°rbol_: cada nodo se puede considerar a su vez como ra√≠z de su propio √°rbol. As√≠, el √°rbol sint√°ctico de una f√≥rmula¬†X=(Y‚àóZ)¬†enlazar√≠a el nodo ra√≠z¬†X¬†con los respectivos √°rboles que tienen por ra√≠z tanto¬†Y¬†como¬†Z.\n```\nNOTES/An√°lisis sint√°ctico de una f√≥rmula.md\n```md\n---\nlibro: \"[[L√≥gica y estructuras discretas 2024-2025]]\"\ncap√≠tulo: 1-Logica Proposicional\npaginas: An√°lisis sint√°ctico de f√≥rmulas proposicionales\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs un proceso que se aplica a una [[F√≥rmula Proposicional]] X. \nEsta consisten en:\n- _Descomposici√≥n de¬†X_. Se puede determinar cu√°l es la √∫ltima conectiva ([[Conectiva principal]]) utilizada en su producci√≥n, as√≠ como las [[Subf√≥rmula inmediata]]s utilizadas en ese paso.\n- _An√°lisis de las subf√≥rmulas inmediatas de¬†X_. Estas subf√≥rmulas inmediatas de¬†X¬†son a su vez f√≥rmulas, susceptibles de ser analizadas de la misma manera: detectando su [[Conectiva principal]]y sus componentes inmediatas.\n- _An√°lisis de cada subcomponente encontrada_. Lo mismo ocurre con cada componente que se va detectando en este proceso de descomposici√≥n, a cualquier nivel: es una nueva f√≥rmula que admite este mismo an√°lisis.\nLa f√≥rmula X inicial es siempre una expresi√≥n finita. Y esta propiedad garantiza que el proceso finaliza siempre. As√≠, este proceso acaba en todas sus l√≠neas de an√°lisis porque se llega necesariamente a componentes at√≥micas, donde se finaliza la descomposici√≥n.\nEjemplo usando un [[√Årbol sint√°ctico]]:\n![[arbol-sintactico.excalidraw]]\n```"},{"type":"text","text":"c√≥mo se complementan?"}]}]},"responses":[{"timestamp":1749506259238,"id":"chatcmpl-BgemdKjqjHAgWsoqDHxf0iRcK31ex","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Los dos archivos **\"An√°lisis sint√°ctico de una f√≥rmula.md\"** y **\"√Årbol sint√°ctico.md\"** se complementan de manera natural porque uno describe el **proceso** y el otro la **representaci√≥n gr√°fica** del resultado de ese proceso.\n\n---\n\n### 1. ¬øC√≥mo se complementan?\n\n- **An√°lisis sint√°ctico de una f√≥rmula.md** explica el **proceso l√≥gico y sistem√°tico** por el cual se analiza una f√≥rmula proposicional:\n  - Se identifica la **conectiva principal** de la f√≥rmula.\n  - Se descompone en las **subf√≥rmulas inmediatas**.\n  - Este proceso se aplica recursivamente a cada subf√≥rmula, hasta llegar a f√≥rmulas at√≥micas (sin conectivas).\n  - Garantiza que la descomposici√≥n termina siempre por ser una f√≥rmula finita.\n  \nEste archivo describe **qu√©** y **c√≥mo** se hace el an√°lisis sint√°ctico paso a paso.\n\n- **√Årbol sint√°ctico.md** muestra c√≥mo se **representa visualmente** el resultado del an√°lisis sint√°ctico mediante un √°rbol invertido:\n  - La f√≥rmula original es la **ra√≠z** del √°rbol.\n  - Las subf√≥rmulas son nodos hijos, sub√°rboles, etc.\n  - Las hojas son las f√≥rmulas at√≥micas.\n  - Se usan t√©rminos gr√°ficos como nodos ra√≠z, nodos hoja, ramas y sub√°rboles para explicar esa estructura jer√°rquica.\n  \nEste archivo ilustra el **resultado visual** o la estructura que surge del proceso descrito en \"An√°lisis sint√°ctico de una f√≥rmula.md\".\n\n---\n\n### 2. Relaci√≥n conceptual entre ambos\n\n- El **An√°lisis sint√°ctico** es el proceso que te permite **descomponer** la f√≥rmula original en sus componentes sint√°cticos b√°sicos.\n- El **√Årbol sint√°ctico** es la **forma gr√°fica** que organiza y muestra claramente esa descomposici√≥n.\n- La f√≥rmula se convierte en un √°rbol, donde cada nodo representa una subf√≥rmula identificada en el an√°lisis.\n- Por lo tanto, el an√°lisis sint√°ctico da los datos y estructura para construir el √°rbol sint√°ctico.\n\n---\n\n### 3. En resumen\n\n- Primero tienes una f√≥rmula proposicional cualquiera.\n- Aplicas el **an√°lisis sint√°ctico**: detectas conectiva principal y subf√≥rmulas, y descompones recursivamente.\n- Al terminar obtienes una jerarqu√≠a de subf√≥rmulas.\n- Esa jerarqu√≠a se puede **representar como un √°rbol sint√°ctico** donde:\n  - La ra√≠z es la f√≥rmula completa.\n  - Las ramas muestran c√≥mo se descompone en subf√≥rmulas.\n  - Las hojas son las f√≥rmulas at√≥micas.\n  \nPor eso, ambos conceptos se complementan porque uno (an√°lisis) te da el procedimiento para entender la estructura, y el otro (√°rbol) te da la forma visual para representar esa estructura.\n\n---\n\nSi lo deseas, te puedo ayudar a crear un ejemplo concreto que ilustre ambos documentos con una f√≥rmula determinada. ¬øQuieres?"}}],"usage":{},"raw":{"id":"chatcmpl-BgemdKjqjHAgWsoqDHxf0iRcK31ex","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Los dos archivos **\"An√°lisis sint√°ctico de una f√≥rmula.md\"** y **\"√Årbol sint√°ctico.md\"** se complementan de manera natural porque uno describe el **proceso** y el otro la **representaci√≥n gr√°fica** del resultado de ese proceso.\n\n---\n\n### 1. ¬øC√≥mo se complementan?\n\n- **An√°lisis sint√°ctico de una f√≥rmula.md** explica el **proceso l√≥gico y sistem√°tico** por el cual se analiza una f√≥rmula proposicional:\n  - Se identifica la **conectiva principal** de la f√≥rmula.\n  - Se descompone en las **subf√≥rmulas inmediatas**.\n  - Este proceso se aplica recursivamente a cada subf√≥rmula, hasta llegar a f√≥rmulas at√≥micas (sin conectivas).\n  - Garantiza que la descomposici√≥n termina siempre por ser una f√≥rmula finita.\n  \nEste archivo describe **qu√©** y **c√≥mo** se hace el an√°lisis sint√°ctico paso a paso.\n\n- **√Årbol sint√°ctico.md** muestra c√≥mo se **representa visualmente** el resultado del an√°lisis sint√°ctico mediante un √°rbol invertido:\n  - La f√≥rmula original es la **ra√≠z** del √°rbol.\n  - Las subf√≥rmulas son nodos hijos, sub√°rboles, etc.\n  - Las hojas son las f√≥rmulas at√≥micas.\n  - Se usan t√©rminos gr√°ficos como nodos ra√≠z, nodos hoja, ramas y sub√°rboles para explicar esa estructura jer√°rquica.\n  \nEste archivo ilustra el **resultado visual** o la estructura que surge del proceso descrito en \"An√°lisis sint√°ctico de una f√≥rmula.md\".\n\n---\n\n### 2. Relaci√≥n conceptual entre ambos\n\n- El **An√°lisis sint√°ctico** es el proceso que te permite **descomponer** la f√≥rmula original en sus componentes sint√°cticos b√°sicos.\n- El **√Årbol sint√°ctico** es la **forma gr√°fica** que organiza y muestra claramente esa descomposici√≥n.\n- La f√≥rmula se convierte en un √°rbol, donde cada nodo representa una subf√≥rmula identificada en el an√°lisis.\n- Por lo tanto, el an√°lisis sint√°ctico da los datos y estructura para construir el √°rbol sint√°ctico.\n\n---\n\n### 3. En resumen\n\n- Primero tienes una f√≥rmula proposicional cualquiera.\n- Aplicas el **an√°lisis sint√°ctico**: detectas conectiva principal y subf√≥rmulas, y descompones recursivamente.\n- Al terminar obtienes una jerarqu√≠a de subf√≥rmulas.\n- Esa jerarqu√≠a se puede **representar como un √°rbol sint√°ctico** donde:\n  - La ra√≠z es la f√≥rmula completa.\n  - Las ramas muestran c√≥mo se descompone en subf√≥rmulas.\n  - Las hojas son las f√≥rmulas at√≥micas.\n  \nPor eso, ambos conceptos se complementan porque uno (an√°lisis) te da el procedimiento para entender la estructura, y el otro (√°rbol) te da la forma visual para representar esa estructura.\n\n---\n\nSi lo deseas, te puedo ayudar a crear un ejemplo concreto que ilustre ambos documentos con una f√≥rmula determinada. ¬øQuieres?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749506146201-1749506170827","thread_key":"Untitled Chat 1749506146201","stream":true,"class_name":"SmartCompletion","context_key":"1749506165172","user_message":"c√≥mo se complementan?","new_user_message":true},
"smart_completions:Untitled Chat 1749506269151-1749506269152": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"en que se relacionan?"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Las tres leyes de TDD.md\n    ‚îî‚îÄ‚îÄ Test unitario (1).md\n\nNOTES/Test unitario (1).md\n```md\n---\nlibro: \"[[Growing Object-Oriented Software, Guided by tests]]\"\ncap√≠tulo: 1-What is the point of test-driven-development\npaginas: 8,\ntags:\n  - TDD\naliases:\n  - Test solitario\n---\n## ¬øQu√© es?\nSeg√∫n los autores son tests que ayudan a cuidar la [[Calidad interna del c√≥digo]]. Suelen hablar de test sobre objetos, no queda del todo claro, pero de cierta manera hablan de test solitario. Esto significa que se intenta verificar que un objeto haga o cumpla lo que se espera de este. Dado, que los objetos no son entes aislados y normalmente trabajan con otros por colaboraci√≥n, y dicha colaboraci√≥n se traduce en dependencia, para testear que un objeto funciona correctamente, es necesario simular estas dependencias, y lo m√°s importante, que queden explicitas en el dise√±o. Por tanto, se trata de comprobar que un objeto, estableciendo condiciones de sus dependencias, se comporte de una manera concreta ante un escenario x.\n## Opini√≥n\nEste enfoque de test unitario provoca:\n* Un acoplamiento excesivo de los tests en el dise√±o\n* Tener que realizar mucho testing de caja blanca\n* Y dificultar el cambio de dise√±o\n```\nNOTES/Las tres leyes de TDD.md\n```md\n---\nlibro: \"[[Clean Craftsmanship Disciplines, Standards and Ethics]]\"\ncap√≠tulo: 1-The Disciplines\npaginas: \"58\"\ntags:\n  - TDD\n---\nLas tres leyes o arbitrariedades de la [[Disciplina]] [[Test-Driven-Development]] son:\n>1. Write no production code until you have first written a test that fails due to the lack of that  production code. \n>2. Write no more of a test than is sufficient to fail or fail to compile. Resolve the failure by writing  some production code.\n>3. Write no more production code than will resolve the currently failing test. Once the test passes,  write more test code. \nLas tres leyes te encierran en un ciclo de unos pocos segundos de duraci√≥n.  En cada vuelta de ese ciclo, est√°s cambiando entre c√≥digo de prueba y c√≥digo de producci√≥n. Nunca podr√°s escribir simplemente una sentencia if o un bucle while. Nunca podr√°s simplemente escribir una funci√≥n. Estar√°s atrapado para siempre en este peque√±o bucle de cambiar contextos entre c√≥digo de prueba y c√≥digo de producci√≥n. \n```"},{"type":"text","text":"en que se relacionan?"}]}]},"responses":[{"timestamp":1749506316742,"id":"chatcmpl-Bgenc8yExKlj3LWcnenYqGp4pkqV0","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Las dos notas que compartiste est√°n relacionadas porque ambas abordan aspectos fundamentales del desarrollo de software usando **Test-Driven Development (TDD)** y en particular, el papel que juegan los **test unitarios** dentro de esta disciplina.\n\n### Relaci√≥n entre las dos notas:\n\n1. **Contexto com√∫n: TDD y test unitarios**  \n   Ambas notas est√°n enfocadas en la pr√°ctica de escribir tests primero y c√≥mo √©stos gu√≠an el desarrollo del c√≥digo (TDD). La nota *\"Las tres leyes de TDD\"* enumera las reglas que definen el ciclo estricto de TDD: escribir un test que falle, luego c√≥digo m√≠nimo para hacerlo pasar, etc. La nota *\"Test unitario (1)\"* profundiza en c√≥mo esos tests ‚Äî especialmente los tests unitarios o tests solitarios (que prueban un objeto o unidad en aislamiento)‚Äî son usados para validar el comportamiento esperado del c√≥digo.\n\n2. **El test unitario como pieza clave dentro del ciclo TDD**  \n   La nota *\"Test unitario (1)\"* explica qu√© es un test unitario, c√≥mo se prueba un objeto aisladamente simulando sus dependencias para enfocarse en su comportamiento concreto. Esto se enlaza con las tres leyes que exigen escribir tests peque√±os y espec√≠ficos primero (ley 1) antes de implementar cualquier c√≥digo.\n\n3. **Disciplina y dise√±o guiado por pruebas**  \n   La nota sobre test unitario subraya que para probar un objeto aislado, se simulan dependencias, lo que implica que el dise√±o debe facilitarlo ‚Äî un aspecto pr√°ctico que surge de seguir la disciplina de TDD, como se muestra en las leyes. El ciclo corto de escribir tests y c√≥digo que las leyes describen fomenta que el dise√±o evolucione junto con los tests.\n\n4. **Implicaciones y retos en el desarrollo**  \n   La cr√≠tica en la nota de los tests unitarios (acoplamiento de tests al dise√±o, testing de caja blanca, dificultad para cambiar dise√±o) es una consecuencia directa del enfoque estricto de TDD que las tres leyes propugnan. En otras palabras, al seguir rigurosamente las tres leyes, uno termina generando muchos tests unitarios muy ligados al dise√±o interno, lo que puede hacer m√°s dif√≠cil la refactorizaci√≥n.\n\n---\n\n### En resumen:\n- **Las tres leyes de TDD** establecen el marco metodol√≥gico y el ciclo de trabajo en TDD.\n- **Los tests unitarios** son el tipo de tests que se construyen siguiendo ese ciclo, buscando probar piezas peque√±as (unidades/objetos) en aislamiento.\n- El proceso de escribir esos tests unitarios primero (como obliga la primera ley) gu√≠a el dise√±o del c√≥digo.\n- El enfoque estricto puede provocar acoplamientos entre tests y dise√±o, lo que afecta la flexibilidad del c√≥digo a largo plazo.\n\n---\n\nSi quieres, puedo ayudarte a ampliar esta relaci√≥n con ejemplos, o explicarte c√≥mo manejar esos retos que mencionas en la nota del test unitario. ¬øQuieres?"}}],"usage":{},"raw":{"id":"chatcmpl-Bgenc8yExKlj3LWcnenYqGp4pkqV0","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Las dos notas que compartiste est√°n relacionadas porque ambas abordan aspectos fundamentales del desarrollo de software usando **Test-Driven Development (TDD)** y en particular, el papel que juegan los **test unitarios** dentro de esta disciplina.\n\n### Relaci√≥n entre las dos notas:\n\n1. **Contexto com√∫n: TDD y test unitarios**  \n   Ambas notas est√°n enfocadas en la pr√°ctica de escribir tests primero y c√≥mo √©stos gu√≠an el desarrollo del c√≥digo (TDD). La nota *\"Las tres leyes de TDD\"* enumera las reglas que definen el ciclo estricto de TDD: escribir un test que falle, luego c√≥digo m√≠nimo para hacerlo pasar, etc. La nota *\"Test unitario (1)\"* profundiza en c√≥mo esos tests ‚Äî especialmente los tests unitarios o tests solitarios (que prueban un objeto o unidad en aislamiento)‚Äî son usados para validar el comportamiento esperado del c√≥digo.\n\n2. **El test unitario como pieza clave dentro del ciclo TDD**  \n   La nota *\"Test unitario (1)\"* explica qu√© es un test unitario, c√≥mo se prueba un objeto aisladamente simulando sus dependencias para enfocarse en su comportamiento concreto. Esto se enlaza con las tres leyes que exigen escribir tests peque√±os y espec√≠ficos primero (ley 1) antes de implementar cualquier c√≥digo.\n\n3. **Disciplina y dise√±o guiado por pruebas**  \n   La nota sobre test unitario subraya que para probar un objeto aislado, se simulan dependencias, lo que implica que el dise√±o debe facilitarlo ‚Äî un aspecto pr√°ctico que surge de seguir la disciplina de TDD, como se muestra en las leyes. El ciclo corto de escribir tests y c√≥digo que las leyes describen fomenta que el dise√±o evolucione junto con los tests.\n\n4. **Implicaciones y retos en el desarrollo**  \n   La cr√≠tica en la nota de los tests unitarios (acoplamiento de tests al dise√±o, testing de caja blanca, dificultad para cambiar dise√±o) es una consecuencia directa del enfoque estricto de TDD que las tres leyes propugnan. En otras palabras, al seguir rigurosamente las tres leyes, uno termina generando muchos tests unitarios muy ligados al dise√±o interno, lo que puede hacer m√°s dif√≠cil la refactorizaci√≥n.\n\n---\n\n### En resumen:\n- **Las tres leyes de TDD** establecen el marco metodol√≥gico y el ciclo de trabajo en TDD.\n- **Los tests unitarios** son el tipo de tests que se construyen siguiendo ese ciclo, buscando probar piezas peque√±as (unidades/objetos) en aislamiento.\n- El proceso de escribir esos tests unitarios primero (como obliga la primera ley) gu√≠a el dise√±o del c√≥digo.\n- El enfoque estricto puede provocar acoplamientos entre tests y dise√±o, lo que afecta la flexibilidad del c√≥digo a largo plazo.\n\n---\n\nSi quieres, puedo ayudarte a ampliar esta relaci√≥n con ejemplos, o explicarte c√≥mo manejar esos retos que mencionas en la nota del test unitario. ¬øQuieres?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749506269151-1749506269152","thread_key":"Untitled Chat 1749506269151","stream":true,"context_key":"1749506269152","class_name":"SmartCompletion","user_message":"en que se relacionan?","new_user_message":true},
"smart_completions:Untitled Chat 1749508539908-1749510228702": {"completion":{"request":{"messages":[{"role":"assistant","content":""},{"role":"user","content":[{"type":"text","text":"Hazme un post para compartir mis notas"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Bases de Lean UX (Product).md\n    ‚îú‚îÄ‚îÄ Ciclos cortos de trabajo ventaja competitiva.md\n    ‚îú‚îÄ‚îÄ Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n    ‚îî‚îÄ‚îÄ Lean UX (Product).md\n\nNOTES/Bases de Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: 366-\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n### Lean Startup \n Lean Startup utiliza un ciclo de retroalimentaci√≥n llamado ‚Äúconstruir-medir-aprender‚Äù para minimizar el riesgo del proyecto y lograr que los equipos comiencen a construir y aprender r√°pidamente. Los equipos crean Productos M√≠nimos Viables (MVP, por sus siglas en ingl√©s) y los lanzan r√°pidamente para iniciar el proceso de aprendizaje lo antes posible. \n \n Como dice Eric, ‚ÄúLean Startup aboga inicialmente por la creaci√≥n de prototipos r√°pidos dise√±ados para probar suposiciones de mercado y utiliza la retroalimentaci√≥n de los clientes para evolucionarlos mucho m√°s r√°pido que mediante pr√°cticas tradicionales de ingenier√≠a de software‚Äù. Contin√∫a: ‚ÄúLos procesos Lean Startup reducen el desperdicio al aumentar la frecuencia de contacto con clientes reales, probando y evitando as√≠ suposiciones de mercado incorrectas lo antes posible‚Äù. \n \n Lean UX es una aplicaci√≥n directa de esta filosof√≠a a la pr√°ctica del dise√±o de productos. Cada dise√±o es una soluci√≥n empresarial propuesta: una hip√≥tesis. Tu objetivo es validar la soluci√≥n propuesta de la manera m√°s eficiente posible utilizando la retroalimentaci√≥n de los clientes. Lo m√°s peque√±o que puedes construir para probar cada hip√≥tesis es tu MVP. El MVP no necesita estar hecho de c√≥digo: puede ser una aproximaci√≥n a la experiencia final; ¬°incluso podr√≠a no ser un producto! Recoges lo que aprendes de tu MVP y desarrollas tus ideas. Luego, lo vuelves a hacer.\n### Design Thinking\n El Design Thinking observa los sistemas y nos ayuda a aplicar herramientas de dise√±o a problemas m√°s amplios. Se basa en la colaboraci√≥n, la iteraci√≥n, la creaci√≥n y la empat√≠a como elementos centrales para la resoluci√≥n de problemas desde una perspectiva hol√≠stica.  \n### Agile\nLean UX aplica los cuatro valores principales del desarrollo √°gil al dise√±o de productos:\n* **Individuos e interacciones sobre procesos y herramientas**\n\t* favorecer la colaboraci√≥n y la conversaci√≥n por encima de los entregables y los procesos r√≠gidos. \n\t* Involucra a todo el equipo para generar ideas desde diversos puntos de vista. \n\t* Fomenta el intercambio libre y frecuente de ideas para que el equipo pueda debatir, decidir y avanzar r√°pidamente.\n* **Software funcionando sobre documentaci√≥n exhaustiva**: \n\t* Cada problema de negocio tiene infinitas soluciones, y cada miembro del equipo tendr√° una opini√≥n sobre cu√°l es la mejor. \n\t* El reto es averiguar cu√°l soluci√≥n es la m√°s viable. A veces, es dif√≠cil o imposible predecir de antemano qu√© soluci√≥n funcionar√°. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a trav√©s de software funcional) antes, el equipo puede evaluar r√°pidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboraci√≥n con el cliente sobre negociaci√≥n contractual**\n\t* Colaborar con tus compa√±eros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n\t* Crea consenso detr√°s de las decisiones. ¬øEl resultado? Iteraciones m√°s r√°pidas, participaci√≥n real en la creaci√≥n del producto e inversi√≥n del equipo en el aprendizaje validado. \n\t* Tambi√©n reduce la dependencia de la documentaci√≥n extensa porque todos en el equipo ya han participado en la toma de decisiones.\n\t* La colaboraci√≥n genera alineaci√≥n de manera m√°s efectiva que la comunicaci√≥n escrita, la discusi√≥n y la defensa elaborada.\nResponder al cambio sobre seguir un plan. La suposici√≥n en Lean UX es que los dise√±os iniciales del producto estar√°n equivocados, por lo que el objetivo del equipo debe ser descubrir lo que est√° mal lo antes posible. Tan pronto como el equipo descubre qu√© est√° funcionando y qu√© no, ajustan sus propuestas y prueban de nuevo. Esta retroalimentaci√≥n del mercado mantiene a los equipos √°giles, gui√°ndolos constantemente en una direcci√≥n ‚Äúm√°s correcta‚Äù.\n## UX (User Experience)\nUX abarca varios campos del dise√±o, incluyendo el dise√±o de interacci√≥n, la arquitectura de la informaci√≥n, el dise√±o gr√°fico y muchos otros. Pero el coraz√≥n de la pr√°ctica de UX es que comienza identificando las necesidades humanas‚Äîlas necesidades de los usuarios del sistema.\n```\nNOTES/Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncap√≠tulo: 0-Prefacio\npaginas: \"207\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Ciclos cortos de trabajo ventaja competitiva.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"266\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© significa esto?\n Al lanzar temprano y con frecuencia, obtener retroalimentaci√≥n del mercado e iterar en funci√≥n de lo que aprenden para crear una conversaci√≥n continua con los clientes.\n## ¬øPor qu√©?\n En esencia, est√°n descubriendo su producto al mismo tiempo que lo entregan. Esto tiene muchos beneficios, pero quiz√°s los dos m√°s importantes son: \n * La capacidad de aprender, de manera continua y r√°pida, qu√© tan bien sus productos est√°n satisfaciendo las necesidades de los clientes.\n * Elevar las expectativas de los clientes en cuanto a la calidad del producto y los tiempos de respuesta de la empresa ante sus inquietudes y comentarios. \n * Adem√°s, esta nueva forma de trabajar no se basa en tecnolog√≠as costosas. Las plataformas y servicios que lo hacen posible est√°n disponibles de forma gratuita o casi gratuita para pr√°cticamente cualquier equipo emprendedor. \n## ¬øC√≥mo impacta esto en el ambiente o mercado?\n Esto expone a las empresas establecidas a una amenaza que no hab√≠an conocido antes. Espec√≠ficamente, las barreras de entrada‚Äîen casi todos los √°mbitos‚Äînunca han sido tan bajas. Sin la necesidad de ‚Äúfabricar‚Äù un producto f√≠sico, cualquier persona con acceso a la web puede dise√±ar, programar y desplegar servicios para cualquier otra persona. Ante estas nuevas amenazas, los enfoques tradicionales de ‚Äútenerlo todo resuelto primero‚Äù simplemente no son viables. Entonces, ¬øqu√© deber√≠an hacer los equipos de producto?\n```\nNOTES/Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro|Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"384\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs la pr√°ctica de revelar la verdadera naturaleza de un producto de manera m√°s r√°pida, colaborativa y multifuncional. Trabajamos para construir una comprensi√≥n compartida del cliente, sus necesidades, nuestras soluciones propuestas y nuestra definici√≥n de √©xito. Priorizamos el aprendizaje sobre la entrega para fundamentar nuestras decisiones con evidencia.\n## ¬øCu√°les son sus principios?\n### Principios para Guiar la Organizaci√≥n del Equipo\n* Equipos multifuncionales \n* Equipos peque√±os, dedicados, colocalizados \n* Equipos autosuficientes y empoderados \n* Equipos enfocados en resolver problemas\n### Principios para Guiar la Cultura\n### Principios para Guiar el Proceso\n```"},{"type":"text","text":"Hazme un post para compartir mis notas"}]}],"tools":[{"type":"function","function":{"name":"lookup_context","description":"Common, frequently used. Performs a semantic search of the user's data. Use to respond to 'Based on my notes...' or any other query that might require surfacing unspecified content. Minimum 3 hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. Each hypothetical is a semantic representation of content that's likely relevant to the user's request. Hypothetical notes always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3.","parameters":{"type":"object","properties":{"hypothetical_1":{"type":"string","description":"Always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3."},"hypothetical_2":{"type":"string","description":"Must be distinct from and not share any breadcrumbs with hypothetical_1."},"hypothetical_3":{"type":"string","description":"Must be distinct from hypothetical_1 and hypothetical_2."},"in_folder":{"type":"string","description":"Optional. Only use if requested by the user. Limit the lookup to items in this folder."}},"required":["hypothetical_1","hypothetical_2"]}}}],"tool_choice":{"type":"function","function":{"name":"lookup_context"}}},"responses":[{"timestamp":1749510274597,"id":"chatcmpl-BgfpYV0FIpZp8YqEDfdXKbp5XwPid","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"","tool_calls":[{"id":"call_WVsJxexfjzw5DBuOgjpPiWlm","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"NOTES/Bases de Lean UX (Product).md: Post sobre los fundamentos de Lean UX, explicando c√≥mo combina Lean Startup, Design Thinking y Agile para dise√±ar productos eficaces y centrados en el usuario.\",\"hypothetical_2\":\"NOTES/Ciclos cortos de trabajo ventaja competitiva.md: Post sobre la ventaja competitiva de aplicar ciclos cortos de trabajo para lanzar r√°pido, obtener feedback continuo y adaptarse al mercado.\",\"hypothetical_3\":\"NOTES/Lean UX (Product).md: Post sobre qu√© es Lean UX, sus principios organizacionales, culturales y de proceso, y c√≥mo ayuda a construir productos basados en aprendizaje validado.\"}"}}]}}],"usage":{},"raw":{"id":"chatcmpl-BgfpYV0FIpZp8YqEDfdXKbp5XwPid","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"","tool_calls":[{"id":"call_WVsJxexfjzw5DBuOgjpPiWlm","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"NOTES/Bases de Lean UX (Product).md: Post sobre los fundamentos de Lean UX, explicando c√≥mo combina Lean Startup, Design Thinking y Agile para dise√±ar productos eficaces y centrados en el usuario.\",\"hypothetical_2\":\"NOTES/Ciclos cortos de trabajo ventaja competitiva.md: Post sobre la ventaja competitiva de aplicar ciclos cortos de trabajo para lanzar r√°pido, obtener feedback continuo y adaptarse al mercado.\",\"hypothetical_3\":\"NOTES/Lean UX (Product).md: Post sobre qu√© es Lean UX, sus principios organizacionales, culturales y de proceso, y c√≥mo ayuda a construir productos basados en aprendizaje validado.\"}"}}]}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749508539908-1749510228702","thread_key":"Untitled Chat 1749508539908","stream":true,"context_key":"1749510228701","class_name":"SmartCompletion","user_message":"Hazme un post para compartir mis notas","new_user_message":true,"action_key":"lookup_context","actions":{"lookup_context":"1749510275393"}},
"smart_completions:Untitled Chat 1749508539908-1749510275396": {"completion":{"request":{"messages":[{"role":"assistant","content":""},{"role":"user","content":[{"type":"text","text":"Hazme un post para compartir mis notas"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Bases de Lean UX (Product).md\n    ‚îú‚îÄ‚îÄ Ciclos cortos de trabajo ventaja competitiva.md\n    ‚îú‚îÄ‚îÄ Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n    ‚îî‚îÄ‚îÄ Lean UX (Product).md\n\nNOTES/Bases de Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: 366-\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n### Lean Startup \n Lean Startup utiliza un ciclo de retroalimentaci√≥n llamado ‚Äúconstruir-medir-aprender‚Äù para minimizar el riesgo del proyecto y lograr que los equipos comiencen a construir y aprender r√°pidamente. Los equipos crean Productos M√≠nimos Viables (MVP, por sus siglas en ingl√©s) y los lanzan r√°pidamente para iniciar el proceso de aprendizaje lo antes posible. \n \n Como dice Eric, ‚ÄúLean Startup aboga inicialmente por la creaci√≥n de prototipos r√°pidos dise√±ados para probar suposiciones de mercado y utiliza la retroalimentaci√≥n de los clientes para evolucionarlos mucho m√°s r√°pido que mediante pr√°cticas tradicionales de ingenier√≠a de software‚Äù. Contin√∫a: ‚ÄúLos procesos Lean Startup reducen el desperdicio al aumentar la frecuencia de contacto con clientes reales, probando y evitando as√≠ suposiciones de mercado incorrectas lo antes posible‚Äù. \n \n Lean UX es una aplicaci√≥n directa de esta filosof√≠a a la pr√°ctica del dise√±o de productos. Cada dise√±o es una soluci√≥n empresarial propuesta: una hip√≥tesis. Tu objetivo es validar la soluci√≥n propuesta de la manera m√°s eficiente posible utilizando la retroalimentaci√≥n de los clientes. Lo m√°s peque√±o que puedes construir para probar cada hip√≥tesis es tu MVP. El MVP no necesita estar hecho de c√≥digo: puede ser una aproximaci√≥n a la experiencia final; ¬°incluso podr√≠a no ser un producto! Recoges lo que aprendes de tu MVP y desarrollas tus ideas. Luego, lo vuelves a hacer.\n### Design Thinking\n El Design Thinking observa los sistemas y nos ayuda a aplicar herramientas de dise√±o a problemas m√°s amplios. Se basa en la colaboraci√≥n, la iteraci√≥n, la creaci√≥n y la empat√≠a como elementos centrales para la resoluci√≥n de problemas desde una perspectiva hol√≠stica.  \n### Agile\nLean UX aplica los cuatro valores principales del desarrollo √°gil al dise√±o de productos:\n* **Individuos e interacciones sobre procesos y herramientas**\n\t* favorecer la colaboraci√≥n y la conversaci√≥n por encima de los entregables y los procesos r√≠gidos. \n\t* Involucra a todo el equipo para generar ideas desde diversos puntos de vista. \n\t* Fomenta el intercambio libre y frecuente de ideas para que el equipo pueda debatir, decidir y avanzar r√°pidamente.\n* **Software funcionando sobre documentaci√≥n exhaustiva**: \n\t* Cada problema de negocio tiene infinitas soluciones, y cada miembro del equipo tendr√° una opini√≥n sobre cu√°l es la mejor. \n\t* El reto es averiguar cu√°l soluci√≥n es la m√°s viable. A veces, es dif√≠cil o imposible predecir de antemano qu√© soluci√≥n funcionar√°. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a trav√©s de software funcional) antes, el equipo puede evaluar r√°pidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboraci√≥n con el cliente sobre negociaci√≥n contractual**\n\t* Colaborar con tus compa√±eros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n\t* Crea consenso detr√°s de las decisiones. ¬øEl resultado? Iteraciones m√°s r√°pidas, participaci√≥n real en la creaci√≥n del producto e inversi√≥n del equipo en el aprendizaje validado. \n\t* Tambi√©n reduce la dependencia de la documentaci√≥n extensa porque todos en el equipo ya han participado en la toma de decisiones.\n\t* La colaboraci√≥n genera alineaci√≥n de manera m√°s efectiva que la comunicaci√≥n escrita, la discusi√≥n y la defensa elaborada.\nResponder al cambio sobre seguir un plan. La suposici√≥n en Lean UX es que los dise√±os iniciales del producto estar√°n equivocados, por lo que el objetivo del equipo debe ser descubrir lo que est√° mal lo antes posible. Tan pronto como el equipo descubre qu√© est√° funcionando y qu√© no, ajustan sus propuestas y prueban de nuevo. Esta retroalimentaci√≥n del mercado mantiene a los equipos √°giles, gui√°ndolos constantemente en una direcci√≥n ‚Äúm√°s correcta‚Äù.\n## UX (User Experience)\nUX abarca varios campos del dise√±o, incluyendo el dise√±o de interacci√≥n, la arquitectura de la informaci√≥n, el dise√±o gr√°fico y muchos otros. Pero el coraz√≥n de la pr√°ctica de UX es que comienza identificando las necesidades humanas‚Äîlas necesidades de los usuarios del sistema.\n```\nNOTES/Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncap√≠tulo: 0-Prefacio\npaginas: \"207\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Ciclos cortos de trabajo ventaja competitiva.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"266\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© significa esto?\n Al lanzar temprano y con frecuencia, obtener retroalimentaci√≥n del mercado e iterar en funci√≥n de lo que aprenden para crear una conversaci√≥n continua con los clientes.\n## ¬øPor qu√©?\n En esencia, est√°n descubriendo su producto al mismo tiempo que lo entregan. Esto tiene muchos beneficios, pero quiz√°s los dos m√°s importantes son: \n * La capacidad de aprender, de manera continua y r√°pida, qu√© tan bien sus productos est√°n satisfaciendo las necesidades de los clientes.\n * Elevar las expectativas de los clientes en cuanto a la calidad del producto y los tiempos de respuesta de la empresa ante sus inquietudes y comentarios. \n * Adem√°s, esta nueva forma de trabajar no se basa en tecnolog√≠as costosas. Las plataformas y servicios que lo hacen posible est√°n disponibles de forma gratuita o casi gratuita para pr√°cticamente cualquier equipo emprendedor. \n## ¬øC√≥mo impacta esto en el ambiente o mercado?\n Esto expone a las empresas establecidas a una amenaza que no hab√≠an conocido antes. Espec√≠ficamente, las barreras de entrada‚Äîen casi todos los √°mbitos‚Äînunca han sido tan bajas. Sin la necesidad de ‚Äúfabricar‚Äù un producto f√≠sico, cualquier persona con acceso a la web puede dise√±ar, programar y desplegar servicios para cualquier otra persona. Ante estas nuevas amenazas, los enfoques tradicionales de ‚Äútenerlo todo resuelto primero‚Äù simplemente no son viables. Entonces, ¬øqu√© deber√≠an hacer los equipos de producto?\n```\nNOTES/Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro|Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"384\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs la pr√°ctica de revelar la verdadera naturaleza de un producto de manera m√°s r√°pida, colaborativa y multifuncional. Trabajamos para construir una comprensi√≥n compartida del cliente, sus necesidades, nuestras soluciones propuestas y nuestra definici√≥n de √©xito. Priorizamos el aprendizaje sobre la entrega para fundamentar nuestras decisiones con evidencia.\n## ¬øCu√°les son sus principios?\n### Principios para Guiar la Organizaci√≥n del Equipo\n* Equipos multifuncionales \n* Equipos peque√±os, dedicados, colocalizados \n* Equipos autosuficientes y empoderados \n* Equipos enfocados en resolver problemas\n### Principios para Guiar la Cultura\n### Principios para Guiar el Proceso\n```"},{"type":"text","text":"Hazme un post para compartir mis notas"},{"type":"text","text":"‚îú‚îÄ‚îÄ ARTICLES/escritas/\n‚îÇ   ‚îú‚îÄ‚îÄ Una estrategia de testing para un desarrollo productivo y eficaz.md#\n‚îÇ   ‚îú‚îÄ‚îÄ Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests\n‚îÇ   ‚îú‚îÄ‚îÄ Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{1}\n‚îÇ   ‚îú‚îÄ‚îÄ Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{5}\n‚îÇ   ‚îî‚îÄ‚îÄ Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{8}\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Ciclos de refactorizaci√≥n.md##¬øQu√© son?\n    ‚îú‚îÄ‚îÄ Ciclos de refactorizaci√≥n.md##¬øQu√© son?#{1}\n    ‚îú‚îÄ‚îÄ Desarrollo de software iterativo-incremental (1).md##¬øQu√© es?#{1}\n    ‚îú‚îÄ‚îÄ Desarrollo de software iterativo-incremental (1).md##Opini√≥n#{1}\n    ‚îî‚îÄ‚îÄ Los beneficios del testing (1).md#\n\nNOTES/Ciclos de refactorizaci√≥n.md##¬øQu√© son?#{1}\n```md##¬øQu√© son?#{1}\nSon momentos donde podemos introducir la pr√°ctica de la refactorizaci√≥n dentro de un ciclo de trabajo. En este caso, hablamos de una introducci√≥n que cuyo consumo de tiempo sea muy bajo pero que tiene una gran rentabilidad a largo plazo. Esto permite que el mayor tiempo se dedique a funcionalidades nuevas  y no al contrario, si no se hace ocurrir√≠a lo contrario.\nEjemplos de esto son:\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md#\n```md#\nEl desarrollo de software guiado por tests requiere un elemento fundamental para ser efectivo: un feedback r√°pido. Esto es crucial para la ejecuci√≥n continua de los tests, especialmente durante la etapa de mejora del dise√±o o refactorizaci√≥n. Sin embargo, lograrlo en un proyecto real no es tarea f√°cil, ya que el n√∫mero de tests puede superar el centenar, con diferentes tiempos de ejecuci√≥n. En mi experiencia, he enfrentado esta dificultad, lo que complicaba la realizaci√≥n de cambios en el c√≥digo. Con el tiempo, aprend√≠ que no era necesario ejecutar todos los tests al trabajar en una secci√≥n espec√≠fica de la aplicaci√≥n; bastaba con asegurarme de que el conjunto de elementos acoplados continuaran pasando los tests. Esto represent√≥ una mejora, y durante un tiempo fue el mejor enfoque que ten√≠a, hasta que comenc√© a ver los webinars de \"Dise√±o a la gorra\" de 10pines, dirigidos por Hern√°n Wilkinson. Estos tuvieron un gran impacto en m√≠, pues ampliaron mi perspectiva sobre el desarrollo guiado por tests. Aprend√≠ a enfocar los tests para aliviar el dolor de la ejecuci√≥n prolongada y, adem√°s, pude conectar estos conocimientos con otros relacionados con el dise√±o orientado a objetos y el testing. El resultado es una estrategia que actualmente en el equipo que estoy estamos aplicando, puesnos permite facilitar el cambio y, lo m√°s importante, obtener un feedback r√°pido. A continuaci√≥n, te explicar√© esta estrategia en detalle.\n```\nNOTES/Ciclos de refactorizaci√≥n.md##¬øQu√© son?\n```md##¬øQu√© son?\n## ¬øQu√© son?\nSon momentos donde podemos introducir la pr√°ctica de la refactorizaci√≥n dentro de un ciclo de trabajo. En este caso, hablamos de una introducci√≥n que cuyo consumo de tiempo sea muy bajo pero que tiene una gran rentabilidad a largo plazo. Esto permite que el mayor tiempo se dedique a funcionalidades nuevas  y no al contrario, si no se hace ocurrir√≠a lo contrario.\nEjemplos de esto son:\n* Conforme se termina de escribir un bloque y funciona, podemos volver a leerlo buscando si se puede hacer m√°s explicito\n* Cada d√≠a al empezar la jornada dedica diez minutos a leer el c√≥digo del d√≠a anterior\n* Al terminar una funcionalidad repasa el c√≥digo para identificar posibles sorpresas o mejorar.\n> Regla del Boy Scout: Mejorar algo el c√≥digo cuando se tiene que cambiar el c√≥digo. Mejora contin√∫a\n```\nNOTES/Desarrollo de software iterativo-incremental (1).md##Opini√≥n#{1}\n```md##Opini√≥n#{1}\nEn el  cap√≠tulo que se menciona esto me parece interesante y alineado con la perspectiva Agile, pero propone una forma de trabajar que se basa  en el tipo de testing que se basa en el alcance del c√≥digo. No se si es la mejor manera de momento.\n```\nNOTES/Desarrollo de software iterativo-incremental (1).md##¬øQu√© es?#{1}\n```md##¬øQu√© es?#{1}\nEs un enfoque de desarrollo de software donde se entregan en ciclos de desarrollo funcionalidades completas de punto a punto (e2e) como una porci√≥n de un sistema (incrementos). sobre cada funcionalidad desplegada hay un proceso de refinamiento de la implementaci√≥n tras contrastar los que ofrece la funcionalidad contra las necesidades de los usuarios por medio del feedback (iteraci√≥n) reduciendo la diferencia entre estos o errores. Por otro lado, esto permite cuantificar el trabajo, ver el progreso del desarrollo, as√≠ c√≥mo poder facilitar ajustes a los planes de desarrollo.\n \n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests\n```md##Un cambio de perspectiva sobre los tests\n## Un cambio de perspectiva sobre los tests\nAl trabajar con tests, es com√∫n hablar de los **Niveles de testing**, que incluyen: **Test unitario**, **Test de integraci√≥n** y **Test end to end**. Aunque esta es una forma extendida de categorizar los tests, otra perspectiva interesante es la que proponen [[Steve Freeman]] y [[Nat Pryce]] en su libro [[_Growing Object-Oriented Software, Guided by Tests_]]:\n- **[[Test unitario (1)|Test solitario]]s**: Verifican que un objeto se comporte como se espera. Si el objeto colabora con otros, estos deben ser simulados.\n- **[[Test de integraci√≥n (1)]]**: Confirman que nuestro c√≥digo interact√∫a correctamente con c√≥digo de terceros que no podemos modificar.\n- **T[[Test end to end (1)|Test de Aceptaci√≥n]]**: Eval√∫an de manera indirecta si el sistema en su totalidad (a trav√©s de flujos completos) funciona correctamente.\nAunque este enfoque es razonable, se centra principalmente en la granularidad o el alcance del c√≥digo. En el webinar [[Todo lo que quisiste saber sobre los tests]], [[Hernan Wilkinson]] presenta una visi√≥n m√°s interesante sobre los tests: la distinci√≥n entre tests para programadores y tests de infraestructura o integraci√≥n. Este enfoque proporciona una manera simple y √∫til de entender los tests:\n- **Tests para programadores**: Se enfocan en cumplir los requisitos funcionales y tienen como principal caracter√≠stica el proporcionar un ciclo de retroalimentaci√≥n r√°pido.\n- **Tests de infraestructura o integraci√≥n**: Verifican que nuestro c√≥digo se integre correctamente con tecnolog√≠as externas de las que depende nuestra aplicaci√≥n.\nResulta interesante que [[Robert C. Martin]] tambi√©n aborda esta visi√≥n en su libro [[Clean Craftsmanship Disciplines, Standards and Ethics]]:\n> [[Test de programador (1)]]: Test escrito por y para programadores con el prop√≥sito de especificar el comportamiento del sistema.\nEsta visi√≥n forma la base de la estrategia que propongo. Ahora queda por resolver: ¬øC√≥mo se implementa esto? Veamos los puntos clave.\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{8}\n```md##Un cambio de perspectiva sobre los tests#{8}\nResulta interesante que [[Robert C. Martin]] tambi√©n aborda esta visi√≥n en su libro [[Clean Craftsmanship Disciplines, Standards and Ethics]]:\n> [[Test de programador (1)]]: Test escrito por y para programadores con el prop√≥sito de especificar el comportamiento del sistema.\nEsta visi√≥n forma la base de la estrategia que propongo. Ahora queda por resolver: ¬øC√≥mo se implementa esto? Veamos los puntos clave.\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{1}\n```md##Un cambio de perspectiva sobre los tests#{1}\nAl trabajar con tests, es com√∫n hablar de los **Niveles de testing**, que incluyen: **Test unitario**, **Test de integraci√≥n** y **Test end to end**. Aunque esta es una forma extendida de categorizar los tests, otra perspectiva interesante es la que proponen [[Steve Freeman]] y [[Nat Pryce]] en su libro [[_Growing Object-Oriented Software, Guided by Tests_]]:\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{5}\n```md##Un cambio de perspectiva sobre los tests#{5}\nAunque este enfoque es razonable, se centra principalmente en la granularidad o el alcance del c√≥digo. En el webinar [[Todo lo que quisiste saber sobre los tests]], [[Hernan Wilkinson]] presenta una visi√≥n m√°s interesante sobre los tests: la distinci√≥n entre tests para programadores y tests de infraestructura o integraci√≥n. Este enfoque proporciona una manera simple y √∫til de entender los tests:\n```\nNOTES/Los beneficios del testing (1).md#\n```md#\n* Encontrar bugs\n* Documentaci√≥n viva del dise√±o\n* Permite aplazar decisiones de dise√±o\n* Soportar el aumento del nivel de abstracci√≥n a medida que nuevos requerimientos aparecen\n* Exponen los defectos de dise√±o \n\t* Un setup que cuesta escribir\n\t* Muchas dependencias\n\t* Dificultar de testear en definitiva\n```"}]},{"role":"assistant","content":""}]},"responses":[{"timestamp":1749510297346,"id":"chatcmpl-BgfpohUikFOOk7beM3mVuYLSatvZ5","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"¬°Hola a todos! üëã\n\nQuiero compartir con ustedes algunas **notas y aprendizajes clave** que he estado recopilando sobre Lean UX, desarrollo √°gil, y testing efectivo para crear productos m√°s eficientes y orientados al cliente. üöÄ\n\n---\n\n### 1. **Bases de Lean UX**  \nLean UX es una metodolog√≠a que integra los principios de Lean Startup, Design Thinking y Agile para crear productos con ciclos cortos de feedback.  \n- Usamos productos m√≠nimos viables (MVP) para validar hip√≥tesis con el menor desperdicio posible.  \n- Priorizamos la colaboraci√≥n, iteraci√≥n r√°pida y el aprendizaje continuo por encima de la documentaci√≥n extensa.  \n- La clave est√° en **iterar r√°pido y ajustar el rumbo con feedback real del mercado**.\n\n### 2. **Ciclos cortos de trabajo: ventaja competitiva**  \nTrabajar en ciclos cortos y lanzar frecuentemente no solo permite aprender r√°pidamente si el producto satisface las necesidades reales, sino que tambi√©n eleva las expectativas del cliente sobre tiempos de respuesta y calidad.  \nEsto reduce las barreras de entrada y obliga a ser m√°s √°giles para competir en mercados actuales.\n\n### 3. **No esperar demasiado para obtener feedback**  \nEsperar mucho para validar tus ideas es un desperdicio de tiempo y recursos. La retroalimentaci√≥n temprana es fundamental para ajustar r√°pidamente lo que no funciona y apostar por lo que s√≠.\n\n### 4. **Una estrategia de testing para un desarrollo productivo y eficaz**  \nEl testing es fundamental para mantener la calidad y facilitar cambios en el c√≥digo, pero los tests deben proveer retroalimentaci√≥n r√°pida.  \n- No es necesario ejecutar todos los tests para cada cambio, sino los que cubren el √°rea afectada.  \n- Distinguir entre tests para programadores (ciclos r√°pidos y funcionales) y tests de infraestructura o integraci√≥n (m√°s lentos y amplios).  \n- Esto permite acelerar el desarrollo sin sacrificar la confiabilidad.\n\n---\n\nüìö Estos apuntes me han ayudado a mejorar mi forma de trabajar, enfoc√°ndome en la eficiencia, colaboraci√≥n, aprendizaje y calidad continua. Si alguno quiere profundizar en alguno de estos temas, ¬°con gusto comparto m√°s detalles!\n\nGracias por leer y seguir aprendiendo juntos üôå.\n\n---\n\n#LeanUX #Agile #Testing #DesarrolloDeSoftware #Productividad #CicloDeFeedback #Innovaci√≥n #CalidadDeSoftware\n\n---\n\n¬øTe interesa que comparta m√°s notas o art√≠culos espec√≠ficos? ¬°D√©jamelo saber! üòä\n\n---\n\n¬°Listo para seguir construyendo mejor y m√°s r√°pido! üí°‚ú®"}}],"usage":{},"raw":{"id":"chatcmpl-BgfpohUikFOOk7beM3mVuYLSatvZ5","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"¬°Hola a todos! üëã\n\nQuiero compartir con ustedes algunas **notas y aprendizajes clave** que he estado recopilando sobre Lean UX, desarrollo √°gil, y testing efectivo para crear productos m√°s eficientes y orientados al cliente. üöÄ\n\n---\n\n### 1. **Bases de Lean UX**  \nLean UX es una metodolog√≠a que integra los principios de Lean Startup, Design Thinking y Agile para crear productos con ciclos cortos de feedback.  \n- Usamos productos m√≠nimos viables (MVP) para validar hip√≥tesis con el menor desperdicio posible.  \n- Priorizamos la colaboraci√≥n, iteraci√≥n r√°pida y el aprendizaje continuo por encima de la documentaci√≥n extensa.  \n- La clave est√° en **iterar r√°pido y ajustar el rumbo con feedback real del mercado**.\n\n### 2. **Ciclos cortos de trabajo: ventaja competitiva**  \nTrabajar en ciclos cortos y lanzar frecuentemente no solo permite aprender r√°pidamente si el producto satisface las necesidades reales, sino que tambi√©n eleva las expectativas del cliente sobre tiempos de respuesta y calidad.  \nEsto reduce las barreras de entrada y obliga a ser m√°s √°giles para competir en mercados actuales.\n\n### 3. **No esperar demasiado para obtener feedback**  \nEsperar mucho para validar tus ideas es un desperdicio de tiempo y recursos. La retroalimentaci√≥n temprana es fundamental para ajustar r√°pidamente lo que no funciona y apostar por lo que s√≠.\n\n### 4. **Una estrategia de testing para un desarrollo productivo y eficaz**  \nEl testing es fundamental para mantener la calidad y facilitar cambios en el c√≥digo, pero los tests deben proveer retroalimentaci√≥n r√°pida.  \n- No es necesario ejecutar todos los tests para cada cambio, sino los que cubren el √°rea afectada.  \n- Distinguir entre tests para programadores (ciclos r√°pidos y funcionales) y tests de infraestructura o integraci√≥n (m√°s lentos y amplios).  \n- Esto permite acelerar el desarrollo sin sacrificar la confiabilidad.\n\n---\n\nüìö Estos apuntes me han ayudado a mejorar mi forma de trabajar, enfoc√°ndome en la eficiencia, colaboraci√≥n, aprendizaje y calidad continua. Si alguno quiere profundizar en alguno de estos temas, ¬°con gusto comparto m√°s detalles!\n\nGracias por leer y seguir aprendiendo juntos üôå.\n\n---\n\n#LeanUX #Agile #Testing #DesarrolloDeSoftware #Productividad #CicloDeFeedback #Innovaci√≥n #CalidadDeSoftware\n\n---\n\n¬øTe interesa que comparta m√°s notas o art√≠culos espec√≠ficos? ¬°D√©jamelo saber! üòä\n\n---\n\n¬°Listo para seguir construyendo mejor y m√°s r√°pido! üí°‚ú®"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749508539908-1749510275396","thread_key":"Untitled Chat 1749508539908","stream":true,"context_key":"1749510275393","class_name":"SmartCompletion"},
"smart_completions:Untitled Chat 1749558763963-1749558787935": {"completion":{"request":{"messages":[{"role":"assistant","content":""},{"role":"user","content":[{"type":"text","text":"¬øQu√© tienen en com√∫n estas notas?"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Alfabeto proposicional alternativo.md\n    ‚îú‚îÄ‚îÄ Bases de Lean UX (Product).md\n    ‚îî‚îÄ‚îÄ Cada test es un transici√≥n de un finitos estado de m√°quina que describe el comportamiento del sistema.md\n\nNOTES/Alfabeto proposicional alternativo.md\n```md\n---\nlibro: \"[[L√≥gica y estructuras discretas 2024-2025]]\"\ncap√≠tulo: 1-Logica Proposicional\npaginas: Notaciones alternativas\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°l puede ser?\nHay alternativas a la simbolog√≠a propuesta en el [[Alfabeto Proposicional]]. \nPara las proposiciones se pueden usar letras del alfabeto como ¬†{p,q,r,s,t‚Ä¶}¬†en lugar de¬†{p1,p2,p3,‚Ä¶} para evitar el uso de sub√≠ndices\nPara las conectivas, en seg√∫n donde se mire, se pueden encontrar s√≠mbolos distintos para nombrarlas:\n- Entre otras opciones, se utiliza¬†&¬†para la conjunci√≥n,¬†|¬†para la disyunci√≥n o¬†‚àº¬†para la negaci√≥n.\n- La Electr√≥nica Digital permite materializar f√≥rmulas l√≥gicas en forma de circuitos combinacionales. Y en ese contexto, es habitual notar la disyunci√≥n como una suma¬†(P+Q), la conjunci√≥n como un producto¬†(P‚ãÖQ)¬†y la negaci√≥n con una sobrel√≠nea¬†P‚Äï (P con el sombrerito.\n```\nNOTES/Bases de Lean UX (Product).md\n```md\n---\nlibro: \"[[BIBLIOGRAPHY/BOOKS/Lean UX (Product) - Libro]]\"\ncap√≠tulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: 366-\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n### Lean Startup \n Lean Startup utiliza un ciclo de retroalimentaci√≥n llamado ‚Äúconstruir-medir-aprender‚Äù para minimizar el riesgo del proyecto y lograr que los equipos comiencen a construir y aprender r√°pidamente. Los equipos crean Productos M√≠nimos Viables (MVP, por sus siglas en ingl√©s) y los lanzan r√°pidamente para iniciar el proceso de aprendizaje lo antes posible. \n \n Como dice Eric, ‚ÄúLean Startup aboga inicialmente por la creaci√≥n de prototipos r√°pidos dise√±ados para probar suposiciones de mercado y utiliza la retroalimentaci√≥n de los clientes para evolucionarlos mucho m√°s r√°pido que mediante pr√°cticas tradicionales de ingenier√≠a de software‚Äù. Contin√∫a: ‚ÄúLos procesos Lean Startup reducen el desperdicio al aumentar la frecuencia de contacto con clientes reales, probando y evitando as√≠ suposiciones de mercado incorrectas lo antes posible‚Äù. \n \n Lean UX es una aplicaci√≥n directa de esta filosof√≠a a la pr√°ctica del dise√±o de productos. Cada dise√±o es una soluci√≥n empresarial propuesta: una hip√≥tesis. Tu objetivo es validar la soluci√≥n propuesta de la manera m√°s eficiente posible utilizando la retroalimentaci√≥n de los clientes. Lo m√°s peque√±o que puedes construir para probar cada hip√≥tesis es tu MVP. El MVP no necesita estar hecho de c√≥digo: puede ser una aproximaci√≥n a la experiencia final; ¬°incluso podr√≠a no ser un producto! Recoges lo que aprendes de tu MVP y desarrollas tus ideas. Luego, lo vuelves a hacer.\n### Design Thinking\n El Design Thinking observa los sistemas y nos ayuda a aplicar herramientas de dise√±o a problemas m√°s amplios. Se basa en la colaboraci√≥n, la iteraci√≥n, la creaci√≥n y la empat√≠a como elementos centrales para la resoluci√≥n de problemas desde una perspectiva hol√≠stica.  \n### Agile\nLean UX aplica los cuatro valores principales del desarrollo √°gil al dise√±o de productos:\n* **Individuos e interacciones sobre procesos y herramientas**\n\t* favorecer la colaboraci√≥n y la conversaci√≥n por encima de los entregables y los procesos r√≠gidos. \n\t* Involucra a todo el equipo para generar ideas desde diversos puntos de vista. \n\t* Fomenta el intercambio libre y frecuente de ideas para que el equipo pueda debatir, decidir y avanzar r√°pidamente.\n* **Software funcionando sobre documentaci√≥n exhaustiva**: \n\t* Cada problema de negocio tiene infinitas soluciones, y cada miembro del equipo tendr√° una opini√≥n sobre cu√°l es la mejor. \n\t* El reto es averiguar cu√°l soluci√≥n es la m√°s viable. A veces, es dif√≠cil o imposible predecir de antemano qu√© soluci√≥n funcionar√°. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a trav√©s de software funcional) antes, el equipo puede evaluar r√°pidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboraci√≥n con el cliente sobre negociaci√≥n contractual**\n\t* Colaborar con tus compa√±eros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n\t* Crea consenso detr√°s de las decisiones. ¬øEl resultado? Iteraciones m√°s r√°pidas, participaci√≥n real en la creaci√≥n del producto e inversi√≥n del equipo en el aprendizaje validado. \n\t* Tambi√©n reduce la dependencia de la documentaci√≥n extensa porque todos en el equipo ya han participado en la toma de decisiones.\n\t* La colaboraci√≥n genera alineaci√≥n de manera m√°s efectiva que la comunicaci√≥n escrita, la discusi√≥n y la defensa elaborada.\nResponder al cambio sobre seguir un plan. La suposici√≥n en Lean UX es que los dise√±os iniciales del producto estar√°n equivocados, por lo que el objetivo del equipo debe ser descubrir lo que est√° mal lo antes posible. Tan pronto como el equipo descubre qu√© est√° funcionando y qu√© no, ajustan sus propuestas y prueban de nuevo. Esta retroalimentaci√≥n del mercado mantiene a los equipos √°giles, gui√°ndolos constantemente en una direcci√≥n ‚Äúm√°s correcta‚Äù.\n## UX (User Experience)\nUX abarca varios campos del dise√±o, incluyendo el dise√±o de interacci√≥n, la arquitectura de la informaci√≥n, el dise√±o gr√°fico y muchos otros. Pero el coraz√≥n de la pr√°ctica de UX es que comienza identificando las necesidades humanas‚Äîlas necesidades de los usuarios del sistema.\n```\nNOTES/Cada test es un transici√≥n de un finitos estado de m√°quina que describe el comportamiento del sistema.md\n```md\n---\nlibro: \"[[Clean Craftsmanship Disciplines, Standards and Ethics]]\"\ncap√≠tulo: 1-The Disciplines\npaginas: 135-136\ntags:\n  - TDD\n  - Testing\n  - Observaci√≥n\n---\n>we can deduce from this is that every test you write is a transition of  the finite state machine that describes the behavior of the system. \n## ¬øPor qu√©?\nCada programa es una m√°quina de estados finitos porque el ordenador en s√≠ hace transiciones de un estado a otro tras cada ejecuci√≥n de instrucci√≥n en el procesador\n```"},{"type":"text","text":"¬øQu√© tienen en com√∫n estas notas?"}]}]},"responses":[{"timestamp":1749558816300,"id":"chatcmpl-BgsSNGcwMYeM0FQCeFUKY91GXhrAm","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Las tres notas que muestras tienen en com√∫n que son **extractos o res√∫menes tomados de libros o fuentes especializadas, con el formato de notas de estudio o fichas para organizar conocimiento** dentro de un sistema de gesti√≥n de notas (como Obsidian o similar). Esto se puede deducir de varios aspectos:\n\n1. **Metadatos frontmatter (YAML)**\n   - Cada nota inicia con un bloque `---` que contiene campos como:\n     - `libro` (el t√≠tulo o referencia del libro o fuente).\n     - `cap√≠tulo`.\n     - `p√°ginas`.\n     - `tags`.\n     - `num_veces_leida`.\n   Esto indica que son fragmentos organizados y referenciados para un trabajo de estudio o investigaci√≥n.\n\n2. **Formato Markdown enriquecido con enlaces internos**\n   - Uso de enlaces internos tipo `[[L√≥gica y estructuras discretas 2024-2025]]`, algo t√≠pico de apps como Obsidian para conectar notas.\n   - Uso de encabezados `##` para marcar secciones.\n\n3. **Tem√°tica centrada en conocimiento t√©cnico o cient√≠fico**\n   - La primera nota es sobre l√≥gica proposicional y notaciones alternativas en matem√°ticas o l√≥gica computacional.\n   - La segunda nota se refiere a metodolog√≠as √°giles, espec√≠ficamente Lean UX, Lean Startup, Agile y Design Thinking, enfocado en producto y dise√±o.\n   - La tercera nota trata de programaci√≥n, tests y modelos de m√°quina de estados finitos, relacionado con ingenier√≠a de software.\n\n4. **Objetivo: comprender, sintetizar y aplicar conocimiento**\n   - Son explicaciones breves que a modo de resumen recogen ideas clave de un cap√≠tulo o texto mayor.\n   - Las notas buscan servir como referencias r√°pidas para revisar conceptos esenciales.\n\n---\n\n**En resumen:**\n\n- Son notas de estudio tomadas de fuentes bibliogr√°ficas.\n- Usan un formato estructurado (frontmatter YAML + Markdown).\n- Contienen conocimiento t√©cnico o especializado.\n- Est√°n pensadas para ser usadas en un sistema enlazado de notas (PKM, Obsidian, Zettelkasten).\n- Sirven como res√∫menes, extractos o anotaciones para aprendizaje y consulta futura.\n\n---\n\nSi quieres puedo ayudarte a extraer la idea principal de cada nota, encontrar etiquetas comunes, o sugerir c√≥mo mejorar su organizaci√≥n. ¬øQuieres?"}}],"usage":{},"raw":{"id":"chatcmpl-BgsSNGcwMYeM0FQCeFUKY91GXhrAm","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Las tres notas que muestras tienen en com√∫n que son **extractos o res√∫menes tomados de libros o fuentes especializadas, con el formato de notas de estudio o fichas para organizar conocimiento** dentro de un sistema de gesti√≥n de notas (como Obsidian o similar). Esto se puede deducir de varios aspectos:\n\n1. **Metadatos frontmatter (YAML)**\n   - Cada nota inicia con un bloque `---` que contiene campos como:\n     - `libro` (el t√≠tulo o referencia del libro o fuente).\n     - `cap√≠tulo`.\n     - `p√°ginas`.\n     - `tags`.\n     - `num_veces_leida`.\n   Esto indica que son fragmentos organizados y referenciados para un trabajo de estudio o investigaci√≥n.\n\n2. **Formato Markdown enriquecido con enlaces internos**\n   - Uso de enlaces internos tipo `[[L√≥gica y estructuras discretas 2024-2025]]`, algo t√≠pico de apps como Obsidian para conectar notas.\n   - Uso de encabezados `##` para marcar secciones.\n\n3. **Tem√°tica centrada en conocimiento t√©cnico o cient√≠fico**\n   - La primera nota es sobre l√≥gica proposicional y notaciones alternativas en matem√°ticas o l√≥gica computacional.\n   - La segunda nota se refiere a metodolog√≠as √°giles, espec√≠ficamente Lean UX, Lean Startup, Agile y Design Thinking, enfocado en producto y dise√±o.\n   - La tercera nota trata de programaci√≥n, tests y modelos de m√°quina de estados finitos, relacionado con ingenier√≠a de software.\n\n4. **Objetivo: comprender, sintetizar y aplicar conocimiento**\n   - Son explicaciones breves que a modo de resumen recogen ideas clave de un cap√≠tulo o texto mayor.\n   - Las notas buscan servir como referencias r√°pidas para revisar conceptos esenciales.\n\n---\n\n**En resumen:**\n\n- Son notas de estudio tomadas de fuentes bibliogr√°ficas.\n- Usan un formato estructurado (frontmatter YAML + Markdown).\n- Contienen conocimiento t√©cnico o especializado.\n- Est√°n pensadas para ser usadas en un sistema enlazado de notas (PKM, Obsidian, Zettelkasten).\n- Sirven como res√∫menes, extractos o anotaciones para aprendizaje y consulta futura.\n\n---\n\nSi quieres puedo ayudarte a extraer la idea principal de cada nota, encontrar etiquetas comunes, o sugerir c√≥mo mejorar su organizaci√≥n. ¬øQuieres?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749558763963-1749558787935","thread_key":"Untitled Chat 1749558763963","stream":true,"context_key":"1749558787935","class_name":"SmartCompletion","user_message":"¬øQu√© tienen en com√∫n estas notas?","new_user_message":true},
"smart_completions:Untitled Chat 1752161883212-1752161883212": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero que me hagas un art√≠culo con todo este contenido"},{"type":"text","text":"‚îú‚îÄ‚îÄ BIBLIOGRAPHY/CONFERENCE-TALKS/\n‚îÇ   ‚îî‚îÄ‚îÄ Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Beneficios de escribir c√≥digo puro para la l√≥gica de dominio.md\n    ‚îú‚îÄ‚îÄ Code smells en tu c√≥digo core.md\n    ‚îú‚îÄ‚îÄ Dependency injection.md\n    ‚îú‚îÄ‚îÄ Dependency interpretation.md\n    ‚îú‚îÄ‚îÄ Dependency parametrization.md\n    ‚îú‚îÄ‚îÄ Dependency rejection.md\n    ‚îú‚îÄ‚îÄ Domain-centric workflow.md\n    ‚îú‚îÄ‚îÄ En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo  puro .md\n    ‚îú‚îÄ‚îÄ Estrategias para gestionar dependencias.md\n    ‚îú‚îÄ‚îÄ Functional Core, Imperative Shell Architecture.md\n    ‚îú‚îÄ‚îÄ Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n    ‚îú‚îÄ‚îÄ Las dependencias son elementos que introducen no-determinismo a una operaci√≥n.md\n    ‚îú‚îÄ‚îÄ Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ‚îú‚îÄ‚îÄ Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    ‚îî‚îÄ‚îÄ Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n\nNOTES/Code smells en tu c√≥digo core.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQue son?\nSon s√≠ntomas de que tu c√≥digo tiene alguna operaci√≥n IO oculta o al menos no expl√≠tica.\n## ¬øCu√°les son?\n* Hay alg√∫n proceso as√≠ncrono\n* Se lanza alguna excepci√≥n\n* Tienes lanzamiento de excepciones para gestionar el flujo de ejecuci√≥n en lugar de retornar un valor \n```\nNOTES/Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\n* El c√≥digo IO no forma parte del dominio. Adem√°s, cuando se entremezclan dificulta la comprensi√≥n de la l√≥gica de negocio.\n* El c√≥digo IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El c√≥digo IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Domain-centric workflow.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"2.44\"\nminutoFin: \"6.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nUn workflow es equivalente a una historia de usuario. Desde esto, [[Scott Wlaschin]] propone trabajar en una arquitectura [[Domain Driving Desing]] porque pone la l√≥gica de dominio en el centro y la l√≥gica IO en los bordes. Por tanto un domain-centric workflow se trata de un \"slice\" c√≥mo se ilustra en la siguiente imagen:\n![[Pasted image 20250709203856.png]]\nCon esta arquitectura, [[Scott Wlaschin]] consigue cumplir principio de dise√±o de [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]]  de una manera efectiva.\nUn caso de uso se ilustra a continuaci√≥n:\n![[Pasted image 20250709204031.png]]\n```\nNOTES/En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo  puro .md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"6.17\"\nminutoFin: \"10.45\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son los principios?\n* El c√≥digo debe ser comprensible. Esto significa que:\n\t* Todo debe ser explicitamente dado por los inputs para que no nos preguntemos ¬øQu√© es lo que necesitamos para que se haga la operaci√≥n X?\n\t* Debe haber un output, para que entendamos cual es el resultado de la operaci√≥n y podamos verificarlo\n* El c√≥digo debe ser determinista: Dados unos inputs, siempre debemos obtener los mismos outputs\n* No tiene side-effects: No se produce ning√∫n proceso adicional que salga del √°mbito del proceso y que adem√°s no vaya al \"exterior\" de la applicaci√≥n (IO)\n```\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el c√≥digo de domino est√° en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enf√°sis en que [[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo \"puro\"]] y [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]] y este ser√° impuro e imperativo.\nAdem√°s, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicaci√≥n en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el c√≥digo es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el c√≥digo de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"18.32\"\nminutoFin: \"21.42\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es esto?\n[[Scott Wlaschin]] propone, en lugar de crear una interfaz o abstracci√≥n desde la cual hacer varias implementaciones, simplemente reemplazar el c√≥digo IO de los bordes y mantener el c√≥digo de dominio. De esta manera, propone trabajar como si piezas de lego se trataran. Al final, el reemplazo de c√≥digo IO seguiran recuperando o mandando los mismos datos y por tanto el c√≥digo de dominio le dar√° igual mientras estos den los inputs y procesen los outputs de este.\nUn ejemplo de esto es lo siguiente:\n![[Pasted image 20250709212804.png]]\n![[Pasted image 20250709212824.png]]\n![[Pasted image 20250709212849.png]]\n```\nNOTES/Beneficios de escribir c√≥digo puro para la l√≥gica de dominio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"21.54\"\nminutoFin: \"33.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n* Los inputs y output son explicitos y por tanto es comprensible c√≥mo usarlo\n* Es f√°cil de hacer testing\n* No tiene que lidiar con procesos asincronos porque no hay procesos IO\n* Dado que no trabaja con procesos IO que pueden fallar, no hay que lidiar con excepciones\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la l√≥gica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enf√°sis en que [[System Under Test (SUT)]] debe ser una unidad l√≥gica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nSeg√∫n [[Scott Wlaschin]], esto no pertenece a la l√≥gica de negocio, y debe ocurrir antes de entrar en juego la l√≥gica de negocio. Esto evita realizar programaci√≥n defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el c√≥digo porque se separa operaciones de valor para el negocio de las validaciones.\n## ¬øQu√© ocurre si no hay algo v√°lido?\nSe hace skip de la l√≥gica de negocio porque se entiende que no tiene sentido procesar informaci√≥n invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situaci√≥n\n![[Pasted image 20250709232523.png]]\n```\nNOTES/Las dependencias son elementos que introducen no-determinismo a una operaci√≥n.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"43.47\"\nminutoFin: \"44.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nPor qu√© las necesitamos para completar los [[Domain-centric workflow]] y dar valor verdadero, es decir, son elementos que involucran procesos IO.\n```\nNOTES/Estrategias para gestionar dependencias.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"44.45\"\nminutoFin: \"45.49\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n* [[Dependency rejection]]: No tener, mantener el c√≥digo puro\n* [[Dependency retention]]: No preocuparse por esto\n* [[Dependency injection]]:  Pasarlas por constructor a las clases\n* [[Dependency parametrization]]: Pasarlas como input a las funciones o m√©todos\n* [[Dependency interpretation]]: Crear un lenguaje de dominio espec√≠fico e interpretarlo\n```\nNOTES/Dependency rejection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"45.53\"\nminutoFin: \"46.57\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]] donde [[Mark Seeman]] enuncia lo siguiente:\n>No tener dependencias en el c√≥digo puro core\nLa ventaja de esto es que es f√°cil de comprender y de testear. Y aunque [[Scott Wlaschin]] expone como desventaja la necesidad de crear c√≥digo (enum y records) para exponer las decisiones para que le el c√≥digo Shell imperativo sepa que operaci√≥n IO ejecutar, para √©l es una ventaja porque genera documentaci√≥n viva y hace m√°s f√°cil de entender el c√≥digo\n```\nNOTES/Dependency injection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n>Pasar las dependencias por constructor a una clase como un todo\nHacer esto puede provocar que una clase tenga una serie de dependencias que aparentemente no tienen sentido juntas pero es necesario porque la clase tiene alg√∫n m√©todo que usa cada una de una manera separada.\nPor otro lado, al tener que borrar algo de una interfaz, no es tan directo saber si en otra parte donde es injectada se usa y por tanto puede ocasionar un miedo a la  rotura y por tanto en lugar de optimizarlo, crecen hasta ser insostenibles y es necesario hacer un an√°lisis importante para poder realizarlo.\n![[Pasted image 20250710001420.png]]\nEs por esto, que este en lugar de este enfoque cl√°sico, [[Scott Wlaschin]] prefiere [[Dependency parametrization]].\nNo obstante, es posiblemente la estrategia m√°s conocida y est√°ndar (la aplican los frameworks normalmente)\n```\nNOTES/Dependency parametrization.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n> Pasar solo las dependencias necesarias para una particular funci√≥n/m√©todo\nLas dependencias en este caso no son interfaces, sino cosas que hace una operaci√≥n concreta:\n![[Pasted image 20250710001117.png]]\nDe esta manera, el c√≥digo se autodocumenta y queda claro lo que necesita de inputs la operaci√≥n y lo que devuelve.\nSin embargo, con c√≥digo que anidado se complica, [[Scott Wlaschin]] aconseja usar esta estrategia en lugar de [[Dependecy Rejection]] cuando no es posible mover a los border los procesos IO por la raz√≥n que sea\n```\nNOTES/Dependency interpretation.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"55.45\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]]. Esta propone:\n>Reemplazar las llamadas a las dependencias con instrucciones que ser√°n interpretadas despu√©s por un \"interprete\" que ser√° el que ejecutara el c√≥digo IO\n![[Pasted image 20250710002445.png]]\nLa ventaja de esto es que se crea una API orientado al dominio, no hay IO pues se sustituye por una instrucci√≥n con la cual se puede operar y se puede hacer un proceso de optimizaci√≥n, pues puede mergearse estructura de datos  \nLo malo es que terriblemente complicado y solo soporta un conjunto limitado de operaciones. Twitter Stich y Facebook Haxl \n```\nBIBLIOGRAPHY/CONFERENCE-TALKS/Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: NDC Conferences London 2024\n```\n## Notas\n|File15|minutoInicio|minutoFin|\n|---|---|---|\n|[Code smells en tu c√≥digo core](NOTES/Code smells en tu c√≥digo core.md)|-|-|\n|[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio](NOTES/Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md)|0.00|2.40|\n|[Domain-centric workflow](NOTES/Domain-centric workflow.md)|2.44|6.10|\n|[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo puro](NOTES/En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo  puro .md)|6.17|10.45|\n|[Functional Core, Imperative Shell Architecture](NOTES/Functional Core, Imperative Shell Architecture.md)|12.00|-|\n|[Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones](NOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md)|18.32|21.42|\n|[Beneficios de escribir c√≥digo puro para la l√≥gica de dominio](NOTES/Beneficios de escribir c√≥digo puro para la l√≥gica de dominio.md)|21.54|33.10|\n|[Los unit tests prueban el core funcional y las integration tests prueban los workflows](NOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md)|33.07|36.23|\n|[Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio)](NOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core \\(dominio\\).md)|36.27|-|\n|[Las dependencias son elementos que introducen no-determinismo a una operaci√≥n](NOTES/Las dependencias son elementos que introducen no-determinismo a una operaci√≥n.md)|43.47|44.44|\n|[Estrategias para gestionar dependencias](NOTES/Estrategias para gestionar dependencias.md)|44.45|45.49|\n|[Dependency rejection](NOTES/Dependency rejection.md)|45.53|46.57|\n|[Dependency injection](NOTES/Dependency injection.md)|48.05|55.44|\n|[Dependency parametrization](NOTES/Dependency parametrization.md)|48.05|55.44|\n|[Dependency interpretation](NOTES/Dependency interpretation.md)|55.45|-|\n```"},{"type":"text","text":"Quiero que me hagas un art√≠culo con todo este contenido"}]}]},"responses":[{"timestamp":1752162043987,"id":"chatcmpl-BrnfRWBQPqaxYVcFJ8lsWTwlMfKs6","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"# Arquitectura Functional Core, Imperative Shell: C√≥mo Mover el C√≥digo IO a los Bordes de tu Aplicaci√≥n\n\nEn el desarrollo de software, especialmente en sistemas complejos, separar la l√≥gica de negocio de los efectos secundarios (como operaciones de entrada/salida o IO) es crucial para mantener el c√≥digo limpio, comprensible y testeable. Esta separaci√≥n se vuelve m√°s importante cuando pretendemos que nuestra aplicaci√≥n sea robusta, predecible y f√°cil de mantener. En este sentido, Scott Wlaschin, en su charla para NDC Conferences London 2024 titulada *\"Moving IO to the edges of your app - Functional Core Imperative Shell\"*, propone un enfoque arquitect√≥nico muy efectivo que nos ayuda a conseguir este objetivo.\n\nEste art√≠culo resume las ideas principales de esta charla y aporta una visi√≥n clara de c√≥mo implementar esta arquitectura y gestionar sus dependencias adecuadamente.\n\n---\n\n## ¬øQu√© es la Arquitectura Functional Core, Imperative Shell?\n\nLa arquitectura **Functional Core, Imperative Shell** es un patr√≥n que sit√∫a el **c√≥digo funcional puro (core)** en el centro de la aplicaci√≥n, y el c√≥digo **imperativo y con efectos secundarios (shell)** en los bordes o periferia. Esto es similar en esp√≠ritu a la Arquitectura Hexagonal, pero hace especial hincapi√© en la pureza y determinismo del n√∫cleo.\n\n- **Core funcional puro:** Es la l√≥gica de negocio. Debe seguir principios de dise√±o que garanticen que el c√≥digo sea **determinista**, **sin efectos secundarios**, y **totalmente comprensible**. Es decir, dados ciertos inputs, siempre entrega los mismos outputs, sin interactuar con el mundo exterior.\n\n- **Shell imperativo:** Es la parte que interact√∫a con el entorno: llamadas a bases de datos, servicios externos, operaciones IO, manejo de excepciones externas, asincron√≠a, etc. Esta capa es inherentemente no determinista y produce efectos secundarios.\n\nSeparando las responsabilidades de esta forma, podemos beneficiar la mantenibilidad, el testing y la comprensi√≥n del sistema.\n\n---\n\n## Por qu√© mantener el c√≥digo IO alejado de la l√≥gica de negocio\n\nSeg√∫n Scott, es fundamental tener bien separadas las responsabilidades porque:\n\n- El c√≥digo IO **no forma parte del dominio** y entremezclarlo con la l√≥gica de negocio dificulta su comprensi√≥n.\n- El c√≥digo IO es **no determinista**: la misma operaci√≥n con los mismos inputs puede arrojar distintos resultados.\n- El c√≥digo IO puede fallar y lanzar excepciones, lo que requiere una l√≥gica de manejo diferente que puede ensuciar la l√≥gica de negocio.\n\nSeparando, garantizamos que el dominio sea siempre predecible y testeable.\n\n---\n\n## Principios para escribir c√≥digo puro en la l√≥gica de dominio\n\nPara que un c√≥digo sea considerado *puro* dentro del dominio, debe seguir ciertos principios de dise√±o:\n\n- **Comprensible:** toda la informaci√≥n necesaria para ejecutar una operaci√≥n debe estar expl√≠citamente dada como entrada. No debe haber dependencias ocultas ni variables globales.\n- **Determinista:** para un conjunto de inputs, siempre debe producir los mismos outputs.\n- **Sin efectos secundarios:** no debe realizar operaciones que modifiquen el estado fuera de su √°mbito o ejecuten IO.\n\nAplicando estos principios se reduce la complejidad y se facilita el testing.\n\n---\n\n## Domain-centric workflow: el workflow centrado en el dominio\n\nUn *workflow* puede verse como una historia de usuario. Scott propone abordar la l√≥gica organizando el workflow centrado en el dominio, donde toda la l√≥gica de negocio est√° en el n√∫cleo, y el resto (como leer o guardar datos) est√° fuera.\n\n![Domain-centric workflow](Pasted_image_20250709203856.png)\n\nEsta t√©cnica ayuda a mantener el principio de mantener el c√≥digo IO alejado del dominio, y facilita que el sistema evolucione y mantenga claridad.\n\n---\n\n## Beneficios de escribir c√≥digo puro para la l√≥gica de dominio\n\n- **Inputs y outputs expl√≠citos:** mejora la comprensi√≥n.\n- **Facilidad para testing:** no necesita mocks ni dobles de prueba complicados.\n- **No lidiar con asincron√≠a:** ya que toda la asincron√≠a est√° confinada a la shell imperativa.\n- **No manejo de excepciones por fallas IO:** que simplifica la l√≥gica interna.\n\n---\n\n## Code smells o olores de c√≥digo en tu core funcional\n\nAlgunos s√≠ntomas que indican que tu core contiene procesos IO o efectos secundarios no deseados son:\n\n- Presencia de procesos as√≠ncronos directamente en el core.\n- Lanzamiento de excepciones para controlar el flujo (en lugar de retornar valores).\n- Cualquier efecto que afecte el estado externo o que no sea determinista.\n\nDetectar estos olores es importante para mantener el core limpio.\n\n---\n\n## Validaciones en la frontera entre IO y el core\n\nLas validaciones de datos deben realizarse al **ingresar a la frontera entre IO y el core** de dominio. Esto evita hacer programaci√≥n defensiva dentro del dominio y garantiza que √©ste trabaje siempre con datos v√°lidos, simplificando el c√≥digo de negocio.\n\nSi los datos no son v√°lidos, el flujo debe saltarse la l√≥gica del dominio y manejar el error o la comunicaci√≥n con el usuario desde la parte IO.\n\n---\n\n## Testing: unit tests y integration tests seg√∫n la arquitectura\n\nEn este enfoque:\n\n- Los **unit tests** prueban exclusivamente el core funcional, porque es puramente funcional y determinista.\n- Las **integration tests** prueban los workflows completos, incluyendo el shell imperativo.\n\nEsta divisi√≥n evita la necesidad de mocks complejos para la l√≥gica de negocio. El principal sujeto bajo prueba (SUT) debe ser siempre una unidad l√≥gica que aporta valor real al negocio.\n\n---\n\n## Gesti√≥n de dependencias en el c√≥digo funcional\n\nLas dependencias son aquellas partes del sistema que introducen no-determinismo y generalmente involucran IO. Scott Wlaschin describe varias estrategias para gestionarlas:\n\n1. **Dependency Rejection (rechazo de dependencias):**  \n   No tener dependencias en el core funcional. Esto simplifica la comprensi√≥n y testing, aunque puede requerir crear estructuras espec√≠ficas para comunicar al shell qu√© IO ejecutar.\n\n2. **Dependency Injection:**  \n   Pasar las dependencias por constructor a las clases. Esta es la estrategia cl√°sica y ampliamente usada, pero puede generar acoplamientos y crecimiento descontrolado de dependencias en las clases.\n\n3. **Dependency Parametrization:**  \n   Pasar solo las dependencias necesarias para una funci√≥n o m√©todo espec√≠fico. Ayuda a una mejor autodocumentaci√≥n y manejo granular, y Scott la prefiere sobre la inyecci√≥n tradicional.\n\n4. **Dependency Interpretation:**  \n   En lugar de ejecutar directamente IO, generar instrucciones que ser√°n interpretadas posteriormente por un \"int√©rprete\" que realizar√° el IO. Esto crea un API orientado al dominio, que puede optimizar operaciones, pero es complejo y limitado en scope.\n\n---\n\n## Reemplazo del c√≥digo IO sin interfaces\n\nEn lugar de crear interfaces abstractas para permitir la variabilidad de implementaciones IO, Scott sugiere simplemente **reemplazar el c√≥digo IO en los bordes**. Mientras el core funcional reciba los mismos inputs y produzca los mismos outputs, no importa c√≥mo se haga el IO.\n\nEsto funciona como piezas de LEGO: el c√≥digo puro permanece inalterado mientras se intercambian los bloques de IO seg√∫n necesidades.\n\n---\n\n## Conclusi√≥n\n\nLa arquitectura **Functional Core, Imperative Shell** promueve un dise√±o claramente separado donde:\n\n- La l√≥gica de negocio se mantiene pura, determinista y f√°cilmente testeable.\n- El c√≥digo imperativo y no determinista, con efectos secundarios, se a√≠sla en los bordes.\n- Las dependencias con IO se gestionan con estrategias pensadas para minimizar el impacto en el core.\n- Las validaciones y excepciones se gestionan antes de que los datos ingresen a la l√≥gica de dominio.\n\nAdoptar este patr√≥n no solo mejora la calidad del software sino que facilita el desarrollo iterativo, la mantenibilidad y la escalabilidad de sistemas complejos.\n\nPara profundizar en este enfoque, se recomienda consultar la charla original de Scott Wlaschin en NDC Conferences London 2024 ([enlace aqu√≠](https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2)) y explorar ejemplos pr√°cticos que ilustren cada uno de estos conceptos.\n\n---\n\n**Referencias:**\n\n- Wlaschin, Scott. *Moving IO to the edges of your app - Functional Core Imperative Shell*, NDC Conferences London 2024.\n- Seeman, Mark. Estrategias para gestionar dependencias.\n\n---\n\nEste art√≠culo sintetiza y organiza los conceptos y recomendaciones que Scott Wlaschin expone para ayudarnos a construir aplicaciones m√°s limpias, robustas y mantenibles siguiendo el patr√≥n Functional Core, Imperative Shell."}}],"usage":{},"raw":{"id":"chatcmpl-BrnfRWBQPqaxYVcFJ8lsWTwlMfKs6","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"# Arquitectura Functional Core, Imperative Shell: C√≥mo Mover el C√≥digo IO a los Bordes de tu Aplicaci√≥n\n\nEn el desarrollo de software, especialmente en sistemas complejos, separar la l√≥gica de negocio de los efectos secundarios (como operaciones de entrada/salida o IO) es crucial para mantener el c√≥digo limpio, comprensible y testeable. Esta separaci√≥n se vuelve m√°s importante cuando pretendemos que nuestra aplicaci√≥n sea robusta, predecible y f√°cil de mantener. En este sentido, Scott Wlaschin, en su charla para NDC Conferences London 2024 titulada *\"Moving IO to the edges of your app - Functional Core Imperative Shell\"*, propone un enfoque arquitect√≥nico muy efectivo que nos ayuda a conseguir este objetivo.\n\nEste art√≠culo resume las ideas principales de esta charla y aporta una visi√≥n clara de c√≥mo implementar esta arquitectura y gestionar sus dependencias adecuadamente.\n\n---\n\n## ¬øQu√© es la Arquitectura Functional Core, Imperative Shell?\n\nLa arquitectura **Functional Core, Imperative Shell** es un patr√≥n que sit√∫a el **c√≥digo funcional puro (core)** en el centro de la aplicaci√≥n, y el c√≥digo **imperativo y con efectos secundarios (shell)** en los bordes o periferia. Esto es similar en esp√≠ritu a la Arquitectura Hexagonal, pero hace especial hincapi√© en la pureza y determinismo del n√∫cleo.\n\n- **Core funcional puro:** Es la l√≥gica de negocio. Debe seguir principios de dise√±o que garanticen que el c√≥digo sea **determinista**, **sin efectos secundarios**, y **totalmente comprensible**. Es decir, dados ciertos inputs, siempre entrega los mismos outputs, sin interactuar con el mundo exterior.\n\n- **Shell imperativo:** Es la parte que interact√∫a con el entorno: llamadas a bases de datos, servicios externos, operaciones IO, manejo de excepciones externas, asincron√≠a, etc. Esta capa es inherentemente no determinista y produce efectos secundarios.\n\nSeparando las responsabilidades de esta forma, podemos beneficiar la mantenibilidad, el testing y la comprensi√≥n del sistema.\n\n---\n\n## Por qu√© mantener el c√≥digo IO alejado de la l√≥gica de negocio\n\nSeg√∫n Scott, es fundamental tener bien separadas las responsabilidades porque:\n\n- El c√≥digo IO **no forma parte del dominio** y entremezclarlo con la l√≥gica de negocio dificulta su comprensi√≥n.\n- El c√≥digo IO es **no determinista**: la misma operaci√≥n con los mismos inputs puede arrojar distintos resultados.\n- El c√≥digo IO puede fallar y lanzar excepciones, lo que requiere una l√≥gica de manejo diferente que puede ensuciar la l√≥gica de negocio.\n\nSeparando, garantizamos que el dominio sea siempre predecible y testeable.\n\n---\n\n## Principios para escribir c√≥digo puro en la l√≥gica de dominio\n\nPara que un c√≥digo sea considerado *puro* dentro del dominio, debe seguir ciertos principios de dise√±o:\n\n- **Comprensible:** toda la informaci√≥n necesaria para ejecutar una operaci√≥n debe estar expl√≠citamente dada como entrada. No debe haber dependencias ocultas ni variables globales.\n- **Determinista:** para un conjunto de inputs, siempre debe producir los mismos outputs.\n- **Sin efectos secundarios:** no debe realizar operaciones que modifiquen el estado fuera de su √°mbito o ejecuten IO.\n\nAplicando estos principios se reduce la complejidad y se facilita el testing.\n\n---\n\n## Domain-centric workflow: el workflow centrado en el dominio\n\nUn *workflow* puede verse como una historia de usuario. Scott propone abordar la l√≥gica organizando el workflow centrado en el dominio, donde toda la l√≥gica de negocio est√° en el n√∫cleo, y el resto (como leer o guardar datos) est√° fuera.\n\n![Domain-centric workflow](Pasted_image_20250709203856.png)\n\nEsta t√©cnica ayuda a mantener el principio de mantener el c√≥digo IO alejado del dominio, y facilita que el sistema evolucione y mantenga claridad.\n\n---\n\n## Beneficios de escribir c√≥digo puro para la l√≥gica de dominio\n\n- **Inputs y outputs expl√≠citos:** mejora la comprensi√≥n.\n- **Facilidad para testing:** no necesita mocks ni dobles de prueba complicados.\n- **No lidiar con asincron√≠a:** ya que toda la asincron√≠a est√° confinada a la shell imperativa.\n- **No manejo de excepciones por fallas IO:** que simplifica la l√≥gica interna.\n\n---\n\n## Code smells o olores de c√≥digo en tu core funcional\n\nAlgunos s√≠ntomas que indican que tu core contiene procesos IO o efectos secundarios no deseados son:\n\n- Presencia de procesos as√≠ncronos directamente en el core.\n- Lanzamiento de excepciones para controlar el flujo (en lugar de retornar valores).\n- Cualquier efecto que afecte el estado externo o que no sea determinista.\n\nDetectar estos olores es importante para mantener el core limpio.\n\n---\n\n## Validaciones en la frontera entre IO y el core\n\nLas validaciones de datos deben realizarse al **ingresar a la frontera entre IO y el core** de dominio. Esto evita hacer programaci√≥n defensiva dentro del dominio y garantiza que √©ste trabaje siempre con datos v√°lidos, simplificando el c√≥digo de negocio.\n\nSi los datos no son v√°lidos, el flujo debe saltarse la l√≥gica del dominio y manejar el error o la comunicaci√≥n con el usuario desde la parte IO.\n\n---\n\n## Testing: unit tests y integration tests seg√∫n la arquitectura\n\nEn este enfoque:\n\n- Los **unit tests** prueban exclusivamente el core funcional, porque es puramente funcional y determinista.\n- Las **integration tests** prueban los workflows completos, incluyendo el shell imperativo.\n\nEsta divisi√≥n evita la necesidad de mocks complejos para la l√≥gica de negocio. El principal sujeto bajo prueba (SUT) debe ser siempre una unidad l√≥gica que aporta valor real al negocio.\n\n---\n\n## Gesti√≥n de dependencias en el c√≥digo funcional\n\nLas dependencias son aquellas partes del sistema que introducen no-determinismo y generalmente involucran IO. Scott Wlaschin describe varias estrategias para gestionarlas:\n\n1. **Dependency Rejection (rechazo de dependencias):**  \n   No tener dependencias en el core funcional. Esto simplifica la comprensi√≥n y testing, aunque puede requerir crear estructuras espec√≠ficas para comunicar al shell qu√© IO ejecutar.\n\n2. **Dependency Injection:**  \n   Pasar las dependencias por constructor a las clases. Esta es la estrategia cl√°sica y ampliamente usada, pero puede generar acoplamientos y crecimiento descontrolado de dependencias en las clases.\n\n3. **Dependency Parametrization:**  \n   Pasar solo las dependencias necesarias para una funci√≥n o m√©todo espec√≠fico. Ayuda a una mejor autodocumentaci√≥n y manejo granular, y Scott la prefiere sobre la inyecci√≥n tradicional.\n\n4. **Dependency Interpretation:**  \n   En lugar de ejecutar directamente IO, generar instrucciones que ser√°n interpretadas posteriormente por un \"int√©rprete\" que realizar√° el IO. Esto crea un API orientado al dominio, que puede optimizar operaciones, pero es complejo y limitado en scope.\n\n---\n\n## Reemplazo del c√≥digo IO sin interfaces\n\nEn lugar de crear interfaces abstractas para permitir la variabilidad de implementaciones IO, Scott sugiere simplemente **reemplazar el c√≥digo IO en los bordes**. Mientras el core funcional reciba los mismos inputs y produzca los mismos outputs, no importa c√≥mo se haga el IO.\n\nEsto funciona como piezas de LEGO: el c√≥digo puro permanece inalterado mientras se intercambian los bloques de IO seg√∫n necesidades.\n\n---\n\n## Conclusi√≥n\n\nLa arquitectura **Functional Core, Imperative Shell** promueve un dise√±o claramente separado donde:\n\n- La l√≥gica de negocio se mantiene pura, determinista y f√°cilmente testeable.\n- El c√≥digo imperativo y no determinista, con efectos secundarios, se a√≠sla en los bordes.\n- Las dependencias con IO se gestionan con estrategias pensadas para minimizar el impacto en el core.\n- Las validaciones y excepciones se gestionan antes de que los datos ingresen a la l√≥gica de dominio.\n\nAdoptar este patr√≥n no solo mejora la calidad del software sino que facilita el desarrollo iterativo, la mantenibilidad y la escalabilidad de sistemas complejos.\n\nPara profundizar en este enfoque, se recomienda consultar la charla original de Scott Wlaschin en NDC Conferences London 2024 ([enlace aqu√≠](https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2)) y explorar ejemplos pr√°cticos que ilustren cada uno de estos conceptos.\n\n---\n\n**Referencias:**\n\n- Wlaschin, Scott. *Moving IO to the edges of your app - Functional Core Imperative Shell*, NDC Conferences London 2024.\n- Seeman, Mark. Estrategias para gestionar dependencias.\n\n---\n\nEste art√≠culo sintetiza y organiza los conceptos y recomendaciones que Scott Wlaschin expone para ayudarnos a construir aplicaciones m√°s limpias, robustas y mantenibles siguiendo el patr√≥n Functional Core, Imperative Shell."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752161883212-1752161883212","thread_key":"Untitled Chat 1752161883212","stream":true,"context_key":"1752161883212","class_name":"SmartCompletion","user_message":"Quiero que me hagas un art√≠culo con todo este contenido","new_user_message":true},
"smart_completions:Untitled Chat 1752161929380-1752163917737": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero que me hagas un art√≠culo con todo este contenido"},{"type":"text","text":"‚îú‚îÄ‚îÄ BIBLIOGRAPHY/CONFERENCE-TALKS/\n‚îÇ   ‚îî‚îÄ‚îÄ Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Beneficios de escribir c√≥digo puro para la l√≥gica de dominio.md\n    ‚îú‚îÄ‚îÄ Code smells en tu c√≥digo core.md\n    ‚îú‚îÄ‚îÄ Dependency injection.md\n    ‚îú‚îÄ‚îÄ Dependency interpretation.md\n    ‚îú‚îÄ‚îÄ Dependency parametrization.md\n    ‚îú‚îÄ‚îÄ Dependency rejection.md\n    ‚îú‚îÄ‚îÄ Domain-centric workflow.md\n    ‚îú‚îÄ‚îÄ En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo  puro .md\n    ‚îú‚îÄ‚îÄ Estrategias para gestionar dependencias.md\n    ‚îú‚îÄ‚îÄ Functional Core, Imperative Shell Architecture.md\n    ‚îú‚îÄ‚îÄ Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n    ‚îú‚îÄ‚îÄ Las dependencias son elementos que introducen no-determinismo a una operaci√≥n.md\n    ‚îú‚îÄ‚îÄ Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ‚îú‚îÄ‚îÄ Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    ‚îî‚îÄ‚îÄ Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n\nNOTES/Code smells en tu c√≥digo core.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQue son?\nSon s√≠ntomas de que tu c√≥digo tiene alguna operaci√≥n IO oculta o al menos no expl√≠tica.\n## ¬øCu√°les son?\n* Hay alg√∫n proceso as√≠ncrono\n* Se lanza alguna excepci√≥n\n* Tienes lanzamiento de excepciones para gestionar el flujo de ejecuci√≥n en lugar de retornar un valor \n```\nNOTES/Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\n* El c√≥digo IO no forma parte del dominio. Adem√°s, cuando se entremezclan dificulta la comprensi√≥n de la l√≥gica de negocio.\n* El c√≥digo IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El c√≥digo IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Domain-centric workflow.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"2.44\"\nminutoFin: \"6.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nUn workflow es equivalente a una historia de usuario. Desde esto, [[Scott Wlaschin]] propone trabajar en una arquitectura [[Domain Driving Desing]] porque pone la l√≥gica de dominio en el centro y la l√≥gica IO en los bordes. Por tanto un domain-centric workflow se trata de un \"slice\" c√≥mo se ilustra en la siguiente imagen:\n![[Pasted image 20250709203856.png]]\nCon esta arquitectura, [[Scott Wlaschin]] consigue cumplir principio de dise√±o de [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]]  de una manera efectiva.\nUn caso de uso se ilustra a continuaci√≥n:\n![[Pasted image 20250709204031.png]]\n```\nNOTES/En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo  puro .md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"6.17\"\nminutoFin: \"10.45\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son los principios?\n* El c√≥digo debe ser comprensible. Esto significa que:\n\t* Todo debe ser explicitamente dado por los inputs para que no nos preguntemos ¬øQu√© es lo que necesitamos para que se haga la operaci√≥n X?\n\t* Debe haber un output, para que entendamos cual es el resultado de la operaci√≥n y podamos verificarlo\n* El c√≥digo debe ser determinista: Dados unos inputs, siempre debemos obtener los mismos outputs\n* No tiene side-effects: No se produce ning√∫n proceso adicional que salga del √°mbito del proceso y que adem√°s no vaya al \"exterior\" de la applicaci√≥n (IO)\n```\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el c√≥digo de domino est√° en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enf√°sis en que [[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo \"puro\"]] y [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]] y este ser√° impuro e imperativo.\nAdem√°s, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicaci√≥n en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el c√≥digo es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el c√≥digo de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"18.32\"\nminutoFin: \"21.42\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es esto?\n[[Scott Wlaschin]] propone, en lugar de crear una interfaz o abstracci√≥n desde la cual hacer varias implementaciones, simplemente reemplazar el c√≥digo IO de los bordes y mantener el c√≥digo de dominio. De esta manera, propone trabajar como si piezas de lego se trataran. Al final, el reemplazo de c√≥digo IO seguiran recuperando o mandando los mismos datos y por tanto el c√≥digo de dominio le dar√° igual mientras estos den los inputs y procesen los outputs de este.\nUn ejemplo de esto es lo siguiente:\n![[Pasted image 20250709212804.png]]\n![[Pasted image 20250709212824.png]]\n![[Pasted image 20250709212849.png]]\n```\nNOTES/Beneficios de escribir c√≥digo puro para la l√≥gica de dominio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"21.54\"\nminutoFin: \"33.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n* Los inputs y output son explicitos y por tanto es comprensible c√≥mo usarlo\n* Es f√°cil de hacer testing\n* No tiene que lidiar con procesos asincronos porque no hay procesos IO\n* Dado que no trabaja con procesos IO que pueden fallar, no hay que lidiar con excepciones\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la l√≥gica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enf√°sis en que [[System Under Test (SUT)]] debe ser una unidad l√≥gica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nSeg√∫n [[Scott Wlaschin]], esto no pertenece a la l√≥gica de negocio, y debe ocurrir antes de entrar en juego la l√≥gica de negocio. Esto evita realizar programaci√≥n defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el c√≥digo porque se separa operaciones de valor para el negocio de las validaciones.\n## ¬øQu√© ocurre si no hay algo v√°lido?\nSe hace skip de la l√≥gica de negocio porque se entiende que no tiene sentido procesar informaci√≥n invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situaci√≥n\n![[Pasted image 20250709232523.png]]\n```\nNOTES/Las dependencias son elementos que introducen no-determinismo a una operaci√≥n.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"43.47\"\nminutoFin: \"44.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nPor qu√© las necesitamos para completar los [[Domain-centric workflow]] y dar valor verdadero, es decir, son elementos que involucran procesos IO.\n```\nNOTES/Estrategias para gestionar dependencias.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"44.45\"\nminutoFin: \"45.49\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øCu√°les son?\n* [[Dependency rejection]]: No tener, mantener el c√≥digo puro\n* [[Dependency retention]]: No preocuparse por esto\n* [[Dependency injection]]:  Pasarlas por constructor a las clases\n* [[Dependency parametrization]]: Pasarlas como input a las funciones o m√©todos\n* [[Dependency interpretation]]: Crear un lenguaje de dominio espec√≠fico e interpretarlo\n```\nNOTES/Dependency rejection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"45.53\"\nminutoFin: \"46.57\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]] donde [[Mark Seeman]] enuncia lo siguiente:\n>No tener dependencias en el c√≥digo puro core\nLa ventaja de esto es que es f√°cil de comprender y de testear. Y aunque [[Scott Wlaschin]] expone como desventaja la necesidad de crear c√≥digo (enum y records) para exponer las decisiones para que le el c√≥digo Shell imperativo sepa que operaci√≥n IO ejecutar, para √©l es una ventaja porque genera documentaci√≥n viva y hace m√°s f√°cil de entender el c√≥digo\n```\nNOTES/Dependency injection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n>Pasar las dependencias por constructor a una clase como un todo\nHacer esto puede provocar que una clase tenga una serie de dependencias que aparentemente no tienen sentido juntas pero es necesario porque la clase tiene alg√∫n m√©todo que usa cada una de una manera separada.\nPor otro lado, al tener que borrar algo de una interfaz, no es tan directo saber si en otra parte donde es injectada se usa y por tanto puede ocasionar un miedo a la  rotura y por tanto en lugar de optimizarlo, crecen hasta ser insostenibles y es necesario hacer un an√°lisis importante para poder realizarlo.\n![[Pasted image 20250710001420.png]]\nEs por esto, que este en lugar de este enfoque cl√°sico, [[Scott Wlaschin]] prefiere [[Dependency parametrization]].\nNo obstante, es posiblemente la estrategia m√°s conocida y est√°ndar (la aplican los frameworks normalmente)\n```\nNOTES/Dependency parametrization.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n> Pasar solo las dependencias necesarias para una particular funci√≥n/m√©todo\nLas dependencias en este caso no son interfaces, sino cosas que hace una operaci√≥n concreta:\n![[Pasted image 20250710001117.png]]\nDe esta manera, el c√≥digo se autodocumenta y queda claro lo que necesita de inputs la operaci√≥n y lo que devuelve.\nSin embargo, con c√≥digo que anidado se complica, [[Scott Wlaschin]] aconseja usar esta estrategia en lugar de [[Dependecy Rejection]] cuando no es posible mover a los border los procesos IO por la raz√≥n que sea\n```\nNOTES/Dependency interpretation.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"55.45\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una de las [[Estrategias para gestionar dependencias]]. Esta propone:\n>Reemplazar las llamadas a las dependencias con instrucciones que ser√°n interpretadas despu√©s por un \"interprete\" que ser√° el que ejecutara el c√≥digo IO\n![[Pasted image 20250710002445.png]]\nLa ventaja de esto es que se crea una API orientado al dominio, no hay IO pues se sustituye por una instrucci√≥n con la cual se puede operar y se puede hacer un proceso de optimizaci√≥n, pues puede mergearse estructura de datos  \nLo malo es que terriblemente complicado y solo soporta un conjunto limitado de operaciones. Twitter Stich y Facebook Haxl \n```\nBIBLIOGRAPHY/CONFERENCE-TALKS/Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: NDC Conferences London 2024\n```\n## Notas\n|File15|minutoInicio|minutoFin|\n|---|---|---|\n|[Code smells en tu c√≥digo core](NOTES/Code smells en tu c√≥digo core.md)|-|-|\n|[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio](NOTES/Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md)|0.00|2.40|\n|[Domain-centric workflow](NOTES/Domain-centric workflow.md)|2.44|6.10|\n|[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo puro](NOTES/En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo  puro .md)|6.17|10.45|\n|[Functional Core, Imperative Shell Architecture](NOTES/Functional Core, Imperative Shell Architecture.md)|12.00|-|\n|[Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones](NOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md)|18.32|21.42|\n|[Beneficios de escribir c√≥digo puro para la l√≥gica de dominio](NOTES/Beneficios de escribir c√≥digo puro para la l√≥gica de dominio.md)|21.54|33.10|\n|[Los unit tests prueban el core funcional y las integration tests prueban los workflows](NOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md)|33.07|36.23|\n|[Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio)](NOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core \\(dominio\\).md)|36.27|-|\n|[Las dependencias son elementos que introducen no-determinismo a una operaci√≥n](NOTES/Las dependencias son elementos que introducen no-determinismo a una operaci√≥n.md)|43.47|44.44|\n|[Estrategias para gestionar dependencias](NOTES/Estrategias para gestionar dependencias.md)|44.45|45.49|\n|[Dependency rejection](NOTES/Dependency rejection.md)|45.53|46.57|\n|[Dependency injection](NOTES/Dependency injection.md)|48.05|55.44|\n|[Dependency parametrization](NOTES/Dependency parametrization.md)|48.05|55.44|\n|[Dependency interpretation](NOTES/Dependency interpretation.md)|55.45|-|\n```"},{"type":"text","text":"Quiero que me hagas un art√≠culo con todo este contenido"}]},{"role":"assistant","content":"# Arquitectura Functional Core, Imperative Shell: C√≥mo Mover el C√≥digo IO a los Bordes de tu Aplicaci√≥n\n\nEn el desarrollo de software, especialmente en sistemas complejos, separar la l√≥gica de negocio de los efectos secundarios (como operaciones de entrada/salida o IO) es crucial para mantener el c√≥digo limpio, comprensible y testeable. Esta separaci√≥n se vuelve m√°s importante cuando pretendemos que nuestra aplicaci√≥n sea robusta, predecible y f√°cil de mantener. En este sentido, Scott Wlaschin, en su charla para NDC Conferences London 2024 titulada *\"Moving IO to the edges of your app - Functional Core Imperative Shell\"*, propone un enfoque arquitect√≥nico muy efectivo que nos ayuda a conseguir este objetivo.\n\nEste art√≠culo resume las ideas principales de esta charla y aporta una visi√≥n clara de c√≥mo implementar esta arquitectura y gestionar sus dependencias adecuadamente.\n\n---\n\n## ¬øQu√© es la Arquitectura Functional Core, Imperative Shell?\n\nLa arquitectura **Functional Core, Imperative Shell** es un patr√≥n que sit√∫a el **c√≥digo funcional puro (core)** en el centro de la aplicaci√≥n, y el c√≥digo **imperativo y con efectos secundarios (shell)** en los bordes o periferia. Esto es similar en esp√≠ritu a la Arquitectura Hexagonal, pero hace especial hincapi√© en la pureza y determinismo del n√∫cleo.\n\n- **Core funcional puro:** Es la l√≥gica de negocio. Debe seguir principios de dise√±o que garanticen que el c√≥digo sea **determinista**, **sin efectos secundarios**, y **totalmente comprensible**. Es decir, dados ciertos inputs, siempre entrega los mismos outputs, sin interactuar con el mundo exterior.\n\n- **Shell imperativo:** Es la parte que interact√∫a con el entorno: llamadas a bases de datos, servicios externos, operaciones IO, manejo de excepciones externas, asincron√≠a, etc. Esta capa es inherentemente no determinista y produce efectos secundarios.\n\nSeparando las responsabilidades de esta forma, podemos beneficiar la mantenibilidad, el testing y la comprensi√≥n del sistema.\n\n---\n\n## Por qu√© mantener el c√≥digo IO alejado de la l√≥gica de negocio\n\nSeg√∫n Scott, es fundamental tener bien separadas las responsabilidades porque:\n\n- El c√≥digo IO **no forma parte del dominio** y entremezclarlo con la l√≥gica de negocio dificulta su comprensi√≥n.\n- El c√≥digo IO es **no determinista**: la misma operaci√≥n con los mismos inputs puede arrojar distintos resultados.\n- El c√≥digo IO puede fallar y lanzar excepciones, lo que requiere una l√≥gica de manejo diferente que puede ensuciar la l√≥gica de negocio.\n\nSeparando, garantizamos que el dominio sea siempre predecible y testeable.\n\n---\n\n## Principios para escribir c√≥digo puro en la l√≥gica de dominio\n\nPara que un c√≥digo sea considerado *puro* dentro del dominio, debe seguir ciertos principios de dise√±o:\n\n- **Comprensible:** toda la informaci√≥n necesaria para ejecutar una operaci√≥n debe estar expl√≠citamente dada como entrada. No debe haber dependencias ocultas ni variables globales.\n- **Determinista:** para un conjunto de inputs, siempre debe producir los mismos outputs.\n- **Sin efectos secundarios:** no debe realizar operaciones que modifiquen el estado fuera de su √°mbito o ejecuten IO.\n\nAplicando estos principios se reduce la complejidad y se facilita el testing.\n\n---\n\n## Domain-centric workflow: el workflow centrado en el dominio\n\nUn *workflow* puede verse como una historia de usuario. Scott propone abordar la l√≥gica organizando el workflow centrado en el dominio, donde toda la l√≥gica de negocio est√° en el n√∫cleo, y el resto (como leer o guardar datos) est√° fuera.\n\n![Domain-centric workflow](Pasted_image_20250709203856.png)\n\nEsta t√©cnica ayuda a mantener el principio de mantener el c√≥digo IO alejado del dominio, y facilita que el sistema evolucione y mantenga claridad.\n\n---\n\n## Beneficios de escribir c√≥digo puro para la l√≥gica de dominio\n\n- **Inputs y outputs expl√≠citos:** mejora la comprensi√≥n.\n- **Facilidad para testing:** no necesita mocks ni dobles de prueba complicados.\n- **No lidiar con asincron√≠a:** ya que toda la asincron√≠a est√° confinada a la shell imperativa.\n- **No manejo de excepciones por fallas IO:** que simplifica la l√≥gica interna.\n\n---\n\n## Code smells o olores de c√≥digo en tu core funcional\n\nAlgunos s√≠ntomas que indican que tu core contiene procesos IO o efectos secundarios no deseados son:\n\n- Presencia de procesos as√≠ncronos directamente en el core.\n- Lanzamiento de excepciones para controlar el flujo (en lugar de retornar valores).\n- Cualquier efecto que afecte el estado externo o que no sea determinista.\n\nDetectar estos olores es importante para mantener el core limpio.\n\n---\n\n## Validaciones en la frontera entre IO y el core\n\nLas validaciones de datos deben realizarse al **ingresar a la frontera entre IO y el core** de dominio. Esto evita hacer programaci√≥n defensiva dentro del dominio y garantiza que √©ste trabaje siempre con datos v√°lidos, simplificando el c√≥digo de negocio.\n\nSi los datos no son v√°lidos, el flujo debe saltarse la l√≥gica del dominio y manejar el error o la comunicaci√≥n con el usuario desde la parte IO.\n\n---\n\n## Testing: unit tests y integration tests seg√∫n la arquitectura\n\nEn este enfoque:\n\n- Los **unit tests** prueban exclusivamente el core funcional, porque es puramente funcional y determinista.\n- Las **integration tests** prueban los workflows completos, incluyendo el shell imperativo.\n\nEsta divisi√≥n evita la necesidad de mocks complejos para la l√≥gica de negocio. El principal sujeto bajo prueba (SUT) debe ser siempre una unidad l√≥gica que aporta valor real al negocio.\n\n---\n\n## Gesti√≥n de dependencias en el c√≥digo funcional\n\nLas dependencias son aquellas partes del sistema que introducen no-determinismo y generalmente involucran IO. Scott Wlaschin describe varias estrategias para gestionarlas:\n\n1. **Dependency Rejection (rechazo de dependencias):**  \n   No tener dependencias en el core funcional. Esto simplifica la comprensi√≥n y testing, aunque puede requerir crear estructuras espec√≠ficas para comunicar al shell qu√© IO ejecutar.\n\n2. **Dependency Injection:**  \n   Pasar las dependencias por constructor a las clases. Esta es la estrategia cl√°sica y ampliamente usada, pero puede generar acoplamientos y crecimiento descontrolado de dependencias en las clases.\n\n3. **Dependency Parametrization:**  \n   Pasar solo las dependencias necesarias para una funci√≥n o m√©todo espec√≠fico. Ayuda a una mejor autodocumentaci√≥n y manejo granular, y Scott la prefiere sobre la inyecci√≥n tradicional.\n\n4. **Dependency Interpretation:**  \n   En lugar de ejecutar directamente IO, generar instrucciones que ser√°n interpretadas posteriormente por un \"int√©rprete\" que realizar√° el IO. Esto crea un API orientado al dominio, que puede optimizar operaciones, pero es complejo y limitado en scope.\n\n---\n\n## Reemplazo del c√≥digo IO sin interfaces\n\nEn lugar de crear interfaces abstractas para permitir la variabilidad de implementaciones IO, Scott sugiere simplemente **reemplazar el c√≥digo IO en los bordes**. Mientras el core funcional reciba los mismos inputs y produzca los mismos outputs, no importa c√≥mo se haga el IO.\n\nEsto funciona como piezas de LEGO: el c√≥digo puro permanece inalterado mientras se intercambian los bloques de IO seg√∫n necesidades.\n\n---\n\n## Conclusi√≥n\n\nLa arquitectura **Functional Core, Imperative Shell** promueve un dise√±o claramente separado donde:\n\n- La l√≥gica de negocio se mantiene pura, determinista y f√°cilmente testeable.\n- El c√≥digo imperativo y no determinista, con efectos secundarios, se a√≠sla en los bordes.\n- Las dependencias con IO se gestionan con estrategias pensadas para minimizar el impacto en el core.\n- Las validaciones y excepciones se gestionan antes de que los datos ingresen a la l√≥gica de dominio.\n\nAdoptar este patr√≥n no solo mejora la calidad del software sino que facilita el desarrollo iterativo, la mantenibilidad y la escalabilidad de sistemas complejos.\n\nPara profundizar en este enfoque, se recomienda consultar la charla original de Scott Wlaschin en NDC Conferences London 2024 ([enlace aqu√≠](https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2)) y explorar ejemplos pr√°cticos que ilustren cada uno de estos conceptos.\n\n---\n\n**Referencias:**\n\n- Wlaschin, Scott. *Moving IO to the edges of your app - Functional Core Imperative Shell*, NDC Conferences London 2024.\n- Seeman, Mark. Estrategias para gestionar dependencias.\n\n---\n\nEste art√≠culo sintetiza y organiza los conceptos y recomendaciones que Scott Wlaschin expone para ayudarnos a construir aplicaciones m√°s limpias, robustas y mantenibles siguiendo el patr√≥n Functional Core, Imperative Shell."},{"role":"user","content":[{"type":"text","text":"de la gesti√≥n de dependencias, desde un caso en concreto genera un ejemplo por cada estrategia"}]}]},"responses":[{"timestamp":1752163949762,"id":"chatcmpl-BroAJ1QpM5YHYhVnuIJPdg8382AH5","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, a continuaci√≥n detallo cada estrategia para la gesti√≥n de dependencias con un ejemplo pr√°ctico basado en un caso concreto. Supongamos que tenemos una aplicaci√≥n que realiza una operaci√≥n de **env√≠o de correo electr√≥nico** como parte de un workflow, donde el **core funcional** define la l√≥gica para decidir cu√°ndo mandar el mail, pero la operaci√≥n real de env√≠o es IO y est√° en el shell imperativo.\n\n---\n\n### Contexto:  \n**Caso:** Enviar un correo de notificaci√≥n solo si se cumple cierta condici√≥n de negocio en el core funcional.  \n**Dependencia:** Servicio de env√≠o de correo (IO).\n\n---\n\n## 1. Dependency Rejection (Rechazo de dependencias)\n\n**Concepto:** No tener dependencias en el core funcional. El core no sabe nada del env√≠o de correos ni tiene referencias a servicios externos. En lugar de eso, el core devuelve un valor que describe la acci√≥n a realizar para el shell.\n\n**Ejemplo:**\n\n```fsharp\n// Core funcional: pura l√≥gica\ntype NotificationAction = \n    | SendEmail of recipient:string * message:string\n    | NoAction\n\nlet decideNotification (user : User) : NotificationAction =\n    if user.IsActive then\n        SendEmail(user.Email, \"Bienvenido!\")\n    else\n        NoAction\n\n// Shell imperativo: interpreta la acci√≥n\nlet performNotification action =\n    match action with\n    | SendEmail (email, msg) -> emailService.Send(email, msg)  // c√≥digo IO\n    | NoAction -> ()\n\n// Uso\nlet action = decideNotification someUser\nperformNotification action\n```\n\n**Ventajas:**  \n- Core puro, sin dependencias de IO.  \n- F√°cil de testear y comprender.  \n- El core documenta \"qu√© debe pasar\" en lugar de \"c√≥mo\".\n\n**Desventajas:**  \n- Se necesita definir tipos para las acciones que el shell interpretar√°, lo que puede ser tedioso.\n\n---\n\n## 2. Dependency Injection (Inyecci√≥n de dependencias)\n\n**Concepto:** El core funcional o las clases que contienen la l√≥gica reciben por constructor el servicio o interfaz que representa la dependencia.\n\n**Ejemplo:**\n\n```csharp\npublic interface IEmailSender\n{\n    void Send(string recipient, string message);\n}\n\npublic class NotificationService\n{\n    private readonly IEmailSender _emailSender;\n\n    public NotificationService(IEmailSender emailSender)\n    {\n        _emailSender = emailSender;\n    }\n\n    public void NotifyUser(User user)\n    {\n        if (user.IsActive)\n        {\n            _emailSender.Send(user.Email, \"Bienvenido!\");\n        }\n    }\n}\n\n// Shell inicializa la dependencia y la inyecta\nvar emailSender = new SmtpEmailSender();\nvar notificationService = new NotificationService(emailSender);\n\nnotificationService.NotifyUser(user);\n```\n\n**Ventajas:**  \n- Com√∫n y muy utilizada con frameworks de IoC.  \n- Centraliza configuraci√≥n de dependencias.\n\n**Desventajas:**  \n- Clases pueden tener muchas dependencias mezcladas.  \n- A veces interfaz y dependencias crecen sin control.  \n- Dificulta saber qu√© dependencias usa cada m√©todo individual.\n\n---\n\n## 3. Dependency Parametrization (Parametrizaci√≥n de dependencias)\n\n**Concepto:** Pasar solo las dependencias necesarias como par√°metros espec√≠ficos a cada funci√≥n o m√©todo que las utiliza.\n\n**Ejemplo:**\n\n```fsharp\n// Define funci√≥n que recibe expl√≠citamente el \"sendEmail\" como funci√≥n\nlet notifyUser (sendEmail: string -> string -> unit) (user: User) =\n    if user.IsActive then\n        sendEmail user.Email \"Bienvenido!\"\n\n// Shell imperativo pasa funci√≥n concreta\nlet smtpSendEmail recipient message =\n    // C√≥digo imperativo que env√≠a el email\n    emailService.Send(recipient, message)\n\n// Uso\nnotifyUser smtpSendEmail someUser\n```\n\n**Ventajas:**  \n- El c√≥digo se autodocumenta: queda claro qu√© inputs se necesitan.  \n- Reduce acoplamientos y hace expl√≠citas las dependencias.  \n- Permite reemplazar f√°cilmente la funci√≥n IO para tests o diferentes implementaciones.\n\n**Desventajas:**  \n- Puede complicarse si hay muchas dependencias m√∫ltiples anidadas.  \n- Requiere disciplina para no pasar argumentos innecesarios.\n\n---\n\n## 4. Dependency Interpretation (Interpretaci√≥n de dependencias)\n\n**Concepto:** En lugar de ejecutar directamente el IO, el core produce una estructura de datos (instrucciones o comandos) que luego son interpretados por un int√©rprete en el shell imperativo.\n\n**Ejemplo:**\n\n```fsharp\n// Define un lenguaje de dominio para las acciones\ntype EmailCommand =\n    | SendEmail of recipient:string * message:string\n\ntype WorkflowInstruction =\n    | Email of EmailCommand\n    | NoOp\n\n// Core crea una lista de instrucciones\nlet buildInstructions (user: User) : WorkflowInstruction list =\n    if user.IsActive then\n        [ Email (SendEmail(user.Email, \"Bienvenido!\")) ]\n    else\n        [ NoOp ]\n\n// Int√©rprete que ejecuta instrucciones\nlet rec interpret instructions =\n    instructions |> List.iter (function\n        | Email (SendEmail (email, msg)) -> emailService.Send(email, msg)\n        | NoOp -> ())\n\n// Uso:\nlet instructions = buildInstructions someUser\ninterpret instructions\n```\n\n**Ventajas:**  \n- Crea una API orientada al dominio que se puede optimizar y analizar antes de ejecutar.  \n- Permite combinar y transformar instrucciones para optimizaciones.\n\n**Desventajas:**  \n- Complejidad elevada para implementaciones.  \n- Solo factible para dominios espec√≠ficos y conjuntos limitados de operaciones.\n\n---\n\n# Resumen\n\n| Estrategia              | ¬øD√≥nde est√° la dependencia?         | Ejemplo breve                             | Ventaja clave                   | Desventaja principal               |\n|------------------------|------------------------------------|-----------------------------------------|---------------------------------|----------------------------------|\n| Dependency Rejection     | Ninguna en el core, solo resultado | Core devuelve acciones, shell las ejecuta | Core puro, muy testeable        | Necesita modelar acciones         |\n| Dependency Injection     | En constructor de clase            | Servicio inyectado en clase              | Framework-friendly, claro       | Acoplamiento, crecimiento dependencias |\n| Dependency Parametrization | Par√°metros individuales en funci√≥n | Funci√≥n recibe funci√≥n `sendEmail`       | Transparente y modular          | Complejo si dependencias muchas  |\n| Dependency Interpretation | Core produce instrucciones, shell interpreta | Core crea lista de instrucciones         | Optimizable, DSL de dominio     | Alta complejidad, limitado scope |\n\nCada estrategia es √∫til dependiendo del contexto y tama√±o del proyecto. La recomendaci√≥n de Scott Wlaschin es preferir la pureza y parametrizaci√≥n para el core funcional, manteniendo el c√≥digo IO separado y cambiado en los bordes.\n\n---\n\nSi quieres, puedo ayudarte a implementar estas estrategias en un lenguaje espec√≠fico o con un caso m√°s avanzado. ¬øQuieres que contin√∫e?"}}],"usage":{},"raw":{"id":"chatcmpl-BroAJ1QpM5YHYhVnuIJPdg8382AH5","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, a continuaci√≥n detallo cada estrategia para la gesti√≥n de dependencias con un ejemplo pr√°ctico basado en un caso concreto. Supongamos que tenemos una aplicaci√≥n que realiza una operaci√≥n de **env√≠o de correo electr√≥nico** como parte de un workflow, donde el **core funcional** define la l√≥gica para decidir cu√°ndo mandar el mail, pero la operaci√≥n real de env√≠o es IO y est√° en el shell imperativo.\n\n---\n\n### Contexto:  \n**Caso:** Enviar un correo de notificaci√≥n solo si se cumple cierta condici√≥n de negocio en el core funcional.  \n**Dependencia:** Servicio de env√≠o de correo (IO).\n\n---\n\n## 1. Dependency Rejection (Rechazo de dependencias)\n\n**Concepto:** No tener dependencias en el core funcional. El core no sabe nada del env√≠o de correos ni tiene referencias a servicios externos. En lugar de eso, el core devuelve un valor que describe la acci√≥n a realizar para el shell.\n\n**Ejemplo:**\n\n```fsharp\n// Core funcional: pura l√≥gica\ntype NotificationAction = \n    | SendEmail of recipient:string * message:string\n    | NoAction\n\nlet decideNotification (user : User) : NotificationAction =\n    if user.IsActive then\n        SendEmail(user.Email, \"Bienvenido!\")\n    else\n        NoAction\n\n// Shell imperativo: interpreta la acci√≥n\nlet performNotification action =\n    match action with\n    | SendEmail (email, msg) -> emailService.Send(email, msg)  // c√≥digo IO\n    | NoAction -> ()\n\n// Uso\nlet action = decideNotification someUser\nperformNotification action\n```\n\n**Ventajas:**  \n- Core puro, sin dependencias de IO.  \n- F√°cil de testear y comprender.  \n- El core documenta \"qu√© debe pasar\" en lugar de \"c√≥mo\".\n\n**Desventajas:**  \n- Se necesita definir tipos para las acciones que el shell interpretar√°, lo que puede ser tedioso.\n\n---\n\n## 2. Dependency Injection (Inyecci√≥n de dependencias)\n\n**Concepto:** El core funcional o las clases que contienen la l√≥gica reciben por constructor el servicio o interfaz que representa la dependencia.\n\n**Ejemplo:**\n\n```csharp\npublic interface IEmailSender\n{\n    void Send(string recipient, string message);\n}\n\npublic class NotificationService\n{\n    private readonly IEmailSender _emailSender;\n\n    public NotificationService(IEmailSender emailSender)\n    {\n        _emailSender = emailSender;\n    }\n\n    public void NotifyUser(User user)\n    {\n        if (user.IsActive)\n        {\n            _emailSender.Send(user.Email, \"Bienvenido!\");\n        }\n    }\n}\n\n// Shell inicializa la dependencia y la inyecta\nvar emailSender = new SmtpEmailSender();\nvar notificationService = new NotificationService(emailSender);\n\nnotificationService.NotifyUser(user);\n```\n\n**Ventajas:**  \n- Com√∫n y muy utilizada con frameworks de IoC.  \n- Centraliza configuraci√≥n de dependencias.\n\n**Desventajas:**  \n- Clases pueden tener muchas dependencias mezcladas.  \n- A veces interfaz y dependencias crecen sin control.  \n- Dificulta saber qu√© dependencias usa cada m√©todo individual.\n\n---\n\n## 3. Dependency Parametrization (Parametrizaci√≥n de dependencias)\n\n**Concepto:** Pasar solo las dependencias necesarias como par√°metros espec√≠ficos a cada funci√≥n o m√©todo que las utiliza.\n\n**Ejemplo:**\n\n```fsharp\n// Define funci√≥n que recibe expl√≠citamente el \"sendEmail\" como funci√≥n\nlet notifyUser (sendEmail: string -> string -> unit) (user: User) =\n    if user.IsActive then\n        sendEmail user.Email \"Bienvenido!\"\n\n// Shell imperativo pasa funci√≥n concreta\nlet smtpSendEmail recipient message =\n    // C√≥digo imperativo que env√≠a el email\n    emailService.Send(recipient, message)\n\n// Uso\nnotifyUser smtpSendEmail someUser\n```\n\n**Ventajas:**  \n- El c√≥digo se autodocumenta: queda claro qu√© inputs se necesitan.  \n- Reduce acoplamientos y hace expl√≠citas las dependencias.  \n- Permite reemplazar f√°cilmente la funci√≥n IO para tests o diferentes implementaciones.\n\n**Desventajas:**  \n- Puede complicarse si hay muchas dependencias m√∫ltiples anidadas.  \n- Requiere disciplina para no pasar argumentos innecesarios.\n\n---\n\n## 4. Dependency Interpretation (Interpretaci√≥n de dependencias)\n\n**Concepto:** En lugar de ejecutar directamente el IO, el core produce una estructura de datos (instrucciones o comandos) que luego son interpretados por un int√©rprete en el shell imperativo.\n\n**Ejemplo:**\n\n```fsharp\n// Define un lenguaje de dominio para las acciones\ntype EmailCommand =\n    | SendEmail of recipient:string * message:string\n\ntype WorkflowInstruction =\n    | Email of EmailCommand\n    | NoOp\n\n// Core crea una lista de instrucciones\nlet buildInstructions (user: User) : WorkflowInstruction list =\n    if user.IsActive then\n        [ Email (SendEmail(user.Email, \"Bienvenido!\")) ]\n    else\n        [ NoOp ]\n\n// Int√©rprete que ejecuta instrucciones\nlet rec interpret instructions =\n    instructions |> List.iter (function\n        | Email (SendEmail (email, msg)) -> emailService.Send(email, msg)\n        | NoOp -> ())\n\n// Uso:\nlet instructions = buildInstructions someUser\ninterpret instructions\n```\n\n**Ventajas:**  \n- Crea una API orientada al dominio que se puede optimizar y analizar antes de ejecutar.  \n- Permite combinar y transformar instrucciones para optimizaciones.\n\n**Desventajas:**  \n- Complejidad elevada para implementaciones.  \n- Solo factible para dominios espec√≠ficos y conjuntos limitados de operaciones.\n\n---\n\n# Resumen\n\n| Estrategia              | ¬øD√≥nde est√° la dependencia?         | Ejemplo breve                             | Ventaja clave                   | Desventaja principal               |\n|------------------------|------------------------------------|-----------------------------------------|---------------------------------|----------------------------------|\n| Dependency Rejection     | Ninguna en el core, solo resultado | Core devuelve acciones, shell las ejecuta | Core puro, muy testeable        | Necesita modelar acciones         |\n| Dependency Injection     | En constructor de clase            | Servicio inyectado en clase              | Framework-friendly, claro       | Acoplamiento, crecimiento dependencias |\n| Dependency Parametrization | Par√°metros individuales en funci√≥n | Funci√≥n recibe funci√≥n `sendEmail`       | Transparente y modular          | Complejo si dependencias muchas  |\n| Dependency Interpretation | Core produce instrucciones, shell interpreta | Core crea lista de instrucciones         | Optimizable, DSL de dominio     | Alta complejidad, limitado scope |\n\nCada estrategia es √∫til dependiendo del contexto y tama√±o del proyecto. La recomendaci√≥n de Scott Wlaschin es preferir la pureza y parametrizaci√≥n para el core funcional, manteniendo el c√≥digo IO separado y cambiado en los bordes.\n\n---\n\nSi quieres, puedo ayudarte a implementar estas estrategias en un lenguaje espec√≠fico o con un caso m√°s avanzado. ¬øQuieres que contin√∫e?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752161929380-1752163917737","thread_key":"Untitled Chat 1752161929380","stream":true,"user_message":"de la gesti√≥n de dependencias, desde un caso en concreto genera un ejemplo por cada estrategia","new_user_message":true,"class_name":"SmartCompletion"},
"smart_completions:Untitled Chat 1752608594239-1752608594240": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Genera notas de conocimiento para guardarlas para generar un curso"},{"type":"text","text":"‚îú‚îÄ‚îÄ BIBLIOGRAPHY/CONFERENCE-TALKS/\n‚îÇ   ‚îî‚îÄ‚îÄ The Power of Composition.md\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Composici√≥n de Types.md\n    ‚îú‚îÄ‚îÄ Gu√≠a de dise√±o de funciones para realizar composici√≥n.md\n    ‚îú‚îÄ‚îÄ Los Types no son clases, son solo un nombre para un conjunto de cosas.md\n    ‚îú‚îÄ‚îÄ Una funci√≥n es una  cosa  independiente (reusable) que no pertenece o est√° ligada a una clase.md\n    ‚îú‚îÄ‚îÄ Una funci√≥n es una  cosa  que transforma inputs en outputs.md\n    ‚îî‚îÄ‚îÄ Una funci√≥n puede ser usada como input o output de otras funciones.md\n\nNOTES/Gu√≠a de dise√±o de funciones para realizar composici√≥n.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"2.50\"\nminutoFin: \"17.17\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√∫al es?\nPara aplicar composici√≥n de funciones, estas deben seguir la siguiente gu√≠a de dise√±o:\n* Todas las funciones deben estar dise√±adas para ser conectadas. De esta manera, no deber√≠a ser necesario usar patrones como el adapter.\n* Las funciones son reusables en diferentes contextos. Esto funciona por que cada funci√≥n es autocontenida o independientes\n* Al conectar dos o m√°s funciones, la resultante funci√≥n debe ser tambi√©n conectable. Esto permite una composici√≥n sin l√≠mites\n## ¬øPor qu√© es importante\nCon esta gu√≠a se puede, desde funciones peque√±as, ir contruyendo piezas cada vez m√°s grandes hasta tener una aplicaci√≥n web. Empezando desde operaciones de bajo nivel, componer estas para crear servicios, combinando servicios crear un caso de uso, y con un dispatcher o controllador elegir que caso de uso ejecutar a modo de workflow. Lo importante es que todas las funciones creadas, son creadas por medio de la gu√≠a mencionada, as√≠ de simple\nAdem√°s, por compleja que sea la aplicaci√≥n, los datos fluyen siempre solo en una direcci√≥n\n```\nNOTES/Una funci√≥n es una  cosa  que transforma inputs en outputs.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"7.33\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una funci√≥n es una  cosa  independiente (reusable) que no pertenece o est√° ligada a una clase.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.12\"\nminutoFin: \"8.42\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una funci√≥n puede ser usada como input o output de otras funciones.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.42\"\nminutoFin: \"10.15\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Los Types no son clases, son solo un nombre para un conjunto de cosas.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"17.13\"\nminutoFin: \"19.02\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© significa?\nSe trata de poner nombre, dada una caracter√≠stica com√∫n,  a un conjunto de elementos. Esto aplica tambi√©n a las funciones, dado que una cosa. Normalmente se entiende bien bajo el contexto de una funci√≥n, ya que una funci√≥n recibe un conjunto posibles cosas de un tipo y es capaz de devolver un conjunto de posibles cosas como output. Por tanto, tienen sentido en tanto y cuanto sean parte de un proceso de una funci√≥n.\n```\nNOTES/Composici√≥n de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es?\nPara la composici√≥n se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento est√° separado de los datos.\nPara construir types \"m√°s grandes/complejos\" se empieza desde types m√°s simples/peque√±os por medio de:\n* Composici√≥n  con \"AND\"  (record)\n\t* es una agrupaci√≥n de types en un objeto, record, struct...\n*  Composici√≥n con \"OR\" (choice)\n\t* Es una elecci√≥n entre diferentes opciones. una forma de hacerlo es usando enums\n## ¬øPor qu√© es interesante?\nEsto permite generar una documentaci√≥n que es ejecutable. Desde la declaraci√≥n de types, su composici√≥n se puede inferir la definici√≥n de los elementos del negocio que est√°n en juego y como se relacionan. Adem√°s al ser ligero, en un mismo fichero es f√°cil de inferir todo m√°s directo\n## ¬øC√≥mo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita informaci√≥n adicional\n>Para `Paypal` se necesita un correo electr√≥nico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementaci√≥n:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```\nBIBLIOGRAPHY/CONFERENCE-TALKS/The Power of Composition.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=rCKPgu4DvcE\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: NDC Conferences Oslo 2020\n```\n## Notas\n|File6|minutoInicio|minutoFin|\n|---|---|---|\n|[Gu√≠a de dise√±o de funciones para realizar composici√≥n](NOTES/Gu√≠a de dise√±o de funciones para realizar composici√≥n.md)|2.50|17.17|\n|[Una funci√≥n es una cosa que transforma inputs en outputs](NOTES/Una funci√≥n es una  cosa  que transforma inputs en outputs.md)|7.33|-|\n|[Una funci√≥n es una cosa independiente (reusable) que no pertenece o est√° ligada a una clase](NOTES/Una funci√≥n es una  cosa  independiente \\(reusable\\) que no pertenece o est√° ligada a una clase.md)|8.12|8.42|\n|[Una funci√≥n puede ser usada como input o output de otras funciones](NOTES/Una funci√≥n puede ser usada como input o output de otras funciones.md)|8.42|10.15|\n|[Los Types no son clases, son solo un nombre para un conjunto de cosas](NOTES/Los Types no son clases, son solo un nombre para un conjunto de cosas.md)|17.13|19.02|\n|[Composici√≥n de Types](NOTES/Composici√≥n de Types.md)|19.00|25.01|\n```"},{"type":"text","text":"Genera notas de conocimiento para guardarlas para generar un curso"}]}]},"responses":[{"timestamp":1752608658921,"id":"chatcmpl-BtfrEncCdhjtB7jFG6yv0qs5KEGTl","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Aqu√≠ tienes una recopilaci√≥n estructurada de notas de conocimiento basadas en el material proporcionado, organizadas para facilitar la creaci√≥n de un curso sobre composici√≥n funcional y dise√±o de tipos. Las notas incluyen definiciones clave, principios importantes, ejemplos y conceptos para explicar en el curso.\n\n---\n\n# Curso: Fundamentos de Composici√≥n Funcional y Dise√±o de Tipos\n\n---\n\n## 1. Introducci√≥n a la Composici√≥n Funcional\n\n### ¬øQu√© es la composici√≥n de funciones?\n- La composici√≥n consiste en conectar funciones que transforman datos, donde la salida de una funci√≥n es la entrada de otra.\n- Esta t√©cnica permite construir sistemas complejos agregando funcionalidades simples de forma modular y escalable.\n\n### Principios b√°sicos:\n- Las funciones deben ser independientes y autocontenidas.\n- Deben poder reutilizarse en diferentes contextos sin depender de implementaciones externas.\n- La salida de la composici√≥n debe ser a su vez una funci√≥n conectable, permitiendo composici√≥n ilimitada.\n\n---\n\n## 2. Gu√≠a de Dise√±o para Funciones Componibles  \n\n### Caracter√≠sticas que deben cumplir:\n- **Dise√±adas para ser conectadas:** sincronizaci√≥n perfecta sin necesidad de adaptadores.\n- **Reutilizables:** independencia del contexto o clase.\n- **Composables recursivamente:** la composici√≥n de funciones genera nuevas funciones que pueden a su vez ser compuestas.\n\n### Importancia\n- Permite crear aplicaciones completas desde funciones simples.\n- Facilita flujos de datos unidireccionales, haciendo el sistema predecible y mantenible.\n  \n---\n\n## 3. Conceptos Clave sobre Funciones\n\n### Una funci√≥n es...\n- Una cosa que **transforma inputs en outputs.**\n- Una cosa **independiente (reusable)** que no est√° ligada a una clase.\n- Una cosa que **puede usarse como input u output** de otras funciones.\n\nEstas cualidades facilitan la composici√≥n y reutilizaci√≥n.\n\n---\n\n## 4. Concepto de Types (Tipos)\n\n### ¬øQu√© son los types?\n- No son clases ni definiciones r√≠gidas, sino **nombres para conjuntos de elementos que comparten caracter√≠sticas comunes.**\n- Se utilizan para **poner nombre a conjuntos de datos o funciones** en el contexto de la composici√≥n.\n\n---\n\n## 5. Composici√≥n de Types (Tipos Algebraicos)\n\n### Sistemas de composici√≥n:\n- **Composici√≥n \"AND\" (record/registro):** agrupa propiedades m√∫ltiples en un solo objeto.\n- **Composici√≥n \"OR\" (choice/elecci√≥n):** representa alternativas usando enumeraciones o sumas de tipos.\n\n### Ventajas:\n- Documentaci√≥n ejecutable.\n- Claridad al describir entidades de dominio y sus relaciones.\n- Ligereza del c√≥digo al fusionar definiciones.\n\n### C√≥mo nombrar los types:\n- Pueden ser sustantivos (para valores/datos) o verbos (para funciones/operaciones).\n\n---\n\n## 6. Ejemplo Pr√°ctico: Modelado de Formas de Pago\n\n```fsharp\ntype EmailAddress = string  // tipo primitivo\ntype CardNumber = string    // tipo primitivo\ntype CardType = Visa | MasterCard  // tipo enumerado (choice)\n\ntype CreditCardInfo = {   // tipo record (AND)\n  CardNumber: CardNumber\n  CardType: CardType\n}\n\ntype PaymentMethod =       // tipo choice (OR)\n  | Cash\n  | Paypal of EmailAddress\n  | Card of CreditCardInfo\n\ntype PaymentAmount = decimal    // tipo primitivo\n\ntype Currency = EUR | USD | RUB // tipo choice\n\ntype Payment = {                // tipo record (AND)\n  Amount: PaymentAmount\n  Currency: Currency\n  Method: PaymentMethod\n}\n```\n\nEste ejemplo muestra c√≥mo combinar tipos simples en tipos complejos que representan un dominio de negocio real.\n\n---\n\n## 7. Referencias y Profundizaci√≥n\n\n- **Conferencia:** [The Power of Composition - Scott Wlaschin - NDC Oslo 2020](https://www.youtube.com/watch?v=rCKPgu4DvcE)\n- Notas clave est√°n relacionadas con los minutos indicados para un estudio detallado y un mejor aprovechamiento.\n\n---\n\n# Resumen para la generaci√≥n del curso\n\nEl curso puede estructurarse en m√≥dulos:\n\n1. **Introducci√≥n a la composici√≥n funcional**\n2. **Dise√±o gu√≠a para funciones componibles**\n3. **Naturaleza y uso de las funciones**\n4. **Concepto y composici√≥n de Types**\n5. **Ejemplos pr√°cticos con tipos algebraicos**\n6. **Estudio de caso y ejercicio pr√°ctico**\n7. **Conclusiones y recursos adicionales**\n\n---\n\nSi quieres, puedo ayudarte a desglosar estos puntos en lecciones, presentaciones o ejercicios pr√°cticos. ¬øQuieres que prepare ese material?"}}],"usage":{},"raw":{"id":"chatcmpl-BtfrEncCdhjtB7jFG6yv0qs5KEGTl","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Aqu√≠ tienes una recopilaci√≥n estructurada de notas de conocimiento basadas en el material proporcionado, organizadas para facilitar la creaci√≥n de un curso sobre composici√≥n funcional y dise√±o de tipos. Las notas incluyen definiciones clave, principios importantes, ejemplos y conceptos para explicar en el curso.\n\n---\n\n# Curso: Fundamentos de Composici√≥n Funcional y Dise√±o de Tipos\n\n---\n\n## 1. Introducci√≥n a la Composici√≥n Funcional\n\n### ¬øQu√© es la composici√≥n de funciones?\n- La composici√≥n consiste en conectar funciones que transforman datos, donde la salida de una funci√≥n es la entrada de otra.\n- Esta t√©cnica permite construir sistemas complejos agregando funcionalidades simples de forma modular y escalable.\n\n### Principios b√°sicos:\n- Las funciones deben ser independientes y autocontenidas.\n- Deben poder reutilizarse en diferentes contextos sin depender de implementaciones externas.\n- La salida de la composici√≥n debe ser a su vez una funci√≥n conectable, permitiendo composici√≥n ilimitada.\n\n---\n\n## 2. Gu√≠a de Dise√±o para Funciones Componibles  \n\n### Caracter√≠sticas que deben cumplir:\n- **Dise√±adas para ser conectadas:** sincronizaci√≥n perfecta sin necesidad de adaptadores.\n- **Reutilizables:** independencia del contexto o clase.\n- **Composables recursivamente:** la composici√≥n de funciones genera nuevas funciones que pueden a su vez ser compuestas.\n\n### Importancia\n- Permite crear aplicaciones completas desde funciones simples.\n- Facilita flujos de datos unidireccionales, haciendo el sistema predecible y mantenible.\n  \n---\n\n## 3. Conceptos Clave sobre Funciones\n\n### Una funci√≥n es...\n- Una cosa que **transforma inputs en outputs.**\n- Una cosa **independiente (reusable)** que no est√° ligada a una clase.\n- Una cosa que **puede usarse como input u output** de otras funciones.\n\nEstas cualidades facilitan la composici√≥n y reutilizaci√≥n.\n\n---\n\n## 4. Concepto de Types (Tipos)\n\n### ¬øQu√© son los types?\n- No son clases ni definiciones r√≠gidas, sino **nombres para conjuntos de elementos que comparten caracter√≠sticas comunes.**\n- Se utilizan para **poner nombre a conjuntos de datos o funciones** en el contexto de la composici√≥n.\n\n---\n\n## 5. Composici√≥n de Types (Tipos Algebraicos)\n\n### Sistemas de composici√≥n:\n- **Composici√≥n \"AND\" (record/registro):** agrupa propiedades m√∫ltiples en un solo objeto.\n- **Composici√≥n \"OR\" (choice/elecci√≥n):** representa alternativas usando enumeraciones o sumas de tipos.\n\n### Ventajas:\n- Documentaci√≥n ejecutable.\n- Claridad al describir entidades de dominio y sus relaciones.\n- Ligereza del c√≥digo al fusionar definiciones.\n\n### C√≥mo nombrar los types:\n- Pueden ser sustantivos (para valores/datos) o verbos (para funciones/operaciones).\n\n---\n\n## 6. Ejemplo Pr√°ctico: Modelado de Formas de Pago\n\n```fsharp\ntype EmailAddress = string  // tipo primitivo\ntype CardNumber = string    // tipo primitivo\ntype CardType = Visa | MasterCard  // tipo enumerado (choice)\n\ntype CreditCardInfo = {   // tipo record (AND)\n  CardNumber: CardNumber\n  CardType: CardType\n}\n\ntype PaymentMethod =       // tipo choice (OR)\n  | Cash\n  | Paypal of EmailAddress\n  | Card of CreditCardInfo\n\ntype PaymentAmount = decimal    // tipo primitivo\n\ntype Currency = EUR | USD | RUB // tipo choice\n\ntype Payment = {                // tipo record (AND)\n  Amount: PaymentAmount\n  Currency: Currency\n  Method: PaymentMethod\n}\n```\n\nEste ejemplo muestra c√≥mo combinar tipos simples en tipos complejos que representan un dominio de negocio real.\n\n---\n\n## 7. Referencias y Profundizaci√≥n\n\n- **Conferencia:** [The Power of Composition - Scott Wlaschin - NDC Oslo 2020](https://www.youtube.com/watch?v=rCKPgu4DvcE)\n- Notas clave est√°n relacionadas con los minutos indicados para un estudio detallado y un mejor aprovechamiento.\n\n---\n\n# Resumen para la generaci√≥n del curso\n\nEl curso puede estructurarse en m√≥dulos:\n\n1. **Introducci√≥n a la composici√≥n funcional**\n2. **Dise√±o gu√≠a para funciones componibles**\n3. **Naturaleza y uso de las funciones**\n4. **Concepto y composici√≥n de Types**\n5. **Ejemplos pr√°cticos con tipos algebraicos**\n6. **Estudio de caso y ejercicio pr√°ctico**\n7. **Conclusiones y recursos adicionales**\n\n---\n\nSi quieres, puedo ayudarte a desglosar estos puntos en lecciones, presentaciones o ejercicios pr√°cticos. ¬øQuieres que prepare ese material?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752608594239-1752608594240","thread_key":"Untitled Chat 1752608594239","stream":true,"context_key":"1752608594240","class_name":"SmartCompletion","user_message":"Genera notas de conocimiento para guardarlas para generar un curso","new_user_message":true},
"smart_completions:Untitled Chat 1752608985407-1752608985407": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"transforma el ejemplo de c√≥digo a typescript"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îî‚îÄ‚îÄ Composici√≥n de Types.md\n\nNOTES/Composici√≥n de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es?\nPara la composici√≥n se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento est√° separado de los datos.\nPara construir types \"m√°s grandes/complejos\" se empieza desde types m√°s simples/peque√±os por medio de:\n* Composici√≥n  con \"AND\"  (record)\n\t* es una agrupaci√≥n de types en un objeto, record, struct...\n*  Composici√≥n con \"OR\" (choice)\n\t* Es una elecci√≥n entre diferentes opciones. una forma de hacerlo es usando enums\n## ¬øPor qu√© es interesante?\nEsto permite generar una documentaci√≥n que es ejecutable. Desde la declaraci√≥n de types, su composici√≥n se puede inferir la definici√≥n de los elementos del negocio que est√°n en juego y como se relacionan. Adem√°s al ser ligero, en un mismo fichero es f√°cil de inferir todo m√°s directo\n## ¬øC√≥mo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita informaci√≥n adicional\n>Para `Paypal` se necesita un correo electr√≥nico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementaci√≥n:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```"},{"type":"text","text":"transforma el ejemplo de c√≥digo a typescript"}]}]},"responses":[{"timestamp":1752609005311,"id":"chatcmpl-Btfx2iUBuYkDfxxXweH5U1bcs2rsL","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, aqu√≠ tienes la transformaci√≥n del ejemplo dado en F# a TypeScript, respetando las composiciones con tipos \"AND\" (objetos) y \"OR\" (uniones / enums):\n\n```typescript\n// Tipos primitivos alias (TypeScript no necesita alias para string/number pero se ponen para claridad)\ntype EmailAddress = string;\ntype CardNumber = string;\ntype PaymentAmount = number; // decimal se representa con number en TypeScript\n\n// Tipo \"choice\" usando enum para CardType\nenum CardType {\n  Visa = \"Visa\",\n  MasterCard = \"MasterCard\",\n}\n\n// Tipo \"record\" (AND) para la informaci√≥n de la tarjeta\ninterface CreditCardInfo {\n  cardNumber: CardNumber;\n  cardType: CardType;\n}\n\n// Tipo \"choice\" (OR) representado con tipos discriminados en TypeScript\ntype PaymentMethod =\n  | { type: \"Cash\" }\n  | { type: \"Paypal\"; email: EmailAddress }\n  | { type: \"Card\"; cardInfo: CreditCardInfo };\n\n// Tipo \"choice\" usando enum para Currency\nenum Currency {\n  EUR = \"EUR\",\n  USD = \"USD\",\n  RUB = \"RUB\",\n}\n\n// Tipo \"record\" (AND) para el pago completo\ninterface Payment {\n  amount: PaymentAmount;\n  currency: Currency;\n  method: PaymentMethod;\n}\n```\n\n---\n\n### Explicaci√≥n breve\n- Usamos `enum` para representar opciones limitadas, como `CardType` y `Currency` (OR/choice types).\n- Representamos tipos \"record\" como `interface` (AND/composici√≥n de propiedades).\n- Para el discriminated union de `PaymentMethod`, usamos objetos con un campo `type` para identificar la variante y los datos asociados correspondiente a cada una.\n\nSi quieres, puedo ayudarte tambi√©n con ejemplos de funciones que usen estos tipos en TypeScript."}}],"usage":{},"raw":{"id":"chatcmpl-Btfx2iUBuYkDfxxXweH5U1bcs2rsL","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, aqu√≠ tienes la transformaci√≥n del ejemplo dado en F# a TypeScript, respetando las composiciones con tipos \"AND\" (objetos) y \"OR\" (uniones / enums):\n\n```typescript\n// Tipos primitivos alias (TypeScript no necesita alias para string/number pero se ponen para claridad)\ntype EmailAddress = string;\ntype CardNumber = string;\ntype PaymentAmount = number; // decimal se representa con number en TypeScript\n\n// Tipo \"choice\" usando enum para CardType\nenum CardType {\n  Visa = \"Visa\",\n  MasterCard = \"MasterCard\",\n}\n\n// Tipo \"record\" (AND) para la informaci√≥n de la tarjeta\ninterface CreditCardInfo {\n  cardNumber: CardNumber;\n  cardType: CardType;\n}\n\n// Tipo \"choice\" (OR) representado con tipos discriminados en TypeScript\ntype PaymentMethod =\n  | { type: \"Cash\" }\n  | { type: \"Paypal\"; email: EmailAddress }\n  | { type: \"Card\"; cardInfo: CreditCardInfo };\n\n// Tipo \"choice\" usando enum para Currency\nenum Currency {\n  EUR = \"EUR\",\n  USD = \"USD\",\n  RUB = \"RUB\",\n}\n\n// Tipo \"record\" (AND) para el pago completo\ninterface Payment {\n  amount: PaymentAmount;\n  currency: Currency;\n  method: PaymentMethod;\n}\n```\n\n---\n\n### Explicaci√≥n breve\n- Usamos `enum` para representar opciones limitadas, como `CardType` y `Currency` (OR/choice types).\n- Representamos tipos \"record\" como `interface` (AND/composici√≥n de propiedades).\n- Para el discriminated union de `PaymentMethod`, usamos objetos con un campo `type` para identificar la variante y los datos asociados correspondiente a cada una.\n\nSi quieres, puedo ayudarte tambi√©n con ejemplos de funciones que usen estos tipos en TypeScript."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752608985407-1752608985407","thread_key":"Untitled Chat 1752608985407","stream":true,"context_key":"1752608985407","class_name":"SmartCompletion","user_message":"transforma el ejemplo de c√≥digo a typescript","new_user_message":true},
"smart_completions:Untitled Chat 1753470938123-1753470938123": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"genera una conclusi√≥n"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îî‚îÄ‚îÄ Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md\n\nNOTES/Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Construyeron o se asocian a una aplicaci√≥n/framework revolucionario\nEstos lenguajes se vuelven populares porque esas aplicaciones resuelve un problema significativo y/o satisface una gran demanda. Por tanto, la trayectoria de estas aplicaciones y estas applicaciones/frameworks queda ligada porque el lenguaje ofrece la forma m√°s r√°pida, f√°cil o, en su momento, la √∫nica viable para utilizar la aplicaci√≥n deseada. No se trata de que el lenguaje sea inherentemente superior o m√°s atractivo, sino de que es la puerta de entrada a algo que los usuarios _realmente_ necesitan o quieren.\nEjemplos de lo anterior son:\n* VisiCalc para el Apple II\n* Ruby on Rails para Ruby\n* PHP para HTML din√°mico, WordPress y Drupal\n* C para la programaci√≥n de sistemas:*\n## Tienen exclusividad de plataforma\nUn lenguaje se convierte en la **forma preferida o, a menudo, la √∫nica viable para desarrollar en un ecosistema de software o hardware muy grande y dominante**. La inmensidad de la plataforma en s√≠ misma es suficiente para impulsar el lenguaje a la cima, **independientemente de su dise√±o intr√≠nseco** (ya sea funcional, imperativo, o orientado a objetos).\nPodemos ver esto manifestado con\n* Objective-C y Swift para Apple, la pura escala de la plataforma Apple garantiza su popularidad\n* JavaScript para la web: Se convirti√≥ en el est√°ndar de facto.\n* C# para Microsoft Windows:  Su √©xito se debi√≥ a la exclusividad de las herramientas de Microsoft en su plataforma.\n## Dan facilidad de una adopci√≥n r√°pida y/o reutilizaci√≥n de c√≥digo existente\nHay lenguajes que se han creado con vistas a atraer o ofrecer a comunidades una alternativa su lenguaje actual de una manera que sea f√°cil y/o tambi√©n que les permita no tener que hacer una reescritura de sus proyectos. Todo con el argumento de que al hacer la migraci√≥n tendr√°n grandes beneficios. En resumen, estos lenguajes tratan de aprovechar la familiaridad del desarrollador (reducci√≥n del coste de aprendizaje) y reducir las barreras de entrada.\nVeamos c√≥mo algunos lenguajes exitosos han utilizado esta estrategia:\n‚Ä¢ **CoffeeScript**: Uno de los primeros lenguajes en prosperar con esta filosof√≠a.\n¬†¬†¬†* Su eslogan era \"es solo JavaScript\".\n¬†¬†¬†* Promet√≠a que, si ya eras programador de JavaScript, pod√≠as aprenderlo en **aproximadamente media hora**.\n¬†¬†¬†* Ofrec√≠a scripts para **convertir autom√°ticamente** tu c√≥digo JavaScript existente a CoffeeScript, lo que minimizaba dr√°sticamente el **esfuerzo de migraci√≥n** y reforzaba la idea de que era \"solo\" JavaScript.\n¬†¬†¬†* Esto fue suficiente para impulsarlo a ser el 11¬∫ lenguaje m√°s popular en GitHub en su apogeo.\n‚Ä¢ **TypeScript**: Un ejemplo fuerte de esta estrategia.\n¬†* Es un **superconjunto estricto de JavaScript**, lo que significa que el c√≥digo JavaScript v√°lido es, por definici√≥n, tambi√©n c√≥digo TypeScript v√°lido.\n¬†* La migraci√≥n puede ser tan simple como **renombrar un archivo** **.js** **a** **.ts**, y \"se supone que simplemente funciona\". A partir de ah√≠, los desarrolladores pueden a√±adir incrementalmente las caracter√≠sticas de TypeScript.\n¬†* Ofrece **beneficios** (como el tipado est√°tico) con un **costo percibido m√≠nimo** (\"solo tienes que renombrar el archivo\"), lo que ha llevado a que mucha gente lo adopte.\n‚Ä¢ **C++**:  El primer gran √©xito de esta estrategia.\n* Era un \"casi superconjunto\" de C.\n* Permiti√≥ a los programadores de C tomar sus archivos `.c`, renombrarlos a `.cpp` y comenzar a acceder a los **beneficios adicionales** de C++. Esto facilit√≥ una transici√≥n y adopci√≥n exitosa.\n‚Ä¢ **Kotlin**: Un ejemplo moderno que, aunque es un lenguaje \"sustancialmente diferente\" de Java, capitaliza la misma idea.\n* Enfatiza su **\"interoperabilidad del 100% con las bases de c√≥digo Java existentes\"** y la disponibilidad de scripts para **convertir Java a Kotlin**.\n* Esto reduce el **esfuerzo de migraci√≥n** y el riesgo percibido para las empresas y desarrolladores con grandes bases de c√≥digo Java, contribuyendo a su gran √©xito.\n## Marketing\nHay lenguajes donde hubo detr√°s inversiones monetarias masivas como en el caso de Java por parte de Sun Microsystems invirti√≥ **500 millones de d√≥lares en una nueva campa√±a de marketing solo para Java**. Con ello obtuvo una omnipresencia en diversos medios que hicieron que fuera un elemento muy reconocible por parte de las personas que desarrollan.\nPor otro lado, JavaScript es el resultado de aprovechar la ola de popularidad de Java. originalmente concebido como un Lisp funcional basado en Scheme, fue forzado por Mozilla a adoptar una sintaxis y un enfoque orientado a objetos similares a Java**. Incluso su nombre contiene \"Java\"...\n## Otros factores secundarios\n‚Ä¢ **Mercado Laboral**\n\tlos desarrolladores dudan en aprender un lenguaje si no hay trabajos disponibles que lo requieran, y los empleadores dudan en adoptar un lenguaje si no pueden encontrar desarrolladores para √©l. Este **refuerza la popularidad de los lenguajes que ya son dominantes**, ya que el gran volumen de trabajos existentes valida su aprendizaje, y la oferta de desarrolladores refuerza su uso por parte de las empresas.\n‚Ä¢ **Comunidad**\n\tLa comunidad alrededor de un lenguaje puede ser un activo importante o un pasivo. Una comunidad acogedora y colaborativa puede atraer y retener a desarrolladores. Adem√°s, de lo que genera la comunidad. Un ejemplo de esto √∫ltimo es Python con diferentes √°mbitos donde la comunidad tiene casi que una tool para cada caso de uso. Y donde m√°s ha explotado es en el √°mbito de la inteligencia artificial.\n‚Ä¢ **Rendimiento**\n\tSe considera una **preocupaci√≥n secundaria** que influye m√°s en los **dominios de uso** de un lenguaje que en su popularidad general. Para ciertas aplicaciones, como la **programaci√≥n de sistemas** (sistemas operativos, utilidades de bajo nivel), es **cr√≠tico tener control sobre la memoria**, lo que favorece lenguajes como C, C++ y, m√°s recientemente, Rust. Sin embargo, para una vasta cantidad de dominios, el rendimiento absoluto no es el factor decisivo. Python, por ejemplo, es un lenguaje \"perfectamente aceptable\" para servidores de backend, incluso si no es el m√°s r√°pido, porque el rendimiento suele estar limitado por factores externos como la red o la base de datos.\n```"},{"type":"text","text":"genera una conclusi√≥n"}]}]},"responses":[{"timestamp":1753470956539,"id":"chatcmpl-BxIBRdiyItoaZ6uwK7ALuMpE84H8Q","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"En conclusi√≥n, la popularidad de los lenguajes de programaci√≥n no depende √∫nicamente de sus caracter√≠sticas t√©cnicas o su dise√±o intr√≠nseco, sino que est√° estrechamente ligada a factores externos y estrat√©gicos. Lenguajes que se asocian con aplicaciones o frameworks revolucionarios, que poseen exclusividad en plataformas dominantes, o que facilitan una adopci√≥n r√°pida mediante la reutilizaci√≥n y compatibilidad con c√≥digo existente, tienden a consolidar su uso masivo. Adem√°s, el marketing y la inversi√≥n en promoci√≥n juegan un papel fundamental para aumentar su visibilidad y aceptaci√≥n. Otros elementos como la disponibilidad de empleo, la fortaleza de la comunidad y consideraciones de rendimiento tambi√©n influyen, aunque con menor peso en la popularidad general. En definitiva, la elecci√≥n y √©xito de un lenguaje es un fen√≥meno multidimensional que responde tanto a necesidades pr√°cticas del mercado como a din√°micas sociales y comerciales dentro del ecosistema tecnol√≥gico."}}],"usage":{},"raw":{"id":"chatcmpl-BxIBRdiyItoaZ6uwK7ALuMpE84H8Q","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"En conclusi√≥n, la popularidad de los lenguajes de programaci√≥n no depende √∫nicamente de sus caracter√≠sticas t√©cnicas o su dise√±o intr√≠nseco, sino que est√° estrechamente ligada a factores externos y estrat√©gicos. Lenguajes que se asocian con aplicaciones o frameworks revolucionarios, que poseen exclusividad en plataformas dominantes, o que facilitan una adopci√≥n r√°pida mediante la reutilizaci√≥n y compatibilidad con c√≥digo existente, tienden a consolidar su uso masivo. Adem√°s, el marketing y la inversi√≥n en promoci√≥n juegan un papel fundamental para aumentar su visibilidad y aceptaci√≥n. Otros elementos como la disponibilidad de empleo, la fortaleza de la comunidad y consideraciones de rendimiento tambi√©n influyen, aunque con menor peso en la popularidad general. En definitiva, la elecci√≥n y √©xito de un lenguaje es un fen√≥meno multidimensional que responde tanto a necesidades pr√°cticas del mercado como a din√°micas sociales y comerciales dentro del ecosistema tecnol√≥gico."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1753470938123-1753470938123","thread_key":"Untitled Chat 1753470938123","stream":true,"context_key":"1753470938123","class_name":"SmartCompletion","user_message":"genera una conclusi√≥n","new_user_message":true},
"smart_completions:Untitled Chat 1753472583163-1753472583163": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"puedes mejorar la redacci√≥n?"},{"type":"text","text":"‚îú‚îÄ‚îÄ BIBLIOGRAPHY/VIDEOS/\n‚îÇ   ‚îî‚îÄ‚îÄ Why Isn't Functional Programming the Norm.md\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îî‚îÄ‚îÄ Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md\n\nNOTES/Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Construyeron o se asocian a una aplicaci√≥n/framework revolucionario\nEstos lenguajes se vuelven populares porque esas aplicaciones resuelve un problema significativo y/o satisface una gran demanda. Por tanto, la trayectoria de estas aplicaciones y estas applicaciones/frameworks queda ligada porque el lenguaje ofrece la forma m√°s r√°pida, f√°cil o, en su momento, la √∫nica viable para utilizar la aplicaci√≥n deseada. No se trata de que el lenguaje sea inherentemente superior o m√°s atractivo, sino de que es la puerta de entrada a algo que los usuarios _realmente_ necesitan o quieren.\nEjemplos de lo anterior son:\n* VisiCalc para el Apple II\n* Ruby on Rails para Ruby\n* PHP para HTML din√°mico, WordPress y Drupal\n* C para la programaci√≥n de sistemas:*\n## Tienen exclusividad de plataforma\nUn lenguaje se convierte en la **forma preferida o, a menudo, la √∫nica viable para desarrollar en un ecosistema de software o hardware muy grande y dominante**. La inmensidad de la plataforma en s√≠ misma es suficiente para impulsar el lenguaje a la cima, **independientemente de su dise√±o intr√≠nseco** (ya sea funcional, imperativo, o orientado a objetos).\nPodemos ver esto manifestado con\n* Objective-C y Swift para Apple, la pura escala de la plataforma Apple garantiza su popularidad\n* JavaScript para la web: Se convirti√≥ en el est√°ndar de facto.\n* C# para Microsoft Windows:  Su √©xito se debi√≥ a la exclusividad de las herramientas de Microsoft en su plataforma.\n## Dan facilidad de una adopci√≥n r√°pida y/o reutilizaci√≥n de c√≥digo existente\nHay lenguajes que se han creado con vistas a atraer o ofrecer a comunidades una alternativa su lenguaje actual de una manera que sea f√°cil y/o tambi√©n que les permita no tener que hacer una reescritura de sus proyectos. Todo con el argumento de que al hacer la migraci√≥n tendr√°n grandes beneficios. En resumen, estos lenguajes tratan de aprovechar la familiaridad del desarrollador (reducci√≥n del coste de aprendizaje) y reducir las barreras de entrada.\nVeamos c√≥mo algunos lenguajes exitosos han utilizado esta estrategia:\n‚Ä¢ **CoffeeScript**: Uno de los primeros lenguajes en prosperar con esta filosof√≠a.\n¬†¬†¬†* Su eslogan era \"es solo JavaScript\".\n¬†¬†¬†* Promet√≠a que, si ya eras programador de JavaScript, pod√≠as aprenderlo en **aproximadamente media hora**.\n¬†¬†¬†* Ofrec√≠a scripts para **convertir autom√°ticamente** tu c√≥digo JavaScript existente a CoffeeScript, lo que minimizaba dr√°sticamente el **esfuerzo de migraci√≥n** y reforzaba la idea de que era \"solo\" JavaScript.\n¬†¬†¬†* Esto fue suficiente para impulsarlo a ser el 11¬∫ lenguaje m√°s popular en GitHub en su apogeo.\n‚Ä¢ **TypeScript**: Un ejemplo fuerte de esta estrategia.\n¬†* Es un **superconjunto estricto de JavaScript**, lo que significa que el c√≥digo JavaScript v√°lido es, por definici√≥n, tambi√©n c√≥digo TypeScript v√°lido.\n¬†* La migraci√≥n puede ser tan simple como **renombrar un archivo** **.js** **a** **.ts**, y \"se supone que simplemente funciona\". A partir de ah√≠, los desarrolladores pueden a√±adir incrementalmente las caracter√≠sticas de TypeScript.\n¬†* Ofrece **beneficios** (como el tipado est√°tico) con un **costo percibido m√≠nimo** (\"solo tienes que renombrar el archivo\"), lo que ha llevado a que mucha gente lo adopte.\n‚Ä¢ **C++**:  El primer gran √©xito de esta estrategia.\n* Era un \"casi superconjunto\" de C.\n* Permiti√≥ a los programadores de C tomar sus archivos `.c`, renombrarlos a `.cpp` y comenzar a acceder a los **beneficios adicionales** de C++. Esto facilit√≥ una transici√≥n y adopci√≥n exitosa.\n‚Ä¢ **Kotlin**: Un ejemplo moderno que, aunque es un lenguaje \"sustancialmente diferente\" de Java, capitaliza la misma idea.\n* Enfatiza su **\"interoperabilidad del 100% con las bases de c√≥digo Java existentes\"** y la disponibilidad de scripts para **convertir Java a Kotlin**.\n* Esto reduce el **esfuerzo de migraci√≥n** y el riesgo percibido para las empresas y desarrolladores con grandes bases de c√≥digo Java, contribuyendo a su gran √©xito.\n## Marketing\nHay lenguajes donde hubo detr√°s inversiones monetarias masivas como en el caso de Java por parte de Sun Microsystems invirti√≥ **500 millones de d√≥lares en una nueva campa√±a de marketing solo para Java**. Con ello obtuvo una omnipresencia en diversos medios que hicieron que fuera un elemento muy reconocible por parte de las personas que desarrollan.\nPor otro lado, JavaScript es el resultado de aprovechar la ola de popularidad de Java. originalmente concebido como un Lisp funcional basado en Scheme, fue forzado por Mozilla a adoptar una sintaxis y un enfoque orientado a objetos similares a Java**. Incluso su nombre contiene \"Java\"...\n## Otros factores secundarios\n‚Ä¢ **Mercado Laboral**\n\tlos desarrolladores dudan en aprender un lenguaje si no hay trabajos disponibles que lo requieran, y los empleadores dudan en adoptar un lenguaje si no pueden encontrar desarrolladores para √©l. Este **refuerza la popularidad de los lenguajes que ya son dominantes**, ya que el gran volumen de trabajos existentes valida su aprendizaje, y la oferta de desarrolladores refuerza su uso por parte de las empresas.\n‚Ä¢ **Comunidad**\n\tLa comunidad alrededor de un lenguaje puede ser un activo importante o un pasivo. Una comunidad acogedora y colaborativa puede atraer y retener a desarrolladores. Adem√°s, de lo que genera la comunidad. Un ejemplo de esto √∫ltimo es Python con diferentes √°mbitos donde la comunidad tiene casi que una tool para cada caso de uso. Y donde m√°s ha explotado es en el √°mbito de la inteligencia artificial.\n‚Ä¢ **Rendimiento**\n\tSe considera una **preocupaci√≥n secundaria** que influye m√°s en los **dominios de uso** de un lenguaje que en su popularidad general. Para ciertas aplicaciones, como la **programaci√≥n de sistemas** (sistemas operativos, utilidades de bajo nivel), es **cr√≠tico tener control sobre la memoria**, lo que favorece lenguajes como C, C++ y, m√°s recientemente, Rust. Sin embargo, para una vasta cantidad de dominios, el rendimiento absoluto no es el factor decisivo. Python, por ejemplo, es un lenguaje \"perfectamente aceptable\" para servidores de backend, incluso si no es el m√°s r√°pido, porque el rendimiento suele estar limitado por factores externos como la red o la base de datos.\n```\nBIBLIOGRAPHY/VIDEOS/Why Isn't Functional Programming the Norm.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=QyJZzq0v7Z4&t=16s\nautores:\n  - \"[[Richard Feldman]]\"\ntype: CONFERENCE-TALK\nconferencia: Clojutre 2019\n```\n## Notas\n|File8|minutoInicio|minutoFin|\n|---|---|---|\n|[Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares](NOTES/Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md)|01:53|18:45|\n|[Aplicaciones o frameworks revolucionarios hacen los lenguajes de programaci√≥n, que los han construido o con las cuales se pueden utilizar, tengan una popularidad asociada a estas](NOTES/Aplicaciones o frameworks revolucionarios hacen los lenguajes de programaci√≥n, que los han construido o con las cuales se pueden utilizar, tengan una popularidad asociada a estas.md)|01:45|06:22|\n|[Hay lenguajes de programaci√≥n que se vuelven populares por la exclusividad en una plataforma popular](NOTES/Hay lenguajes de programaci√≥n que se vuelven populares por la exclusividad en una plataforma popular.md)|06:22|10:22|\n|[Los lenguajes de programaci√≥n que permiten una adopci√≥n r√°pida (familiaridad), reutilizaci√≥n de c√≥digo existente (f√°cil migraci√≥n) y dan beneficios, se vuelven populares](NOTES/Los lenguajes de programaci√≥n que permiten una adopci√≥n r√°pida \\(familiaridad\\), reutilizaci√≥n de c√≥digo existente \\(f√°cil migraci√≥n\\) y dan beneficios, se vuelven populares.md)|10:22|13:14|\n|[El marketing puede hacer a un lenguaje popular o conocido](NOTES/El marketing puede hacer a un lenguaje popular o conocido.md)|13:14|16:15|\n|[El mercado laboral es un factor para decidir usar un lenguaje de programaci√≥n](NOTES/El mercado laboral es un factor para decidir usar un lenguaje de programaci√≥n.md)|17:46|18:46|\n|[Las comunidades de un lenguaje de programaci√≥n pueden influir para cambiar o empezar a usar un lenguaje de programaci√≥n](NOTES/Las comunidades de un lenguaje de programaci√≥n pueden influir para cambiar o empezar a usar un lenguaje de programaci√≥n.md)|17:46|18:46|\n|[La elecci√≥n de un lenguaje de programaci√≥n en ciertos contextos puede estar determinado por su rendimiento](NOTES/La elecci√≥n de un lenguaje de programaci√≥n en ciertos contextos puede estar determinado por su rendimiento.md)|17:46|18:46|\n```"},{"type":"text","text":"puedes mejorar la redacci√≥n?"}]}]},"responses":[{"timestamp":1753472609810,"id":"chatcmpl-BxIc4PLfu6qSTabJWQmzht7g7TIks","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, aqu√≠ tienes una versi√≥n mejorada y m√°s fluida del texto:\n\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Asociados a una aplicaci√≥n o framework revolucionario\nUn lenguaje se vuelve popular cuando est√° ligado a una aplicaci√≥n o framework que resuelve un problema significativo o satisface una gran demanda. La trayectoria de estos proyectos queda estrechamente vinculada con el lenguaje, ya que este ofrece la forma m√°s r√°pida, sencilla o, en su momento, la √∫nica manera viable de utilizarlos. No se trata de que el lenguaje sea inherentemente superior o m√°s atractivo, sino de que act√∫a como la puerta de entrada a algo que los usuarios _realmente_ necesitan o desean.  \nEjemplos claros incluyen:\n* VisiCalc para Apple II  \n* Ruby on Rails para Ruby  \n* PHP para HTML din√°mico, WordPress y Drupal  \n* C para programaci√≥n de sistemas  \n\n## Exclusividad en plataformas dominantes\nUn lenguaje puede convertirse en la **opci√≥n preferida o incluso la √∫nica viable para desarrollar dentro de un ecosistema de software o hardware muy grande y dominante**. La magnitud de la plataforma es suficiente para catapultar su popularidad, **sin importar su dise√±o intr√≠nseco** (funcional, imperativo u orientado a objetos).  \nEsto se refleja en casos como:  \n* Objective-C y Swift para Apple, cuya escala de plataforma garantiza su uso masivo  \n* JavaScript para la web, que se convirti√≥ en el est√°ndar de facto  \n* C# para Windows, impulsado por la exclusividad de las herramientas Microsoft en su plataforma  \n\n## Facilidad de adopci√≥n r√°pida y reutilizaci√≥n del c√≥digo existente\nAlgunos lenguajes se crearon para atraer comunidades ofreciendo una transici√≥n sencilla, permitiendo reutilizar c√≥digo existente y evitar reescrituras completas, argumentando que la migraci√≥n conlleva beneficios sustanciales. En resumen, estos lenguajes aprovechan la familiaridad del desarrollador (reduciendo el coste de aprendizaje) y eliminan barreras de entrada.  \n\nEjemplos destacados:  \n* **CoffeeScript**:   \n  - Su lema era \"es solo JavaScript\".  \n  - Promet√≠a que un programador JavaScript pod√≠a aprenderlo en **aproximadamente media hora**.  \n  - Dispon√≠a de scripts para **convertir autom√°ticamente** c√≥digo JavaScript a CoffeeScript, minimizando el esfuerzo de migraci√≥n y reforzando la idea de que \"solo\" era JavaScript.  \n  - Esto le vali√≥ llegar a ser el 11¬∫ lenguaje m√°s popular en GitHub en su apogeo.  \n* **TypeScript**:  \n  - Es un **superconjunto estricto de JavaScript**, lo que implica que cualquier c√≥digo JavaScript v√°lido es tambi√©n c√≥digo TypeScript.  \n  - La migraci√≥n puede ser tan simple como renombrar un archivo `.js` a `.ts`, esperando que \"simplemente funcione\". Luego, los desarrolladores pueden a√±adir funcionalidades TypeScript de forma incremental.  \n  - Proporciona beneficios como el tipado est√°tico con un costo percibido m√≠nimo, facilitando su adopci√≥n masiva.  \n* **C++**:  \n  - Fue uno de los primeros √©xitos de esta estrategia.  \n  - Es un \"casi superconjunto\" de C, permitiendo renombrar archivos `.c` a `.cpp` para acceder a las ventajas de C++ sin empezar desde cero.  \n* **Kotlin**:  \n  - Aunque significativamente diferente a Java, hace √©nfasis en su **compatibilidad total con las bases de c√≥digo Java existentes** y en la disponibilidad de herramientas para convertir c√≥digo Java a Kotlin.  \n  - Esto reduce el esfuerzo y riesgo de migraci√≥n para empresas y desarrolladores, contribuyendo a su amplio √©xito.  \n\n## Marketing\nAlgunos lenguajes deben su popularidad a fuertes inversiones en marketing. Por ejemplo, Sun Microsystems destin√≥ **500 millones de d√≥lares** para una campa√±a exclusivamente enfocada en Java, logrando una amplia visibilidad y reconocimiento entre desarrolladores.  \nJavaScript, por su parte, aprovech√≥ la popularidad de Java; aunque inicialmente estaba basado en un Lisp funcional influenciado por Scheme, se vio obligado a adoptar una sintaxis y enfoque orientado a objetos similares a Java. Incluso su nombre incluye \"Java\" para aprovechar ese renombre.\n\n## Factores secundarios\n* **Mercado laboral**  \n  Los desarrolladores dudan en aprender un lenguaje sin demanda laboral, y los empleadores se resisten a adoptarlo si no encuentran talento capacitado. Esto **refuerza la popularidad de lenguajes dominantes**, al validar su aprendizaje por su alta demanda y asegurar la oferta de desarrolladores.  \n* **Comunidad**  \n  Una comunidad activa y acogedora puede ser clave para atraer y retener desarrolladores, adem√°s de promover el uso del lenguaje. Python es un buen ejemplo, con una amplia comunidad que ha desarrollado herramientas para pr√°cticamente cualquier caso de uso, destacando en √°reas como inteligencia artificial.  \n* **Rendimiento**  \n  Aunque importante en ciertos √°mbitos, como la programaci√≥n de sistemas donde el control de memoria es cr√≠tico, el rendimiento suele ser un factor secundario en la popularidad general. Lenguajes como Python resultan \"suficientemente r√°pidos\" para muchas aplicaciones, donde el verdadero cuello de botella est√° en la red o la base de datos, no en el lenguaje en s√≠.  \n\n```\n\nSi quieres, tambi√©n puedo ayudarte a mejorar la redacci√≥n de las notas o del archivo YAML. ¬øQuieres que lo haga?"}}],"usage":{},"raw":{"id":"chatcmpl-BxIc4PLfu6qSTabJWQmzht7g7TIks","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, aqu√≠ tienes una versi√≥n mejorada y m√°s fluida del texto:\n\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Asociados a una aplicaci√≥n o framework revolucionario\nUn lenguaje se vuelve popular cuando est√° ligado a una aplicaci√≥n o framework que resuelve un problema significativo o satisface una gran demanda. La trayectoria de estos proyectos queda estrechamente vinculada con el lenguaje, ya que este ofrece la forma m√°s r√°pida, sencilla o, en su momento, la √∫nica manera viable de utilizarlos. No se trata de que el lenguaje sea inherentemente superior o m√°s atractivo, sino de que act√∫a como la puerta de entrada a algo que los usuarios _realmente_ necesitan o desean.  \nEjemplos claros incluyen:\n* VisiCalc para Apple II  \n* Ruby on Rails para Ruby  \n* PHP para HTML din√°mico, WordPress y Drupal  \n* C para programaci√≥n de sistemas  \n\n## Exclusividad en plataformas dominantes\nUn lenguaje puede convertirse en la **opci√≥n preferida o incluso la √∫nica viable para desarrollar dentro de un ecosistema de software o hardware muy grande y dominante**. La magnitud de la plataforma es suficiente para catapultar su popularidad, **sin importar su dise√±o intr√≠nseco** (funcional, imperativo u orientado a objetos).  \nEsto se refleja en casos como:  \n* Objective-C y Swift para Apple, cuya escala de plataforma garantiza su uso masivo  \n* JavaScript para la web, que se convirti√≥ en el est√°ndar de facto  \n* C# para Windows, impulsado por la exclusividad de las herramientas Microsoft en su plataforma  \n\n## Facilidad de adopci√≥n r√°pida y reutilizaci√≥n del c√≥digo existente\nAlgunos lenguajes se crearon para atraer comunidades ofreciendo una transici√≥n sencilla, permitiendo reutilizar c√≥digo existente y evitar reescrituras completas, argumentando que la migraci√≥n conlleva beneficios sustanciales. En resumen, estos lenguajes aprovechan la familiaridad del desarrollador (reduciendo el coste de aprendizaje) y eliminan barreras de entrada.  \n\nEjemplos destacados:  \n* **CoffeeScript**:   \n  - Su lema era \"es solo JavaScript\".  \n  - Promet√≠a que un programador JavaScript pod√≠a aprenderlo en **aproximadamente media hora**.  \n  - Dispon√≠a de scripts para **convertir autom√°ticamente** c√≥digo JavaScript a CoffeeScript, minimizando el esfuerzo de migraci√≥n y reforzando la idea de que \"solo\" era JavaScript.  \n  - Esto le vali√≥ llegar a ser el 11¬∫ lenguaje m√°s popular en GitHub en su apogeo.  \n* **TypeScript**:  \n  - Es un **superconjunto estricto de JavaScript**, lo que implica que cualquier c√≥digo JavaScript v√°lido es tambi√©n c√≥digo TypeScript.  \n  - La migraci√≥n puede ser tan simple como renombrar un archivo `.js` a `.ts`, esperando que \"simplemente funcione\". Luego, los desarrolladores pueden a√±adir funcionalidades TypeScript de forma incremental.  \n  - Proporciona beneficios como el tipado est√°tico con un costo percibido m√≠nimo, facilitando su adopci√≥n masiva.  \n* **C++**:  \n  - Fue uno de los primeros √©xitos de esta estrategia.  \n  - Es un \"casi superconjunto\" de C, permitiendo renombrar archivos `.c` a `.cpp` para acceder a las ventajas de C++ sin empezar desde cero.  \n* **Kotlin**:  \n  - Aunque significativamente diferente a Java, hace √©nfasis en su **compatibilidad total con las bases de c√≥digo Java existentes** y en la disponibilidad de herramientas para convertir c√≥digo Java a Kotlin.  \n  - Esto reduce el esfuerzo y riesgo de migraci√≥n para empresas y desarrolladores, contribuyendo a su amplio √©xito.  \n\n## Marketing\nAlgunos lenguajes deben su popularidad a fuertes inversiones en marketing. Por ejemplo, Sun Microsystems destin√≥ **500 millones de d√≥lares** para una campa√±a exclusivamente enfocada en Java, logrando una amplia visibilidad y reconocimiento entre desarrolladores.  \nJavaScript, por su parte, aprovech√≥ la popularidad de Java; aunque inicialmente estaba basado en un Lisp funcional influenciado por Scheme, se vio obligado a adoptar una sintaxis y enfoque orientado a objetos similares a Java. Incluso su nombre incluye \"Java\" para aprovechar ese renombre.\n\n## Factores secundarios\n* **Mercado laboral**  \n  Los desarrolladores dudan en aprender un lenguaje sin demanda laboral, y los empleadores se resisten a adoptarlo si no encuentran talento capacitado. Esto **refuerza la popularidad de lenguajes dominantes**, al validar su aprendizaje por su alta demanda y asegurar la oferta de desarrolladores.  \n* **Comunidad**  \n  Una comunidad activa y acogedora puede ser clave para atraer y retener desarrolladores, adem√°s de promover el uso del lenguaje. Python es un buen ejemplo, con una amplia comunidad que ha desarrollado herramientas para pr√°cticamente cualquier caso de uso, destacando en √°reas como inteligencia artificial.  \n* **Rendimiento**  \n  Aunque importante en ciertos √°mbitos, como la programaci√≥n de sistemas donde el control de memoria es cr√≠tico, el rendimiento suele ser un factor secundario en la popularidad general. Lenguajes como Python resultan \"suficientemente r√°pidos\" para muchas aplicaciones, donde el verdadero cuello de botella est√° en la red o la base de datos, no en el lenguaje en s√≠.  \n\n```\n\nSi quieres, tambi√©n puedo ayudarte a mejorar la redacci√≥n de las notas o del archivo YAML. ¬øQuieres que lo haga?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1753472583163-1753472583163","thread_key":"Untitled Chat 1753472583163","stream":true,"context_key":"1753472583163","class_name":"SmartCompletion","user_message":"puedes mejorar la redacci√≥n?","new_user_message":true},
"smart_completions:Untitled Chat 1753473204102-1753473204102": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"genera una conclusi√≥n"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îî‚îÄ‚îÄ Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md\n\nNOTES/Razones por las cu√°les los lenguajes de programaci√≥n se vuelven populares.md\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Construyeron o se asocian a una aplicaci√≥n/framework revolucionario\nEstos lenguajes se vuelven populares porque esas aplicaciones resuelve un problema significativo y/o satisface una gran demanda. Por tanto, la trayectoria de estas aplicaciones y estas applicaciones/frameworks queda ligada porque el lenguaje ofrece la forma m√°s r√°pida, f√°cil o, en su momento, la √∫nica viable para utilizar la aplicaci√≥n deseada. No se trata de que el lenguaje sea inherentemente superior o m√°s atractivo, sino de que es la puerta de entrada a algo que los usuarios _realmente_ necesitan o quieren.\nEjemplos de lo anterior son:\n* VisiCalc para el Apple II\n* Ruby on Rails para Ruby\n* PHP para HTML din√°mico, WordPress y Drupal\n* C para la programaci√≥n de sistemas:*\n## Tienen exclusividad de plataforma\nUn lenguaje se convierte en la **forma preferida o, a menudo, la √∫nica viable para desarrollar en un ecosistema de software o hardware muy grande y dominante**. La inmensidad de la plataforma en s√≠ misma es suficiente para impulsar el lenguaje a la cima, **independientemente de su dise√±o intr√≠nseco** (ya sea funcional, imperativo, o orientado a objetos).\nPodemos ver esto manifestado con\n* Objective-C y Swift para Apple, la pura escala de la plataforma Apple garantiza su popularidad\n* JavaScript para la web: Se convirti√≥ en el est√°ndar de facto.\n* C# para Microsoft Windows:  Su √©xito se debi√≥ a la exclusividad de las herramientas de Microsoft en su plataforma.\n## Dan facilidad de una adopci√≥n r√°pida y/o reutilizaci√≥n de c√≥digo existente\nHay lenguajes que se han creado con vistas a atraer o ofrecer a comunidades una alternativa su lenguaje actual de una manera que sea f√°cil y/o tambi√©n que les permita no tener que hacer una reescritura de sus proyectos. Todo con el argumento de que al hacer la migraci√≥n tendr√°n grandes beneficios. En resumen, estos lenguajes tratan de aprovechar la familiaridad del desarrollador (reducci√≥n del coste de aprendizaje) y reducir las barreras de entrada.\nVeamos c√≥mo algunos lenguajes exitosos han utilizado esta estrategia:\n‚Ä¢ **CoffeeScript**: Uno de los primeros lenguajes en prosperar con esta filosof√≠a.\n¬†¬†¬†* Su eslogan era \"es solo JavaScript\".\n¬†¬†¬†* Promet√≠a que, si ya eras programador de JavaScript, pod√≠as aprenderlo en **aproximadamente media hora**.\n¬†¬†¬†* Ofrec√≠a scripts para **convertir autom√°ticamente** tu c√≥digo JavaScript existente a CoffeeScript, lo que minimizaba dr√°sticamente el **esfuerzo de migraci√≥n** y reforzaba la idea de que era \"solo\" JavaScript.\n¬†¬†¬†* Esto fue suficiente para impulsarlo a ser el 11¬∫ lenguaje m√°s popular en GitHub en su apogeo.\n‚Ä¢ **TypeScript**: Un ejemplo fuerte de esta estrategia.\n¬†* Es un **superconjunto estricto de JavaScript**, lo que significa que el c√≥digo JavaScript v√°lido es, por definici√≥n, tambi√©n c√≥digo TypeScript v√°lido.\n¬†* La migraci√≥n puede ser tan simple como **renombrar un archivo** **.js** **a** **.ts**, y \"se supone que simplemente funciona\". A partir de ah√≠, los desarrolladores pueden a√±adir incrementalmente las caracter√≠sticas de TypeScript.\n¬†* Ofrece **beneficios** (como el tipado est√°tico) con un **costo percibido m√≠nimo** (\"solo tienes que renombrar el archivo\"), lo que ha llevado a que mucha gente lo adopte.\n‚Ä¢ **C++**:  El primer gran √©xito de esta estrategia.\n* Era un \"casi superconjunto\" de C.\n* Permiti√≥ a los programadores de C tomar sus archivos `.c`, renombrarlos a `.cpp` y comenzar a acceder a los **beneficios adicionales** de C++. Esto facilit√≥ una transici√≥n y adopci√≥n exitosa.\n‚Ä¢ **Kotlin**: Un ejemplo moderno que, aunque es un lenguaje \"sustancialmente diferente\" de Java, capitaliza la misma idea.\n* Enfatiza su **\"interoperabilidad del 100% con las bases de c√≥digo Java existentes\"** y la disponibilidad de scripts para **convertir Java a Kotlin**.\n* Esto reduce el **esfuerzo de migraci√≥n** y el riesgo percibido para las empresas y desarrolladores con grandes bases de c√≥digo Java, contribuyendo a su gran √©xito.\n## Marketing\nHay lenguajes donde hubo detr√°s inversiones monetarias masivas como en el caso de Java por parte de Sun Microsystems invirti√≥ **500 millones de d√≥lares en una nueva campa√±a de marketing solo para Java**. Con ello obtuvo una omnipresencia en diversos medios que hicieron que fuera un elemento muy reconocible por parte de las personas que desarrollan.\nPor otro lado, JavaScript es el resultado de aprovechar la ola de popularidad de Java. originalmente concebido como un Lisp funcional basado en Scheme, fue forzado por Mozilla a adoptar una sintaxis y un enfoque orientado a objetos similares a Java**. Incluso su nombre contiene \"Java\"...\n## Otros factores secundarios\n‚Ä¢ **Mercado Laboral**\n\tlos desarrolladores dudan en aprender un lenguaje si no hay trabajos disponibles que lo requieran, y los empleadores dudan en adoptar un lenguaje si no pueden encontrar desarrolladores para √©l. Este **refuerza la popularidad de los lenguajes que ya son dominantes**, ya que el gran volumen de trabajos existentes valida su aprendizaje, y la oferta de desarrolladores refuerza su uso por parte de las empresas.\n‚Ä¢ **Comunidad**\n\tLa comunidad alrededor de un lenguaje puede ser un activo importante o un pasivo. Una comunidad acogedora y colaborativa puede atraer y retener a desarrolladores. Adem√°s, de lo que genera la comunidad. Un ejemplo de esto √∫ltimo es Python con diferentes √°mbitos donde la comunidad tiene casi que una tool para cada caso de uso. Y donde m√°s ha explotado es en el √°mbito de la inteligencia artificial.\n‚Ä¢ **Rendimiento**\n\tSe considera una **preocupaci√≥n secundaria** que influye m√°s en los **dominios de uso** de un lenguaje que en su popularidad general. Para ciertas aplicaciones, como la **programaci√≥n de sistemas** (sistemas operativos, utilidades de bajo nivel), es **cr√≠tico tener control sobre la memoria**, lo que favorece lenguajes como C, C++ y, m√°s recientemente, Rust. Sin embargo, para una vasta cantidad de dominios, el rendimiento absoluto no es el factor decisivo. Python, por ejemplo, es un lenguaje \"perfectamente aceptable\" para servidores de backend, incluso si no es el m√°s r√°pido, porque el rendimiento suele estar limitado por factores externos como la red o la base de datos.\n```"},{"type":"text","text":"genera una conclusi√≥n"}]}]},"responses":[{"timestamp":1753473218017,"id":"chatcmpl-BxIlzIcxTaX6VdlteUlPVR5EmqudC","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"En conclusi√≥n, la popularidad de los lenguajes de programaci√≥n no depende exclusivamente de sus caracter√≠sticas t√©cnicas o su superioridad inherente, sino que est√° fuertemente influenciada por factores externos como la asociaci√≥n con aplicaciones o frameworks revolucionarios, la exclusividad en plataformas dominantes, y la facilidad para la adopci√≥n r√°pida y reutilizaci√≥n de c√≥digo existente. Adem√°s, el marketing estrat√©gico, el mercado laboral, y la comunidad de desarrolladores juegan un papel fundamental en consolidar y mantener su relevancia. Aunque el rendimiento es un aspecto importante en ciertos dominios espec√≠ficos, en la mayor√≠a de los casos no es el factor decisivo para la popularidad general. Por tanto, la adopci√≥n de un lenguaje suele ser un equilibrio entre necesidades pr√°cticas, ecosistemas y estrategias sociales y comerciales."}}],"usage":{},"raw":{"id":"chatcmpl-BxIlzIcxTaX6VdlteUlPVR5EmqudC","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"En conclusi√≥n, la popularidad de los lenguajes de programaci√≥n no depende exclusivamente de sus caracter√≠sticas t√©cnicas o su superioridad inherente, sino que est√° fuertemente influenciada por factores externos como la asociaci√≥n con aplicaciones o frameworks revolucionarios, la exclusividad en plataformas dominantes, y la facilidad para la adopci√≥n r√°pida y reutilizaci√≥n de c√≥digo existente. Adem√°s, el marketing estrat√©gico, el mercado laboral, y la comunidad de desarrolladores juegan un papel fundamental en consolidar y mantener su relevancia. Aunque el rendimiento es un aspecto importante en ciertos dominios espec√≠ficos, en la mayor√≠a de los casos no es el factor decisivo para la popularidad general. Por tanto, la adopci√≥n de un lenguaje suele ser un equilibrio entre necesidades pr√°cticas, ecosistemas y estrategias sociales y comerciales."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1753473204102-1753473204102","thread_key":"Untitled Chat 1753473204102","stream":true,"context_key":"1753473204102","class_name":"SmartCompletion","user_message":"genera una conclusi√≥n","new_user_message":true},
"smart_completions:Untitled Chat 1754602279071-1754602279072": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para dise√±ar el backend de mi actual proyecto"},{"type":"text","text":"‚îú‚îÄ‚îÄ BIBLIOGRAPHY/VIDEOS/\n‚îÇ   ‚îî‚îÄ‚îÄ Functional Desing Patterns.md\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n    ‚îú‚îÄ‚îÄ Composici√≥n con currificaci√≥n.md\n    ‚îú‚îÄ‚îÄ Composici√≥n de Types.md\n    ‚îú‚îÄ‚îÄ Functional Core, Imperative Shell Architecture.md\n    ‚îú‚îÄ‚îÄ Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n    ‚îú‚îÄ‚îÄ La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n    ‚îú‚îÄ‚îÄ La programaci√≥n orientada a objetos trata sobre manejo o gesti√≥n de dependencias.md\n    ‚îú‚îÄ‚îÄ Las pipelines al ser componibles, son extensibles.md\n    ‚îú‚îÄ‚îÄ Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ‚îú‚îÄ‚îÄ Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    ‚îú‚îÄ‚îÄ Puedes llamar funciones puras en funciones impuras, pero no lo hagas al rev√©s.md\n    ‚îú‚îÄ‚îÄ Trabajar en progromaci√≥n funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n    ‚îú‚îÄ‚îÄ Una funci√≥n es una  cosa  independiente (reusable) que no pertenece o est√° ligada a una clase.md\n    ‚îî‚îÄ‚îÄ Una funci√≥n puede ser usada como input o output de otras funciones.md\n\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el c√≥digo de domino est√° en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enf√°sis en que [[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo \"puro\"]] y [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]] y este ser√° impuro e imperativo.\nAdem√°s, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicaci√≥n en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el c√≥digo es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el c√≥digo de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\n* El c√≥digo IO no forma parte del dominio. Adem√°s, cuando se entremezclan dificulta la comprensi√≥n de la l√≥gica de negocio.\n* El c√≥digo IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El c√≥digo IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la l√≥gica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enf√°sis en que [[System Under Test (SUT)]] debe ser una unidad l√≥gica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Trabajar en progromaci√≥n funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"57.27\"\nminutoFin: FINAL\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nPor el ideal o gu√≠a b√°sica de la [[Programaci√≥n Funcional]] es crear funciones puras y por tanto funciones aisladas de sus dependencias. Y si est√°n as√≠ son testeables por definici√≥n.\n![[Pasted image 20250722021843.png]]\nen cambio con [[POO]] ocurre un [[Test-Induced damage]] porque no hay solape sino una intersecci√≥n que hace opere en un equilibrio m√°s inestable:\n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nSeg√∫n [[Scott Wlaschin]], esto no pertenece a la l√≥gica de negocio, y debe ocurrir antes de entrar en juego la l√≥gica de negocio. Esto evita realizar programaci√≥n defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el c√≥digo porque se separa operaciones de valor para el negocio de las validaciones.\n## ¬øQu√© ocurre si no hay algo v√°lido?\nSe hace skip de la l√≥gica de negocio porque se entiende que no tiene sentido procesar informaci√≥n invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situaci√≥n\n![[Pasted image 20250709232523.png]]\n```\nNOTES/La programaci√≥n orientada a objetos trata sobre manejo o gesti√≥n de dependencias.md\n```md\n---\nlibro: \"[[Practical Object-Oriented Desing (2¬∫ Edition)]]\"\ncap√≠tulo: 1-Object-Oriented Design\npaginas: \"27\"\ntags:\n  - POO\n  - Dise√±o-software\n  - Observaci√≥n\n---\n## Lo que comenta la autora sobre esto\nLa [[POO]] trabaja con objetos, estos interactuan entre s√≠ por pasos de mensaje, para ello tienen que conocer que mensajes pedir, la gesti√≥n de este \"conocimiento\" entre los objetos es la gesti√≥n de dependencias. Si estos, saben mucho entre estos ocurre que un cambio tiene mayor impacto del necesario.\n```\nNOTES/Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"29.10\"\nminutoFin: \"33.14\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nEn el [[Ejemplo -> Restaurant Booking]], [[Mark Seeman]] muestra como al escribir funciones puras para la l√≥gica de negocio (Dominio) y la capa de aplicaci√≥n (donde se adapta el modelo de negocio al exterior y viceversa)  y la parte impura para las operaciones IO. Autom√°ticamente se centra siguiendo el principio de [[Puedes llamar funciones puras en funciones impuras, pero no lo hagas al rev√©s]] a la hora de generar  hacer la composici√≥n. Esto se lleva al l√≠mite con [[Haskell]] cuando esto te lo fuerza por typing. Es decir, que si intentas romper el principio, el programa no te compilara y te forzar√° a hacerlo bien sin necesidad de estar vigilando que todo el mundo cumpla las gu√≠as\n![[Pasted image 20250722010459.png]]\n```\nNOTES/La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"9.12\"\nminutoFin: \"12.32\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nPrimero hay un esfuerzo importante que hacer para explicar a un equipo de personas que desarrollan que nunca han escuchado sobre la [[Arquitectura Hexagonal]] el por qu√© necesitamos aplicarla. Sobre todo cuando para aplicarla es necesario entender principios de dise√±o de la [[Programaci√≥n Orientada a Objetos]] como pueden ser los [[Principios SOLID]], [[Inyecci√≥n de dependencias]]... etc. Y para entenderlos con la profundidad necesaria es necesario consumir bibliograf√≠a no poco extensa.\nLuego, lo m√°s complicado es mantener en \"orden\" o \"rectitud\" la aplicaci√≥n de todos esos principios en armon√≠a para que se cumpla la arquitectura. Esto se debe a que esto puede ser \"derrumbado\" ante cada modificaci√≥n o extensi√≥n del sistema (perturbaciones). Por ejemplo, si por urgencia se decide saltar alguna de las capas para que el Dominio tenga \"acceso\" a Infrastructura, nada lo impide y posiblemente sea algo que genere intereses negativos como [[Deuda T√©cnica]] y sino se ataja mayor es el inter√©s (tiempo a invertir) a pagar con el paso del tiempo. En definitiva, que se pueda hacer esto quiere decir que todo ese edificio de principios y dem√°s pueden caerse porque los cimientos pueden ser quitados sin ninguna red de seguridad m√°s que la convenci√≥n\n```\nNOTES/Puedes llamar funciones puras en funciones impuras, pero no lo hagas al rev√©s.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"15.15\"\nminutoFin: \"16.50\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\n[[Mark Semman]] hace el siguiente razonamiento\n* Si compones funciones impuras, siguen siendo el resultado impuro. No pasa nada, todo es impuro\n* Si creas un funci√≥n impura donde funciones de m√°s \"bajo nivel\" son puras no pasa nada porque que sea mas o menos impura no es relevante\n* Pero si la funci√≥n de \"alto nivel\" quieres que intente ser pura pero tiene alguna de m√°s bajo nivel impura, hay un problema de dise√±o, se ha colado un [[Side-Effects]] y habr√≠a que ver la manera de empujar esa impureza fuera. Hay lenguajes como [[Haskell]] que ni si quiera compila\n```\nNOTES/Composici√≥n de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es?\nPara la composici√≥n se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento est√° separado de los datos.\nPara construir types \"m√°s grandes/complejos\" se empieza desde types m√°s simples/peque√±os por medio de:\n* Composici√≥n  con \"AND\"  (record)\n\t* es una agrupaci√≥n de types en un objeto, record, struct...\n*  Composici√≥n con \"OR\" (choice)\n\t* Es una elecci√≥n entre diferentes opciones. una forma de hacerlo es usando enums\n## ¬øPor qu√© es interesante?\nEsto permite generar una documentaci√≥n que es ejecutable. Desde la declaraci√≥n de types, su composici√≥n se puede inferir la definici√≥n de los elementos del negocio que est√°n en juego y como se relacionan. Adem√°s al ser ligero, en un mismo fichero es f√°cil de inferir todo m√°s directo\n## ¬øC√≥mo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita informaci√≥n adicional\n>Para `Paypal` se necesita un correo electr√≥nico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementaci√≥n:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```\nNOTES/Composici√≥n con currificaci√≥n.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"31.00\"\nminutoFin: \"36.35\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una t√©cnica para conectar funciones que no tienen un solo input y tienen un solo output. Esto permite aplicar la [[Gu√≠a de dise√±o de funciones para realizar composici√≥n]].\n![[Pasted image 20250716001611.png]]\nLa t√©cnica trata de generar una funci√≥n intermedia interna permita gestionar el segundo par√°metro como un input individual de esta que a su vez da un output individual, una especie de adaptaci√≥n para conectar con nuevas funciones.\n## Ejemplo\n![[Pasted image 20250716002738.png]]\n![[Pasted image 20250716001854.png]]\n![[Pasted image 20250716002002.png]]\n```\nNOTES/Una funci√≥n puede ser usada como input o output de otras funciones.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.42\"\nminutoFin: \"10.15\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una funci√≥n es una  cosa  independiente (reusable) que no pertenece o est√° ligada a una clase.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.12\"\nminutoFin: \"8.42\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Las pipelines al ser componibles, son extensibles.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"38.25\"\nminutoFin: \"39.00\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nA√±adir funcionalidad adicional no requiere modificar el c√≥digo existente, basta con a√±adir nuevos segmentos.\n![[Pasted image 20250716003633.png]]\n```\nBIBLIOGRAPHY/VIDEOS/Functional Desing Patterns.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=ucnWLfBA1dc&t=598s\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: DevTernity Conference 2018\n```\n|File0|minutoInicio|minutoFin|\n|---|---|---|\nDataview: No results to show for table query.\n```"},{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para dise√±ar el backend de mi actual proyecto"}]}],"tools":[{"type":"function","function":{"name":"lookup_context","description":"Common, frequently used. Performs a semantic search of the user's data. Use to respond to 'Based on my notes...' or any other query that might require surfacing unspecified content. Minimum 3 hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. Each hypothetical is a semantic representation of content that's likely relevant to the user's request. Hypothetical notes always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3.","parameters":{"type":"object","properties":{"hypothetical_1":{"type":"string","description":"Always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3."},"hypothetical_2":{"type":"string","description":"Must be distinct from and not share any breadcrumbs with hypothetical_1."},"hypothetical_3":{"type":"string","description":"Must be distinct from hypothetical_1 and hypothetical_2."},"in_folder":{"type":"string","description":"Optional. Only use if requested by the user. Limit the lookup to items in this folder."}},"required":["hypothetical_1","hypothetical_2"]}}}],"tool_choice":{"type":"function","function":{"name":"lookup_context"}}},"responses":[{"timestamp":1754602459060,"id":"chatcmpl-C22Xa1P23XZb9qm2Qa2lTDYM1DH1q","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"","tool_calls":[{"id":"call_KrOYTM3rvw32f90QqWWHVc7q","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"DOCUMENTO BASE > Dise√±o Backend: Ideas principales desde arquitectura funcional y patterns.md\",\"hypothetical_2\":\"DOCUMENTO BASE > Resumen y s√≠ntesis de conceptos de arquitectura y programaci√≥n funcional.md\",\"hypothetical_3\":\"DOCUMENTO BASE > Gu√≠a coherente para dise√±o de backend usando arquitectura funcional.md\"}"}}]}}],"usage":{},"raw":{"id":"chatcmpl-C22Xa1P23XZb9qm2Qa2lTDYM1DH1q","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"","tool_calls":[{"id":"call_KrOYTM3rvw32f90QqWWHVc7q","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"DOCUMENTO BASE > Dise√±o Backend: Ideas principales desde arquitectura funcional y patterns.md\",\"hypothetical_2\":\"DOCUMENTO BASE > Resumen y s√≠ntesis de conceptos de arquitectura y programaci√≥n funcional.md\",\"hypothetical_3\":\"DOCUMENTO BASE > Gu√≠a coherente para dise√±o de backend usando arquitectura funcional.md\"}"}}]}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1754602279071-1754602279072","thread_key":"Untitled Chat 1754602279071","stream":true,"context_key":"1754602279072","class_name":"SmartCompletion","user_message":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para dise√±ar el backend de mi actual proyecto","new_user_message":true,"action_key":"lookup_context","actions":{"lookup_context":"1754602459847"}},
"smart_completions:Untitled Chat 1754602279071-1754602459851": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para dise√±ar el backend de mi actual proyecto"},{"type":"text","text":"‚îú‚îÄ‚îÄ BIBLIOGRAPHY/VIDEOS/\n‚îÇ   ‚îî‚îÄ‚îÄ Functional Desing Patterns.md\n‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n    ‚îú‚îÄ‚îÄ Composici√≥n con currificaci√≥n.md\n    ‚îú‚îÄ‚îÄ Composici√≥n de Types.md\n    ‚îú‚îÄ‚îÄ Functional Core, Imperative Shell Architecture.md\n    ‚îú‚îÄ‚îÄ Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n    ‚îú‚îÄ‚îÄ La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n    ‚îú‚îÄ‚îÄ La programaci√≥n orientada a objetos trata sobre manejo o gesti√≥n de dependencias.md\n    ‚îú‚îÄ‚îÄ Las pipelines al ser componibles, son extensibles.md\n    ‚îú‚îÄ‚îÄ Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ‚îú‚îÄ‚îÄ Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    ‚îú‚îÄ‚îÄ Puedes llamar funciones puras en funciones impuras, pero no lo hagas al rev√©s.md\n    ‚îú‚îÄ‚îÄ Trabajar en progromaci√≥n funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n    ‚îú‚îÄ‚îÄ Una funci√≥n es una  cosa  independiente (reusable) que no pertenece o est√° ligada a una clase.md\n    ‚îî‚îÄ‚îÄ Una funci√≥n puede ser usada como input o output de otras funciones.md\n\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el c√≥digo de domino est√° en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enf√°sis en que [[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo \"puro\"]] y [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]] y este ser√° impuro e imperativo.\nAdem√°s, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicaci√≥n en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el c√≥digo es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el c√≥digo de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\n* El c√≥digo IO no forma parte del dominio. Adem√°s, cuando se entremezclan dificulta la comprensi√≥n de la l√≥gica de negocio.\n* El c√≥digo IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El c√≥digo IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la l√≥gica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enf√°sis en que [[System Under Test (SUT)]] debe ser una unidad l√≥gica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Trabajar en progromaci√≥n funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"57.27\"\nminutoFin: FINAL\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nPor el ideal o gu√≠a b√°sica de la [[Programaci√≥n Funcional]] es crear funciones puras y por tanto funciones aisladas de sus dependencias. Y si est√°n as√≠ son testeables por definici√≥n.\n![[Pasted image 20250722021843.png]]\nen cambio con [[POO]] ocurre un [[Test-Induced damage]] porque no hay solape sino una intersecci√≥n que hace opere en un equilibrio m√°s inestable:\n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nSeg√∫n [[Scott Wlaschin]], esto no pertenece a la l√≥gica de negocio, y debe ocurrir antes de entrar en juego la l√≥gica de negocio. Esto evita realizar programaci√≥n defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el c√≥digo porque se separa operaciones de valor para el negocio de las validaciones.\n## ¬øQu√© ocurre si no hay algo v√°lido?\nSe hace skip de la l√≥gica de negocio porque se entiende que no tiene sentido procesar informaci√≥n invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situaci√≥n\n![[Pasted image 20250709232523.png]]\n```\nNOTES/La programaci√≥n orientada a objetos trata sobre manejo o gesti√≥n de dependencias.md\n```md\n---\nlibro: \"[[Practical Object-Oriented Desing (2¬∫ Edition)]]\"\ncap√≠tulo: 1-Object-Oriented Design\npaginas: \"27\"\ntags:\n  - POO\n  - Dise√±o-software\n  - Observaci√≥n\n---\n## Lo que comenta la autora sobre esto\nLa [[POO]] trabaja con objetos, estos interactuan entre s√≠ por pasos de mensaje, para ello tienen que conocer que mensajes pedir, la gesti√≥n de este \"conocimiento\" entre los objetos es la gesti√≥n de dependencias. Si estos, saben mucho entre estos ocurre que un cambio tiene mayor impacto del necesario.\n```\nNOTES/Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"29.10\"\nminutoFin: \"33.14\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nEn el [[Ejemplo -> Restaurant Booking]], [[Mark Seeman]] muestra como al escribir funciones puras para la l√≥gica de negocio (Dominio) y la capa de aplicaci√≥n (donde se adapta el modelo de negocio al exterior y viceversa)  y la parte impura para las operaciones IO. Autom√°ticamente se centra siguiendo el principio de [[Puedes llamar funciones puras en funciones impuras, pero no lo hagas al rev√©s]] a la hora de generar  hacer la composici√≥n. Esto se lleva al l√≠mite con [[Haskell]] cuando esto te lo fuerza por typing. Es decir, que si intentas romper el principio, el programa no te compilara y te forzar√° a hacerlo bien sin necesidad de estar vigilando que todo el mundo cumpla las gu√≠as\n![[Pasted image 20250722010459.png]]\n```\nNOTES/La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"9.12\"\nminutoFin: \"12.32\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nPrimero hay un esfuerzo importante que hacer para explicar a un equipo de personas que desarrollan que nunca han escuchado sobre la [[Arquitectura Hexagonal]] el por qu√© necesitamos aplicarla. Sobre todo cuando para aplicarla es necesario entender principios de dise√±o de la [[Programaci√≥n Orientada a Objetos]] como pueden ser los [[Principios SOLID]], [[Inyecci√≥n de dependencias]]... etc. Y para entenderlos con la profundidad necesaria es necesario consumir bibliograf√≠a no poco extensa.\nLuego, lo m√°s complicado es mantener en \"orden\" o \"rectitud\" la aplicaci√≥n de todos esos principios en armon√≠a para que se cumpla la arquitectura. Esto se debe a que esto puede ser \"derrumbado\" ante cada modificaci√≥n o extensi√≥n del sistema (perturbaciones). Por ejemplo, si por urgencia se decide saltar alguna de las capas para que el Dominio tenga \"acceso\" a Infrastructura, nada lo impide y posiblemente sea algo que genere intereses negativos como [[Deuda T√©cnica]] y sino se ataja mayor es el inter√©s (tiempo a invertir) a pagar con el paso del tiempo. En definitiva, que se pueda hacer esto quiere decir que todo ese edificio de principios y dem√°s pueden caerse porque los cimientos pueden ser quitados sin ninguna red de seguridad m√°s que la convenci√≥n\n```\nNOTES/Puedes llamar funciones puras en funciones impuras, pero no lo hagas al rev√©s.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"15.15\"\nminutoFin: \"16.50\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\n[[Mark Semman]] hace el siguiente razonamiento\n* Si compones funciones impuras, siguen siendo el resultado impuro. No pasa nada, todo es impuro\n* Si creas un funci√≥n impura donde funciones de m√°s \"bajo nivel\" son puras no pasa nada porque que sea mas o menos impura no es relevante\n* Pero si la funci√≥n de \"alto nivel\" quieres que intente ser pura pero tiene alguna de m√°s bajo nivel impura, hay un problema de dise√±o, se ha colado un [[Side-Effects]] y habr√≠a que ver la manera de empujar esa impureza fuera. Hay lenguajes como [[Haskell]] que ni si quiera compila\n```\nNOTES/Composici√≥n de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øC√≥mo es?\nPara la composici√≥n se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento est√° separado de los datos.\nPara construir types \"m√°s grandes/complejos\" se empieza desde types m√°s simples/peque√±os por medio de:\n* Composici√≥n  con \"AND\"  (record)\n\t* es una agrupaci√≥n de types en un objeto, record, struct...\n*  Composici√≥n con \"OR\" (choice)\n\t* Es una elecci√≥n entre diferentes opciones. una forma de hacerlo es usando enums\n## ¬øPor qu√© es interesante?\nEsto permite generar una documentaci√≥n que es ejecutable. Desde la declaraci√≥n de types, su composici√≥n se puede inferir la definici√≥n de los elementos del negocio que est√°n en juego y como se relacionan. Adem√°s al ser ligero, en un mismo fichero es f√°cil de inferir todo m√°s directo\n## ¬øC√≥mo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita informaci√≥n adicional\n>Para `Paypal` se necesita un correo electr√≥nico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementaci√≥n:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```\nNOTES/Composici√≥n con currificaci√≥n.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"31.00\"\nminutoFin: \"36.35\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øQu√© es?\nEs una t√©cnica para conectar funciones que no tienen un solo input y tienen un solo output. Esto permite aplicar la [[Gu√≠a de dise√±o de funciones para realizar composici√≥n]].\n![[Pasted image 20250716001611.png]]\nLa t√©cnica trata de generar una funci√≥n intermedia interna permita gestionar el segundo par√°metro como un input individual de esta que a su vez da un output individual, una especie de adaptaci√≥n para conectar con nuevas funciones.\n## Ejemplo\n![[Pasted image 20250716002738.png]]\n![[Pasted image 20250716001854.png]]\n![[Pasted image 20250716002002.png]]\n```\nNOTES/Una funci√≥n puede ser usada como input o output de otras funciones.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.42\"\nminutoFin: \"10.15\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una funci√≥n es una  cosa  independiente (reusable) que no pertenece o est√° ligada a una clase.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.12\"\nminutoFin: \"8.42\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Las pipelines al ser componibles, son extensibles.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"38.25\"\nminutoFin: \"39.00\"\ntags: \nnum_veces_leida: 0\n---\n## ¬øPor qu√©?\nA√±adir funcionalidad adicional no requiere modificar el c√≥digo existente, basta con a√±adir nuevos segmentos.\n![[Pasted image 20250716003633.png]]\n```\nBIBLIOGRAPHY/VIDEOS/Functional Desing Patterns.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=ucnWLfBA1dc&t=598s\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: DevTernity Conference 2018\n```\n|File0|minutoInicio|minutoFin|\n|---|---|---|\nDataview: No results to show for table query.\n```"},{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para dise√±ar el backend de mi actual proyecto"},{"type":"text","text":"‚îî‚îÄ‚îÄ NOTES/\n    ‚îú‚îÄ‚îÄ Bases de Lean UX (Product).md##¬øCu√°les son?#Agile#{3}\n    ‚îú‚îÄ‚îÄ El dise√±o es el arte de ordenar c√≥digo.md##Lo que piensa la autora#{1}\n    ‚îú‚îÄ‚îÄ El modelaje o dise√±o de software que sea f√°cil de mantener es complicado aplicando POO.md##¬øPor qu√©?\n    ‚îú‚îÄ‚îÄ El modelaje o dise√±o de software que sea f√°cil de mantener es complicado aplicando POO.md##¬øPor qu√©?#{1}\n    ‚îú‚îÄ‚îÄ El modelaje o dise√±o de software que sea f√°cil de mantener es complicado aplicando POO.md##¬øPor qu√©?#{4}\n    ‚îú‚îÄ‚îÄ Functional Core, Imperative Shell Architecture.md##¬øQu√© es?\n    ‚îú‚îÄ‚îÄ Functional Core, Imperative Shell Architecture.md##¬øQu√© es?#{1}\n    ‚îú‚îÄ‚îÄ RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\n    ‚îú‚îÄ‚îÄ RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema#{1}\n    ‚îî‚îÄ‚îÄ Testing sobre bases de datos (1).md##Mi opini√≥n#{1}\n\nNOTES/Testing sobre bases de datos (1).md##Mi opini√≥n#{1}\n```md##Mi opini√≥n#{1}\nCiertamente, es algo que pr√°ctico creo desde el punto de vista de [[DDD no depende de una arquitectura o patr√≥n de arquitectura concreto, la elecci√≥n de estas deben estar orientadas solo a satisface los requerimientos de calidad de software y estas no pueden ser determinadas sin los requisitos funcionales]] con el patr√≥n repository (siendo el \"sinonimo\" de Gateway). A mi sinceramente me gusta m√°s crear una implementaci√≥n de [[Fake Object]] testeado y que este sea utilizado en las pruebas de negocio. Pero concuerdo con la separaci√≥n y testear de que ese elemento descoplante est√© haciendo esa traducci√≥n entre objetos de dominio y queries o commandos hacia base de datos\n```\nNOTES/Functional Core, Imperative Shell Architecture.md##¬øQu√© es?#{1}\n```md##¬øQu√© es?#{1}\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el c√≥digo de domino est√° en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enf√°sis en que [[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo \"puro\"]] y [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]] y este ser√° impuro e imperativo.\nAdem√°s, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicaci√≥n en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el c√≥digo es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el c√≥digo de domino puro logramos:\n```\nNOTES/RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\n```md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\n#### Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\nEsto se considera un enfoque cl√°sico, ya que considera la interfaz del sistema como un todo cohesivo que simplemente se expone  utilizando abstracciones  de recursos en lugar de servicios  o interfaces remotas\n```\nNOTES/Functional Core, Imperative Shell Architecture.md##¬øQu√© es?\n```md##¬øQu√© es?\n## ¬øQu√© es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el c√≥digo de domino est√° en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enf√°sis en que [[En la l√≥gica de dominio hay que seguir los principios de dise√±o para generar c√≥digo \"puro\"]] y [[Hay mantener el c√≥digo IO alejado de la l√≥gica de negocio]] y este ser√° impuro e imperativo.\nAdem√°s, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicaci√≥n en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el c√≥digo es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el c√≥digo de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema#{1}\n```md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema#{1}\nEsto se considera un enfoque cl√°sico, ya que considera la interfaz del sistema como un todo cohesivo que simplemente se expone  utilizando abstracciones  de recursos en lugar de servicios  o interfaces remotas\n```\nNOTES/El modelaje o dise√±o de software que sea f√°cil de mantener es complicado aplicando POO.md##¬øPor qu√©?#{1}\n```md##¬øPor qu√©?#{1}\nEl principio fundamental de la [[POO]] es la encapsulaci√≥n que significa que pocas palabras: Agrupar en objetos datos y comportamiento y no exponer los datos sino operaciones sobre estos con m√©todos ([[Tell, Don`t ask]]). Esto ha hecho que aparecieran antipatrones como [[Active Record]] donde operaciones sobre entidades de tipo persistencia se encapsularan sobre objetos de tipo X.\nLuego, [[Eric Evans]] escribi√≥ un libro sobre [[Domain Driving Desing]] donde explica patrones de dise√±o para hacer m√°s f√°cil mantener software separando objetos en dos categor√≠as:\n```\nNOTES/El modelaje o dise√±o de software que sea f√°cil de mantener es complicado aplicando POO.md##¬øPor qu√©?\n```md##¬øPor qu√©?\n## ¬øPor qu√©?\nEl principio fundamental de la [[POO]] es la encapsulaci√≥n que significa que pocas palabras: Agrupar en objetos datos y comportamiento y no exponer los datos sino operaciones sobre estos con m√©todos ([[Tell, Don`t ask]]). Esto ha hecho que aparecieran antipatrones como [[Active Record]] donde operaciones sobre entidades de tipo persistencia se encapsularan sobre objetos de tipo X.\nLuego, [[Eric Evans]] escribi√≥ un libro sobre [[Domain Driving Desing]] donde explica patrones de dise√±o para hacer m√°s f√°cil mantener software separando objetos en dos categor√≠as:\n* Entidades y value objects\n* Servicios\nEn los values objects son elementos que carecen de comportamiento y solo encapsulan conjuntos de datos para dar sentido a dominio cuando est√°n bajo una entidad (elemento importante en el dominio sobre el cual existe un ciclo de vida) y los servicios son los elementos que operan con estos conjuntos de datos.\nDe la manera que [[Eric Evans]], bajo la experiencia de [[Mark Seeman]] se genera un c√≥digo que tiene √©xito porque se mantiene con el tiempo bien. Sin embargo, al igual que pasa que [[La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla]],  esto requiere de mucho esfuerzo para entender por qu√© esto genera un software m√°s f√°cil de mantener, c√≥mo aplicar los patrones de dise√±o y lo m√°s complicado que todas las personas mantengan el mismo mindset.\n```\nNOTES/El dise√±o es el arte de ordenar c√≥digo.md##Lo que piensa la autora#{1}\n```md##Lo que piensa la autora#{1}\nNo se trata de anticipar  lo que cambiar√° en un software, se trata de aceptar que algo cambiar√°. Se trata de preservar las opci√≥n abiertas para acomodar esos posibles cambios. Por  tanto, reducir el coste de cambio.\n```\nNOTES/Bases de Lean UX (Product).md##¬øCu√°les son?#Agile#{3}\n```md##¬øCu√°les son?#Agile#{3}\n\t* El reto es averiguar cu√°l soluci√≥n es la m√°s viable. A veces, es dif√≠cil o imposible predecir de antemano qu√© soluci√≥n funcionar√°. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a trav√©s de software funcional) antes, el equipo puede evaluar r√°pidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboraci√≥n con el cliente sobre negociaci√≥n contractual**\n\t* Colaborar con tus compa√±eros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n```\nNOTES/El modelaje o dise√±o de software que sea f√°cil de mantener es complicado aplicando POO.md##¬øPor qu√©?#{4}\n```md##¬øPor qu√©?#{4}\nEn los values objects son elementos que carecen de comportamiento y solo encapsulan conjuntos de datos para dar sentido a dominio cuando est√°n bajo una entidad (elemento importante en el dominio sobre el cual existe un ciclo de vida) y los servicios son los elementos que operan con estos conjuntos de datos.\nDe la manera que [[Eric Evans]], bajo la experiencia de [[Mark Seeman]] se genera un c√≥digo que tiene √©xito porque se mantiene con el tiempo bien. Sin embargo, al igual que pasa que [[La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla]],  esto requiere de mucho esfuerzo para entender por qu√© esto genera un software m√°s f√°cil de mantener, c√≥mo aplicar los patrones de dise√±o y lo m√°s complicado que todas las personas mantengan el mismo mindset.\n```"}]},{"role":"assistant","content":""}]},"responses":[{"timestamp":1754602572809,"id":"chatcmpl-C22Z2xLH6vCXH4q44verGRKjjaMb7","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, aqu√≠ tienes un documento coherente que integra y articula las ideas clave extra√≠das de tus notas y referencias para explicar el dise√±o del backend de tu proyecto, desde una perspectiva funcional y arquitect√≥nica, comparando enfoques y destacando buenas pr√°cticas:\n\n---\n\n# Dise√±o del Backend basado en Arquitectura Funcional y Principios del Core Funcional\n\n## Introducci√≥n\n\nEl dise√±o del backend de este proyecto se ha basado en un conjunto de ideas extra√≠das principalmente de la arquitectura funcional y el patr√≥n **Functional Core, Imperative Shell**, as√≠ como en conceptos de arquitectura hexagonal o puertos y adaptadores. A continuaci√≥n, se presenta una s√≠ntesis estructurada de estos conceptos, con especial √©nfasis en la separaci√≥n de responsabilidades, la gesti√≥n de dependencias y la testabilidad.\n\n---\n\n## 1. Separaci√≥n clara entre l√≥gica de negocio y efectos secundarios (IO)\n\n### 1.1 Functional Core - Imperative Shell\n\nEste patr√≥n arquitect√≥nico sit√∫a el c√≥digo de dominio en el centro del sistema, el cual debe estar escrito como funciones **puras**, siguiendo principios de dise√±o funcional. Alrededor de este n√∫cleo se encuentra una \"c√°scara\" imperativa que maneja todas las operaciones con efectos secundarios o entrada/salida (IO).\n\n**Beneficios clave:**\n\n- **Aislamiento de la l√≥gica de negocio:** La l√≥gica de dominio no se preocupa por la asincron√≠a ni las fallas de IO, lo que simplifica la comprensi√≥n y evoluci√≥n del c√≥digo.\n- **Facilidad en el testeo:** Al ser puras, las funciones del core son deterministas y f√°cilmente testeables con tests unitarios.\n- **Manejo expl√≠cito de efectos secundarios:** El c√≥digo IO, que es no determinista y propenso a fallos, se maneja en los bordes, donde se deben implementar mecanismos espec√≠ficos de error y validaci√≥n.\n\n---\n\n### 1.2 Mantener el c√≥digo IO alejado de la l√≥gica de negocio\n\nEl c√≥digo que realiza operaciones IO debe mantenerse fuera de la l√≥gica del dominio, porque:\n\n- Dificulta la comprensi√≥n al mezclar conceptos muy distintos.\n- Introduce no determinismo en el core, dificultando pruebas y mantenibilidad.\n- Requiere manejo de excepciones distinto al de la l√≥gica de negocio.\n\nEste aislamiento es fundamental para aplicar correctamente el patr√≥n Functional Core Imperative Shell.\n\n---\n\n## 2. Arquitectura Hexagonal (Puertos y Adaptadores)\n\nLa arquitectura hexagonal propone que el dominio (core) est√© desacoplado de las infraestructuras y tecnolog√≠as externas mediante puertos (interfaces abstractas) y adaptadores concretos que implementan esas interfaces.\n\n- Esta arquitectura es muy compatible con la arquitectura funcional, especialmente cuando los bordes contienen el c√≥digo impuro.\n- En programaci√≥n **orientada a objetos (POO)**, la implementaci√≥n de la arquitectura hexagonal demanda un gran esfuerzo para ser bien aplicada y mantenida, requiriendo un entendimiento profundo de principios como SOLID y una disciplina constante para evitar \"atajos\" que generen deuda t√©cnica.\n- En cambio, la arquitectura funcional facilita este desacoplamiento de forma m√°s natural, incluso en lenguajes que fuerzan, como Haskell, la separaci√≥n entre c√≥digo puro e impuro a nivel de tipos.\n\n---\n\n## 3. Principios de dise√±o funcional aplicados\n\n### 3.1 Composici√≥n y reutilizaci√≥n de funciones\n\n- Una funci√≥n es una entidad independiente, reusable y desacoplada de clases o estructuras de datos.\n- Puede ser usada como entrada o salida de otras funciones, facilitando la composici√≥n.\n- La currificaci√≥n es una t√©cnica para adaptar funciones con m√∫ltiples argumentos a una cadena de funciones de un solo argumento, que permite conexiones limpias y composables entre ellas.\n- Las pipelines construidas con funciones puras son extensibles, ya que agregar funcionalidad normalmente implica a√±adir nuevos segmentos sin alterar el c√≥digo existente.\n\n---\n\n### 3.2 Composici√≥n de types algebraicos para modelar dominio\n\nPara representar datos del dominio de forma clara y segura, aplicamos:\n\n- Composici√≥n con \"AND\" (records/tuplas): para agrupar datos relacionados.\n- Composici√≥n con \"OR\" (uniones / enums): para modelar elecciones o variantes.\n\nEsta t√©cnica no solo documenta de forma precisa los elementos y sus relaciones, sino que tambi√©n facilita el an√°lisis est√°tico, el mantenimiento y la evoluci√≥n del dominio, manteniendo la l√≥gica separada de la representaci√≥n.\n\n---\n\n## 4. Validaci√≥n y flujo de datos\n\n- Las validaciones deben realizarse en la frontera entre los procesos IO y el core funcional para garantizar que la l√≥gica de negocio solo reciba datos v√°lidos.\n- Esto evite la necesidad de programaci√≥n defensiva dentro del core y simplifica la l√≥gica.\n- Cuando se detectan datos no v√°lidos, se omite la ejecuci√≥n del core (skip) y se deben ejecutar procesos alternativos para manejar esos casos.\n\n---\n\n## 5. Testeo\n\n- Los **tests unitarios** se enfocan en el core funcional, donde las funciones puras permiten pruebas deterministas, simples y r√°pidas.\n- Los **tests de integraci√≥n** apuntan a validar los flujos de trabajo (workflows) completos, los cuales incluyen las operaciones de IO y la interacci√≥n entre m√∫ltiples componentes y sistemas.\n\nEste enfoque reduce la necesidad de dobles y mocks complejos en la l√≥gica de negocio y mejora la confianza en la calidad del software.\n\n---\n\n## 6. Comparaci√≥n con la Programaci√≥n Orientada a Objetos (POO)\n\n- La POO centra su pr√°ctica en la gesti√≥n de dependencias entre objetos, los cuales se comunican por mensajes.\n- Esta gesti√≥n puede ser compleja y conlleva un mayor esfuerzo para aplicar arquitecturas limpias como la hexagonal y mantener la disciplina asociada.\n- Patrones mal aplicados, como Active Record, mezclan l√≥gica de persistencia con l√≥gica de negocio, complicando el mantenimiento.\n- En la POO, los objetos pueden contener estado y comportamiento, y el acoplamiento accidental puede generar un incremento en la deuda t√©cnica con el tiempo.\n- En cambio, la programaci√≥n funcional promueve el aislamiento de dependencias mediante funciones puras, que reduce el esfuerzo en testabilidad y mantenibilidad.\n\n---\n\n## 7. Perspectiva de Lean UX y desarrollo √°gil\n\n- El dise√±o y arquitectura deben aceptar que los cambios suceder√°n, por lo que el c√≥digo debe preservar flexibilidad y minimizar el costo de cambio.\n- Validar ideas cuanto antes con clientes, es decir, entregar software funcional que permita obtener feedback r√°pido, ayuda a evaluar la viabilidad de las soluciones.\n- La colaboraci√≥n estrecha con clientes y el equipo contribuye a un entendimiento com√∫n del problema y de las soluciones.\n\n---\n\n## Conclusi√≥n\n\nEl dise√±o del backend se apoya en una arquitectura funcional que conlleva un core de funciones puras rodeado por una capa imperativa que maneja IO. Esta separaci√≥n garantiza un dominio expresivo, claro y altamente testeable.\n\nLa composici√≥n funcional, la utilizaci√≥n correcta de tipos algebraicos para el modelado, la validaci√≥n en los bordes y el uso consciente de buenas pr√°cticas para testear mejoran la calidad y mantenibilidad del proyecto.\n\nSi bien la arquitectura hexagonal y patrones de dise√±o similares son aplicables en POO, la arquitectura funcional facilita esta limpieza estructural con menor esfuerzo, a la vez que despliega un modelo mental m√°s simple y alineado con los principios de la programaci√≥n funcional.\n\n---\n\nSi quieres, puedo ayudarte a elaborar diagramas o ejemplos concretos para ilustrar cualquiera de estos puntos. ¬øQuieres continuar con eso?"}}],"usage":{},"raw":{"id":"chatcmpl-C22Z2xLH6vCXH4q44verGRKjjaMb7","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, aqu√≠ tienes un documento coherente que integra y articula las ideas clave extra√≠das de tus notas y referencias para explicar el dise√±o del backend de tu proyecto, desde una perspectiva funcional y arquitect√≥nica, comparando enfoques y destacando buenas pr√°cticas:\n\n---\n\n# Dise√±o del Backend basado en Arquitectura Funcional y Principios del Core Funcional\n\n## Introducci√≥n\n\nEl dise√±o del backend de este proyecto se ha basado en un conjunto de ideas extra√≠das principalmente de la arquitectura funcional y el patr√≥n **Functional Core, Imperative Shell**, as√≠ como en conceptos de arquitectura hexagonal o puertos y adaptadores. A continuaci√≥n, se presenta una s√≠ntesis estructurada de estos conceptos, con especial √©nfasis en la separaci√≥n de responsabilidades, la gesti√≥n de dependencias y la testabilidad.\n\n---\n\n## 1. Separaci√≥n clara entre l√≥gica de negocio y efectos secundarios (IO)\n\n### 1.1 Functional Core - Imperative Shell\n\nEste patr√≥n arquitect√≥nico sit√∫a el c√≥digo de dominio en el centro del sistema, el cual debe estar escrito como funciones **puras**, siguiendo principios de dise√±o funcional. Alrededor de este n√∫cleo se encuentra una \"c√°scara\" imperativa que maneja todas las operaciones con efectos secundarios o entrada/salida (IO).\n\n**Beneficios clave:**\n\n- **Aislamiento de la l√≥gica de negocio:** La l√≥gica de dominio no se preocupa por la asincron√≠a ni las fallas de IO, lo que simplifica la comprensi√≥n y evoluci√≥n del c√≥digo.\n- **Facilidad en el testeo:** Al ser puras, las funciones del core son deterministas y f√°cilmente testeables con tests unitarios.\n- **Manejo expl√≠cito de efectos secundarios:** El c√≥digo IO, que es no determinista y propenso a fallos, se maneja en los bordes, donde se deben implementar mecanismos espec√≠ficos de error y validaci√≥n.\n\n---\n\n### 1.2 Mantener el c√≥digo IO alejado de la l√≥gica de negocio\n\nEl c√≥digo que realiza operaciones IO debe mantenerse fuera de la l√≥gica del dominio, porque:\n\n- Dificulta la comprensi√≥n al mezclar conceptos muy distintos.\n- Introduce no determinismo en el core, dificultando pruebas y mantenibilidad.\n- Requiere manejo de excepciones distinto al de la l√≥gica de negocio.\n\nEste aislamiento es fundamental para aplicar correctamente el patr√≥n Functional Core Imperative Shell.\n\n---\n\n## 2. Arquitectura Hexagonal (Puertos y Adaptadores)\n\nLa arquitectura hexagonal propone que el dominio (core) est√© desacoplado de las infraestructuras y tecnolog√≠as externas mediante puertos (interfaces abstractas) y adaptadores concretos que implementan esas interfaces.\n\n- Esta arquitectura es muy compatible con la arquitectura funcional, especialmente cuando los bordes contienen el c√≥digo impuro.\n- En programaci√≥n **orientada a objetos (POO)**, la implementaci√≥n de la arquitectura hexagonal demanda un gran esfuerzo para ser bien aplicada y mantenida, requiriendo un entendimiento profundo de principios como SOLID y una disciplina constante para evitar \"atajos\" que generen deuda t√©cnica.\n- En cambio, la arquitectura funcional facilita este desacoplamiento de forma m√°s natural, incluso en lenguajes que fuerzan, como Haskell, la separaci√≥n entre c√≥digo puro e impuro a nivel de tipos.\n\n---\n\n## 3. Principios de dise√±o funcional aplicados\n\n### 3.1 Composici√≥n y reutilizaci√≥n de funciones\n\n- Una funci√≥n es una entidad independiente, reusable y desacoplada de clases o estructuras de datos.\n- Puede ser usada como entrada o salida de otras funciones, facilitando la composici√≥n.\n- La currificaci√≥n es una t√©cnica para adaptar funciones con m√∫ltiples argumentos a una cadena de funciones de un solo argumento, que permite conexiones limpias y composables entre ellas.\n- Las pipelines construidas con funciones puras son extensibles, ya que agregar funcionalidad normalmente implica a√±adir nuevos segmentos sin alterar el c√≥digo existente.\n\n---\n\n### 3.2 Composici√≥n de types algebraicos para modelar dominio\n\nPara representar datos del dominio de forma clara y segura, aplicamos:\n\n- Composici√≥n con \"AND\" (records/tuplas): para agrupar datos relacionados.\n- Composici√≥n con \"OR\" (uniones / enums): para modelar elecciones o variantes.\n\nEsta t√©cnica no solo documenta de forma precisa los elementos y sus relaciones, sino que tambi√©n facilita el an√°lisis est√°tico, el mantenimiento y la evoluci√≥n del dominio, manteniendo la l√≥gica separada de la representaci√≥n.\n\n---\n\n## 4. Validaci√≥n y flujo de datos\n\n- Las validaciones deben realizarse en la frontera entre los procesos IO y el core funcional para garantizar que la l√≥gica de negocio solo reciba datos v√°lidos.\n- Esto evite la necesidad de programaci√≥n defensiva dentro del core y simplifica la l√≥gica.\n- Cuando se detectan datos no v√°lidos, se omite la ejecuci√≥n del core (skip) y se deben ejecutar procesos alternativos para manejar esos casos.\n\n---\n\n## 5. Testeo\n\n- Los **tests unitarios** se enfocan en el core funcional, donde las funciones puras permiten pruebas deterministas, simples y r√°pidas.\n- Los **tests de integraci√≥n** apuntan a validar los flujos de trabajo (workflows) completos, los cuales incluyen las operaciones de IO y la interacci√≥n entre m√∫ltiples componentes y sistemas.\n\nEste enfoque reduce la necesidad de dobles y mocks complejos en la l√≥gica de negocio y mejora la confianza en la calidad del software.\n\n---\n\n## 6. Comparaci√≥n con la Programaci√≥n Orientada a Objetos (POO)\n\n- La POO centra su pr√°ctica en la gesti√≥n de dependencias entre objetos, los cuales se comunican por mensajes.\n- Esta gesti√≥n puede ser compleja y conlleva un mayor esfuerzo para aplicar arquitecturas limpias como la hexagonal y mantener la disciplina asociada.\n- Patrones mal aplicados, como Active Record, mezclan l√≥gica de persistencia con l√≥gica de negocio, complicando el mantenimiento.\n- En la POO, los objetos pueden contener estado y comportamiento, y el acoplamiento accidental puede generar un incremento en la deuda t√©cnica con el tiempo.\n- En cambio, la programaci√≥n funcional promueve el aislamiento de dependencias mediante funciones puras, que reduce el esfuerzo en testabilidad y mantenibilidad.\n\n---\n\n## 7. Perspectiva de Lean UX y desarrollo √°gil\n\n- El dise√±o y arquitectura deben aceptar que los cambios suceder√°n, por lo que el c√≥digo debe preservar flexibilidad y minimizar el costo de cambio.\n- Validar ideas cuanto antes con clientes, es decir, entregar software funcional que permita obtener feedback r√°pido, ayuda a evaluar la viabilidad de las soluciones.\n- La colaboraci√≥n estrecha con clientes y el equipo contribuye a un entendimiento com√∫n del problema y de las soluciones.\n\n---\n\n## Conclusi√≥n\n\nEl dise√±o del backend se apoya en una arquitectura funcional que conlleva un core de funciones puras rodeado por una capa imperativa que maneja IO. Esta separaci√≥n garantiza un dominio expresivo, claro y altamente testeable.\n\nLa composici√≥n funcional, la utilizaci√≥n correcta de tipos algebraicos para el modelado, la validaci√≥n en los bordes y el uso consciente de buenas pr√°cticas para testear mejoran la calidad y mantenibilidad del proyecto.\n\nSi bien la arquitectura hexagonal y patrones de dise√±o similares son aplicables en POO, la arquitectura funcional facilita esta limpieza estructural con menor esfuerzo, a la vez que despliega un modelo mental m√°s simple y alineado con los principios de la programaci√≥n funcional.\n\n---\n\nSi quieres, puedo ayudarte a elaborar diagramas o ejemplos concretos para ilustrar cualquiera de estos puntos. ¬øQuieres continuar con eso?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1754602279071-1754602459851","thread_key":"Untitled Chat 1754602279071","stream":true,"context_key":"1754602459847","class_name":"SmartCompletion"},