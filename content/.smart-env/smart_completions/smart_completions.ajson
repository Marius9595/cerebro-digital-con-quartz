
"smart_completions:Untitled Chat 1749506146201-1749506170827": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"cómo se complementan?"},{"type":"text","text":"└── NOTES/\n    ├── Análisis sintáctico de una fórmula.md\n    └── Árbol sintáctico.md\n\nNOTES/Árbol sintáctico.md\n```md\n---\nlibro: \"[[Lógica y estructuras discretas 2024-2025]]\"\ncapítulo: 1-Logica Proposicional\npaginas: Análisis sintáctico de fórmulas proposicionales\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una representación gráfica, en forma de árbol invertido, que describe cualquier sistema compuesto de bloques dentro de otros bloques. Esta representación es el cómo resultado de un [[Análisis sintáctico de una fórmula]] X.\nPara navegar en el se usa la siguiente notación:\n- _Nodo raíz y nodos hoja_: la fórmula X original es la raíz del árbol y cada una de las fórmulas atómicas inferiores es una hoja del árbol.\n- _Nodos del árbol_: cada una de las fórmulas que aparecen en ese árbol está situada en un nodo del árbol, desde el nodo raíz hasta los nodos hoja, pasando por los nodos intermedios.\n- _Ramas del árbol_: cada uno de los caminos de nodos que empieza en el nodo raíz y finaliza en un nodo hoja, inclusive ambos, se denomina rama del árbol.\n- _Subárbol_: cada nodo se puede considerar a su vez como raíz de su propio árbol. Así, el árbol sintáctico de una fórmula X=(Y∗Z) enlazaría el nodo raíz X con los respectivos árboles que tienen por raíz tanto Y como Z.\n```\nNOTES/Análisis sintáctico de una fórmula.md\n```md\n---\nlibro: \"[[Lógica y estructuras discretas 2024-2025]]\"\ncapítulo: 1-Logica Proposicional\npaginas: Análisis sintáctico de fórmulas proposicionales\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs un proceso que se aplica a una [[Fórmula Proposicional]] X. \nEsta consisten en:\n- _Descomposición de X_. Se puede determinar cuál es la última conectiva ([[Conectiva principal]]) utilizada en su producción, así como las [[Subfórmula inmediata]]s utilizadas en ese paso.\n- _Análisis de las subfórmulas inmediatas de X_. Estas subfórmulas inmediatas de X son a su vez fórmulas, susceptibles de ser analizadas de la misma manera: detectando su [[Conectiva principal]]y sus componentes inmediatas.\n- _Análisis de cada subcomponente encontrada_. Lo mismo ocurre con cada componente que se va detectando en este proceso de descomposición, a cualquier nivel: es una nueva fórmula que admite este mismo análisis.\nLa fórmula X inicial es siempre una expresión finita. Y esta propiedad garantiza que el proceso finaliza siempre. Así, este proceso acaba en todas sus líneas de análisis porque se llega necesariamente a componentes atómicas, donde se finaliza la descomposición.\nEjemplo usando un [[Árbol sintáctico]]:\n![[arbol-sintactico.excalidraw]]\n```"},{"type":"text","text":"cómo se complementan?"}]}]},"responses":[{"timestamp":1749506259238,"id":"chatcmpl-BgemdKjqjHAgWsoqDHxf0iRcK31ex","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Los dos archivos **\"Análisis sintáctico de una fórmula.md\"** y **\"Árbol sintáctico.md\"** se complementan de manera natural porque uno describe el **proceso** y el otro la **representación gráfica** del resultado de ese proceso.\n\n---\n\n### 1. ¿Cómo se complementan?\n\n- **Análisis sintáctico de una fórmula.md** explica el **proceso lógico y sistemático** por el cual se analiza una fórmula proposicional:\n  - Se identifica la **conectiva principal** de la fórmula.\n  - Se descompone en las **subfórmulas inmediatas**.\n  - Este proceso se aplica recursivamente a cada subfórmula, hasta llegar a fórmulas atómicas (sin conectivas).\n  - Garantiza que la descomposición termina siempre por ser una fórmula finita.\n  \nEste archivo describe **qué** y **cómo** se hace el análisis sintáctico paso a paso.\n\n- **Árbol sintáctico.md** muestra cómo se **representa visualmente** el resultado del análisis sintáctico mediante un árbol invertido:\n  - La fórmula original es la **raíz** del árbol.\n  - Las subfórmulas son nodos hijos, subárboles, etc.\n  - Las hojas son las fórmulas atómicas.\n  - Se usan términos gráficos como nodos raíz, nodos hoja, ramas y subárboles para explicar esa estructura jerárquica.\n  \nEste archivo ilustra el **resultado visual** o la estructura que surge del proceso descrito en \"Análisis sintáctico de una fórmula.md\".\n\n---\n\n### 2. Relación conceptual entre ambos\n\n- El **Análisis sintáctico** es el proceso que te permite **descomponer** la fórmula original en sus componentes sintácticos básicos.\n- El **Árbol sintáctico** es la **forma gráfica** que organiza y muestra claramente esa descomposición.\n- La fórmula se convierte en un árbol, donde cada nodo representa una subfórmula identificada en el análisis.\n- Por lo tanto, el análisis sintáctico da los datos y estructura para construir el árbol sintáctico.\n\n---\n\n### 3. En resumen\n\n- Primero tienes una fórmula proposicional cualquiera.\n- Aplicas el **análisis sintáctico**: detectas conectiva principal y subfórmulas, y descompones recursivamente.\n- Al terminar obtienes una jerarquía de subfórmulas.\n- Esa jerarquía se puede **representar como un árbol sintáctico** donde:\n  - La raíz es la fórmula completa.\n  - Las ramas muestran cómo se descompone en subfórmulas.\n  - Las hojas son las fórmulas atómicas.\n  \nPor eso, ambos conceptos se complementan porque uno (análisis) te da el procedimiento para entender la estructura, y el otro (árbol) te da la forma visual para representar esa estructura.\n\n---\n\nSi lo deseas, te puedo ayudar a crear un ejemplo concreto que ilustre ambos documentos con una fórmula determinada. ¿Quieres?"}}],"usage":{},"raw":{"id":"chatcmpl-BgemdKjqjHAgWsoqDHxf0iRcK31ex","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Los dos archivos **\"Análisis sintáctico de una fórmula.md\"** y **\"Árbol sintáctico.md\"** se complementan de manera natural porque uno describe el **proceso** y el otro la **representación gráfica** del resultado de ese proceso.\n\n---\n\n### 1. ¿Cómo se complementan?\n\n- **Análisis sintáctico de una fórmula.md** explica el **proceso lógico y sistemático** por el cual se analiza una fórmula proposicional:\n  - Se identifica la **conectiva principal** de la fórmula.\n  - Se descompone en las **subfórmulas inmediatas**.\n  - Este proceso se aplica recursivamente a cada subfórmula, hasta llegar a fórmulas atómicas (sin conectivas).\n  - Garantiza que la descomposición termina siempre por ser una fórmula finita.\n  \nEste archivo describe **qué** y **cómo** se hace el análisis sintáctico paso a paso.\n\n- **Árbol sintáctico.md** muestra cómo se **representa visualmente** el resultado del análisis sintáctico mediante un árbol invertido:\n  - La fórmula original es la **raíz** del árbol.\n  - Las subfórmulas son nodos hijos, subárboles, etc.\n  - Las hojas son las fórmulas atómicas.\n  - Se usan términos gráficos como nodos raíz, nodos hoja, ramas y subárboles para explicar esa estructura jerárquica.\n  \nEste archivo ilustra el **resultado visual** o la estructura que surge del proceso descrito en \"Análisis sintáctico de una fórmula.md\".\n\n---\n\n### 2. Relación conceptual entre ambos\n\n- El **Análisis sintáctico** es el proceso que te permite **descomponer** la fórmula original en sus componentes sintácticos básicos.\n- El **Árbol sintáctico** es la **forma gráfica** que organiza y muestra claramente esa descomposición.\n- La fórmula se convierte en un árbol, donde cada nodo representa una subfórmula identificada en el análisis.\n- Por lo tanto, el análisis sintáctico da los datos y estructura para construir el árbol sintáctico.\n\n---\n\n### 3. En resumen\n\n- Primero tienes una fórmula proposicional cualquiera.\n- Aplicas el **análisis sintáctico**: detectas conectiva principal y subfórmulas, y descompones recursivamente.\n- Al terminar obtienes una jerarquía de subfórmulas.\n- Esa jerarquía se puede **representar como un árbol sintáctico** donde:\n  - La raíz es la fórmula completa.\n  - Las ramas muestran cómo se descompone en subfórmulas.\n  - Las hojas son las fórmulas atómicas.\n  \nPor eso, ambos conceptos se complementan porque uno (análisis) te da el procedimiento para entender la estructura, y el otro (árbol) te da la forma visual para representar esa estructura.\n\n---\n\nSi lo deseas, te puedo ayudar a crear un ejemplo concreto que ilustre ambos documentos con una fórmula determinada. ¿Quieres?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749506146201-1749506170827","thread_key":"Untitled Chat 1749506146201","stream":true,"class_name":"SmartCompletion","context_key":"1749506165172","user_message":"cómo se complementan?","new_user_message":true},
"smart_completions:Untitled Chat 1749506269151-1749506269152": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"en que se relacionan?"},{"type":"text","text":"└── NOTES/\n    ├── Las tres leyes de TDD.md\n    └── Test unitario (1).md\n\nNOTES/Test unitario (1).md\n```md\n---\nlibro: \"[[Growing Object-Oriented Software, Guided by tests]]\"\ncapítulo: 1-What is the point of test-driven-development\npaginas: 8,\ntags:\n  - TDD\naliases:\n  - Test solitario\n---\n## ¿Qué es?\nSegún los autores son tests que ayudan a cuidar la [[Calidad interna del código]]. Suelen hablar de test sobre objetos, no queda del todo claro, pero de cierta manera hablan de test solitario. Esto significa que se intenta verificar que un objeto haga o cumpla lo que se espera de este. Dado, que los objetos no son entes aislados y normalmente trabajan con otros por colaboración, y dicha colaboración se traduce en dependencia, para testear que un objeto funciona correctamente, es necesario simular estas dependencias, y lo más importante, que queden explicitas en el diseño. Por tanto, se trata de comprobar que un objeto, estableciendo condiciones de sus dependencias, se comporte de una manera concreta ante un escenario x.\n## Opinión\nEste enfoque de test unitario provoca:\n* Un acoplamiento excesivo de los tests en el diseño\n* Tener que realizar mucho testing de caja blanca\n* Y dificultar el cambio de diseño\n```\nNOTES/Las tres leyes de TDD.md\n```md\n---\nlibro: \"[[Clean Craftsmanship Disciplines, Standards and Ethics]]\"\ncapítulo: 1-The Disciplines\npaginas: \"58\"\ntags:\n  - TDD\n---\nLas tres leyes o arbitrariedades de la [[Disciplina]] [[Test-Driven-Development]] son:\n>1. Write no production code until you have first written a test that fails due to the lack of that  production code. \n>2. Write no more of a test than is sufficient to fail or fail to compile. Resolve the failure by writing  some production code.\n>3. Write no more production code than will resolve the currently failing test. Once the test passes,  write more test code. \nLas tres leyes te encierran en un ciclo de unos pocos segundos de duración.  En cada vuelta de ese ciclo, estás cambiando entre código de prueba y código de producción. Nunca podrás escribir simplemente una sentencia if o un bucle while. Nunca podrás simplemente escribir una función. Estarás atrapado para siempre en este pequeño bucle de cambiar contextos entre código de prueba y código de producción. \n```"},{"type":"text","text":"en que se relacionan?"}]}]},"responses":[{"timestamp":1749506316742,"id":"chatcmpl-Bgenc8yExKlj3LWcnenYqGp4pkqV0","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Las dos notas que compartiste están relacionadas porque ambas abordan aspectos fundamentales del desarrollo de software usando **Test-Driven Development (TDD)** y en particular, el papel que juegan los **test unitarios** dentro de esta disciplina.\n\n### Relación entre las dos notas:\n\n1. **Contexto común: TDD y test unitarios**  \n   Ambas notas están enfocadas en la práctica de escribir tests primero y cómo éstos guían el desarrollo del código (TDD). La nota *\"Las tres leyes de TDD\"* enumera las reglas que definen el ciclo estricto de TDD: escribir un test que falle, luego código mínimo para hacerlo pasar, etc. La nota *\"Test unitario (1)\"* profundiza en cómo esos tests — especialmente los tests unitarios o tests solitarios (que prueban un objeto o unidad en aislamiento)— son usados para validar el comportamiento esperado del código.\n\n2. **El test unitario como pieza clave dentro del ciclo TDD**  \n   La nota *\"Test unitario (1)\"* explica qué es un test unitario, cómo se prueba un objeto aisladamente simulando sus dependencias para enfocarse en su comportamiento concreto. Esto se enlaza con las tres leyes que exigen escribir tests pequeños y específicos primero (ley 1) antes de implementar cualquier código.\n\n3. **Disciplina y diseño guiado por pruebas**  \n   La nota sobre test unitario subraya que para probar un objeto aislado, se simulan dependencias, lo que implica que el diseño debe facilitarlo — un aspecto práctico que surge de seguir la disciplina de TDD, como se muestra en las leyes. El ciclo corto de escribir tests y código que las leyes describen fomenta que el diseño evolucione junto con los tests.\n\n4. **Implicaciones y retos en el desarrollo**  \n   La crítica en la nota de los tests unitarios (acoplamiento de tests al diseño, testing de caja blanca, dificultad para cambiar diseño) es una consecuencia directa del enfoque estricto de TDD que las tres leyes propugnan. En otras palabras, al seguir rigurosamente las tres leyes, uno termina generando muchos tests unitarios muy ligados al diseño interno, lo que puede hacer más difícil la refactorización.\n\n---\n\n### En resumen:\n- **Las tres leyes de TDD** establecen el marco metodológico y el ciclo de trabajo en TDD.\n- **Los tests unitarios** son el tipo de tests que se construyen siguiendo ese ciclo, buscando probar piezas pequeñas (unidades/objetos) en aislamiento.\n- El proceso de escribir esos tests unitarios primero (como obliga la primera ley) guía el diseño del código.\n- El enfoque estricto puede provocar acoplamientos entre tests y diseño, lo que afecta la flexibilidad del código a largo plazo.\n\n---\n\nSi quieres, puedo ayudarte a ampliar esta relación con ejemplos, o explicarte cómo manejar esos retos que mencionas en la nota del test unitario. ¿Quieres?"}}],"usage":{},"raw":{"id":"chatcmpl-Bgenc8yExKlj3LWcnenYqGp4pkqV0","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Las dos notas que compartiste están relacionadas porque ambas abordan aspectos fundamentales del desarrollo de software usando **Test-Driven Development (TDD)** y en particular, el papel que juegan los **test unitarios** dentro de esta disciplina.\n\n### Relación entre las dos notas:\n\n1. **Contexto común: TDD y test unitarios**  \n   Ambas notas están enfocadas en la práctica de escribir tests primero y cómo éstos guían el desarrollo del código (TDD). La nota *\"Las tres leyes de TDD\"* enumera las reglas que definen el ciclo estricto de TDD: escribir un test que falle, luego código mínimo para hacerlo pasar, etc. La nota *\"Test unitario (1)\"* profundiza en cómo esos tests — especialmente los tests unitarios o tests solitarios (que prueban un objeto o unidad en aislamiento)— son usados para validar el comportamiento esperado del código.\n\n2. **El test unitario como pieza clave dentro del ciclo TDD**  \n   La nota *\"Test unitario (1)\"* explica qué es un test unitario, cómo se prueba un objeto aisladamente simulando sus dependencias para enfocarse en su comportamiento concreto. Esto se enlaza con las tres leyes que exigen escribir tests pequeños y específicos primero (ley 1) antes de implementar cualquier código.\n\n3. **Disciplina y diseño guiado por pruebas**  \n   La nota sobre test unitario subraya que para probar un objeto aislado, se simulan dependencias, lo que implica que el diseño debe facilitarlo — un aspecto práctico que surge de seguir la disciplina de TDD, como se muestra en las leyes. El ciclo corto de escribir tests y código que las leyes describen fomenta que el diseño evolucione junto con los tests.\n\n4. **Implicaciones y retos en el desarrollo**  \n   La crítica en la nota de los tests unitarios (acoplamiento de tests al diseño, testing de caja blanca, dificultad para cambiar diseño) es una consecuencia directa del enfoque estricto de TDD que las tres leyes propugnan. En otras palabras, al seguir rigurosamente las tres leyes, uno termina generando muchos tests unitarios muy ligados al diseño interno, lo que puede hacer más difícil la refactorización.\n\n---\n\n### En resumen:\n- **Las tres leyes de TDD** establecen el marco metodológico y el ciclo de trabajo en TDD.\n- **Los tests unitarios** son el tipo de tests que se construyen siguiendo ese ciclo, buscando probar piezas pequeñas (unidades/objetos) en aislamiento.\n- El proceso de escribir esos tests unitarios primero (como obliga la primera ley) guía el diseño del código.\n- El enfoque estricto puede provocar acoplamientos entre tests y diseño, lo que afecta la flexibilidad del código a largo plazo.\n\n---\n\nSi quieres, puedo ayudarte a ampliar esta relación con ejemplos, o explicarte cómo manejar esos retos que mencionas en la nota del test unitario. ¿Quieres?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749506269151-1749506269152","thread_key":"Untitled Chat 1749506269151","stream":true,"context_key":"1749506269152","class_name":"SmartCompletion","user_message":"en que se relacionan?","new_user_message":true},
"smart_completions:Untitled Chat 1749508539908-1749510228702": {"completion":{"request":{"messages":[{"role":"assistant","content":""},{"role":"user","content":[{"type":"text","text":"Hazme un post para compartir mis notas"},{"type":"text","text":"└── NOTES/\n    ├── Bases de Lean UX (Product).md\n    ├── Ciclos cortos de trabajo ventaja competitiva.md\n    ├── Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n    └── Lean UX (Product).md\n\nNOTES/Bases de Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: 366-\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n### Lean Startup \n Lean Startup utiliza un ciclo de retroalimentación llamado “construir-medir-aprender” para minimizar el riesgo del proyecto y lograr que los equipos comiencen a construir y aprender rápidamente. Los equipos crean Productos Mínimos Viables (MVP, por sus siglas en inglés) y los lanzan rápidamente para iniciar el proceso de aprendizaje lo antes posible. \n \n Como dice Eric, “Lean Startup aboga inicialmente por la creación de prototipos rápidos diseñados para probar suposiciones de mercado y utiliza la retroalimentación de los clientes para evolucionarlos mucho más rápido que mediante prácticas tradicionales de ingeniería de software”. Continúa: “Los procesos Lean Startup reducen el desperdicio al aumentar la frecuencia de contacto con clientes reales, probando y evitando así suposiciones de mercado incorrectas lo antes posible”. \n \n Lean UX es una aplicación directa de esta filosofía a la práctica del diseño de productos. Cada diseño es una solución empresarial propuesta: una hipótesis. Tu objetivo es validar la solución propuesta de la manera más eficiente posible utilizando la retroalimentación de los clientes. Lo más pequeño que puedes construir para probar cada hipótesis es tu MVP. El MVP no necesita estar hecho de código: puede ser una aproximación a la experiencia final; ¡incluso podría no ser un producto! Recoges lo que aprendes de tu MVP y desarrollas tus ideas. Luego, lo vuelves a hacer.\n### Design Thinking\n El Design Thinking observa los sistemas y nos ayuda a aplicar herramientas de diseño a problemas más amplios. Se basa en la colaboración, la iteración, la creación y la empatía como elementos centrales para la resolución de problemas desde una perspectiva holística.  \n### Agile\nLean UX aplica los cuatro valores principales del desarrollo ágil al diseño de productos:\n* **Individuos e interacciones sobre procesos y herramientas**\n\t* favorecer la colaboración y la conversación por encima de los entregables y los procesos rígidos. \n\t* Involucra a todo el equipo para generar ideas desde diversos puntos de vista. \n\t* Fomenta el intercambio libre y frecuente de ideas para que el equipo pueda debatir, decidir y avanzar rápidamente.\n* **Software funcionando sobre documentación exhaustiva**: \n\t* Cada problema de negocio tiene infinitas soluciones, y cada miembro del equipo tendrá una opinión sobre cuál es la mejor. \n\t* El reto es averiguar cuál solución es la más viable. A veces, es difícil o imposible predecir de antemano qué solución funcionará. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a través de software funcional) antes, el equipo puede evaluar rápidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboración con el cliente sobre negociación contractual**\n\t* Colaborar con tus compañeros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n\t* Crea consenso detrás de las decisiones. ¿El resultado? Iteraciones más rápidas, participación real en la creación del producto e inversión del equipo en el aprendizaje validado. \n\t* También reduce la dependencia de la documentación extensa porque todos en el equipo ya han participado en la toma de decisiones.\n\t* La colaboración genera alineación de manera más efectiva que la comunicación escrita, la discusión y la defensa elaborada.\nResponder al cambio sobre seguir un plan. La suposición en Lean UX es que los diseños iniciales del producto estarán equivocados, por lo que el objetivo del equipo debe ser descubrir lo que está mal lo antes posible. Tan pronto como el equipo descubre qué está funcionando y qué no, ajustan sus propuestas y prueban de nuevo. Esta retroalimentación del mercado mantiene a los equipos ágiles, guiándolos constantemente en una dirección “más correcta”.\n## UX (User Experience)\nUX abarca varios campos del diseño, incluyendo el diseño de interacción, la arquitectura de la información, el diseño gráfico y muchos otros. Pero el corazón de la práctica de UX es que comienza identificando las necesidades humanas—las necesidades de los usuarios del sistema.\n```\nNOTES/Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncapítulo: 0-Prefacio\npaginas: \"207\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Ciclos cortos de trabajo ventaja competitiva.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"266\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué significa esto?\n Al lanzar temprano y con frecuencia, obtener retroalimentación del mercado e iterar en función de lo que aprenden para crear una conversación continua con los clientes.\n## ¿Por qué?\n En esencia, están descubriendo su producto al mismo tiempo que lo entregan. Esto tiene muchos beneficios, pero quizás los dos más importantes son: \n * La capacidad de aprender, de manera continua y rápida, qué tan bien sus productos están satisfaciendo las necesidades de los clientes.\n * Elevar las expectativas de los clientes en cuanto a la calidad del producto y los tiempos de respuesta de la empresa ante sus inquietudes y comentarios. \n * Además, esta nueva forma de trabajar no se basa en tecnologías costosas. Las plataformas y servicios que lo hacen posible están disponibles de forma gratuita o casi gratuita para prácticamente cualquier equipo emprendedor. \n## ¿Cómo impacta esto en el ambiente o mercado?\n Esto expone a las empresas establecidas a una amenaza que no habían conocido antes. Específicamente, las barreras de entrada—en casi todos los ámbitos—nunca han sido tan bajas. Sin la necesidad de “fabricar” un producto físico, cualquier persona con acceso a la web puede diseñar, programar y desplegar servicios para cualquier otra persona. Ante estas nuevas amenazas, los enfoques tradicionales de “tenerlo todo resuelto primero” simplemente no son viables. Entonces, ¿qué deberían hacer los equipos de producto?\n```\nNOTES/Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro|Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"384\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs la práctica de revelar la verdadera naturaleza de un producto de manera más rápida, colaborativa y multifuncional. Trabajamos para construir una comprensión compartida del cliente, sus necesidades, nuestras soluciones propuestas y nuestra definición de éxito. Priorizamos el aprendizaje sobre la entrega para fundamentar nuestras decisiones con evidencia.\n## ¿Cuáles son sus principios?\n### Principios para Guiar la Organización del Equipo\n* Equipos multifuncionales \n* Equipos pequeños, dedicados, colocalizados \n* Equipos autosuficientes y empoderados \n* Equipos enfocados en resolver problemas\n### Principios para Guiar la Cultura\n### Principios para Guiar el Proceso\n```"},{"type":"text","text":"Hazme un post para compartir mis notas"}]}],"tools":[{"type":"function","function":{"name":"lookup_context","description":"Common, frequently used. Performs a semantic search of the user's data. Use to respond to 'Based on my notes...' or any other query that might require surfacing unspecified content. Minimum 3 hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. Each hypothetical is a semantic representation of content that's likely relevant to the user's request. Hypothetical notes always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3.","parameters":{"type":"object","properties":{"hypothetical_1":{"type":"string","description":"Always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3."},"hypothetical_2":{"type":"string","description":"Must be distinct from and not share any breadcrumbs with hypothetical_1."},"hypothetical_3":{"type":"string","description":"Must be distinct from hypothetical_1 and hypothetical_2."},"in_folder":{"type":"string","description":"Optional. Only use if requested by the user. Limit the lookup to items in this folder."}},"required":["hypothetical_1","hypothetical_2"]}}}],"tool_choice":{"type":"function","function":{"name":"lookup_context"}}},"responses":[{"timestamp":1749510274597,"id":"chatcmpl-BgfpYV0FIpZp8YqEDfdXKbp5XwPid","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"","tool_calls":[{"id":"call_WVsJxexfjzw5DBuOgjpPiWlm","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"NOTES/Bases de Lean UX (Product).md: Post sobre los fundamentos de Lean UX, explicando cómo combina Lean Startup, Design Thinking y Agile para diseñar productos eficaces y centrados en el usuario.\",\"hypothetical_2\":\"NOTES/Ciclos cortos de trabajo ventaja competitiva.md: Post sobre la ventaja competitiva de aplicar ciclos cortos de trabajo para lanzar rápido, obtener feedback continuo y adaptarse al mercado.\",\"hypothetical_3\":\"NOTES/Lean UX (Product).md: Post sobre qué es Lean UX, sus principios organizacionales, culturales y de proceso, y cómo ayuda a construir productos basados en aprendizaje validado.\"}"}}]}}],"usage":{},"raw":{"id":"chatcmpl-BgfpYV0FIpZp8YqEDfdXKbp5XwPid","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"","tool_calls":[{"id":"call_WVsJxexfjzw5DBuOgjpPiWlm","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"NOTES/Bases de Lean UX (Product).md: Post sobre los fundamentos de Lean UX, explicando cómo combina Lean Startup, Design Thinking y Agile para diseñar productos eficaces y centrados en el usuario.\",\"hypothetical_2\":\"NOTES/Ciclos cortos de trabajo ventaja competitiva.md: Post sobre la ventaja competitiva de aplicar ciclos cortos de trabajo para lanzar rápido, obtener feedback continuo y adaptarse al mercado.\",\"hypothetical_3\":\"NOTES/Lean UX (Product).md: Post sobre qué es Lean UX, sus principios organizacionales, culturales y de proceso, y cómo ayuda a construir productos basados en aprendizaje validado.\"}"}}]}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749508539908-1749510228702","thread_key":"Untitled Chat 1749508539908","stream":true,"context_key":"1749510228701","class_name":"SmartCompletion","user_message":"Hazme un post para compartir mis notas","new_user_message":true,"action_key":"lookup_context","actions":{"lookup_context":"1749510275393"}},
"smart_completions:Untitled Chat 1749508539908-1749510275396": {"completion":{"request":{"messages":[{"role":"assistant","content":""},{"role":"user","content":[{"type":"text","text":"Hazme un post para compartir mis notas"},{"type":"text","text":"└── NOTES/\n    ├── Bases de Lean UX (Product).md\n    ├── Ciclos cortos de trabajo ventaja competitiva.md\n    ├── Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n    └── Lean UX (Product).md\n\nNOTES/Bases de Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: 366-\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n### Lean Startup \n Lean Startup utiliza un ciclo de retroalimentación llamado “construir-medir-aprender” para minimizar el riesgo del proyecto y lograr que los equipos comiencen a construir y aprender rápidamente. Los equipos crean Productos Mínimos Viables (MVP, por sus siglas en inglés) y los lanzan rápidamente para iniciar el proceso de aprendizaje lo antes posible. \n \n Como dice Eric, “Lean Startup aboga inicialmente por la creación de prototipos rápidos diseñados para probar suposiciones de mercado y utiliza la retroalimentación de los clientes para evolucionarlos mucho más rápido que mediante prácticas tradicionales de ingeniería de software”. Continúa: “Los procesos Lean Startup reducen el desperdicio al aumentar la frecuencia de contacto con clientes reales, probando y evitando así suposiciones de mercado incorrectas lo antes posible”. \n \n Lean UX es una aplicación directa de esta filosofía a la práctica del diseño de productos. Cada diseño es una solución empresarial propuesta: una hipótesis. Tu objetivo es validar la solución propuesta de la manera más eficiente posible utilizando la retroalimentación de los clientes. Lo más pequeño que puedes construir para probar cada hipótesis es tu MVP. El MVP no necesita estar hecho de código: puede ser una aproximación a la experiencia final; ¡incluso podría no ser un producto! Recoges lo que aprendes de tu MVP y desarrollas tus ideas. Luego, lo vuelves a hacer.\n### Design Thinking\n El Design Thinking observa los sistemas y nos ayuda a aplicar herramientas de diseño a problemas más amplios. Se basa en la colaboración, la iteración, la creación y la empatía como elementos centrales para la resolución de problemas desde una perspectiva holística.  \n### Agile\nLean UX aplica los cuatro valores principales del desarrollo ágil al diseño de productos:\n* **Individuos e interacciones sobre procesos y herramientas**\n\t* favorecer la colaboración y la conversación por encima de los entregables y los procesos rígidos. \n\t* Involucra a todo el equipo para generar ideas desde diversos puntos de vista. \n\t* Fomenta el intercambio libre y frecuente de ideas para que el equipo pueda debatir, decidir y avanzar rápidamente.\n* **Software funcionando sobre documentación exhaustiva**: \n\t* Cada problema de negocio tiene infinitas soluciones, y cada miembro del equipo tendrá una opinión sobre cuál es la mejor. \n\t* El reto es averiguar cuál solución es la más viable. A veces, es difícil o imposible predecir de antemano qué solución funcionará. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a través de software funcional) antes, el equipo puede evaluar rápidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboración con el cliente sobre negociación contractual**\n\t* Colaborar con tus compañeros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n\t* Crea consenso detrás de las decisiones. ¿El resultado? Iteraciones más rápidas, participación real en la creación del producto e inversión del equipo en el aprendizaje validado. \n\t* También reduce la dependencia de la documentación extensa porque todos en el equipo ya han participado en la toma de decisiones.\n\t* La colaboración genera alineación de manera más efectiva que la comunicación escrita, la discusión y la defensa elaborada.\nResponder al cambio sobre seguir un plan. La suposición en Lean UX es que los diseños iniciales del producto estarán equivocados, por lo que el objetivo del equipo debe ser descubrir lo que está mal lo antes posible. Tan pronto como el equipo descubre qué está funcionando y qué no, ajustan sus propuestas y prueban de nuevo. Esta retroalimentación del mercado mantiene a los equipos ágiles, guiándolos constantemente en una dirección “más correcta”.\n## UX (User Experience)\nUX abarca varios campos del diseño, incluyendo el diseño de interacción, la arquitectura de la información, el diseño gráfico y muchos otros. Pero el corazón de la práctica de UX es que comienza identificando las necesidades humanas—las necesidades de los usuarios del sistema.\n```\nNOTES/Esperar demasiado tiempo para obtener feedback, es un desperdicio.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncapítulo: 0-Prefacio\npaginas: \"207\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Ciclos cortos de trabajo ventaja competitiva.md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"266\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué significa esto?\n Al lanzar temprano y con frecuencia, obtener retroalimentación del mercado e iterar en función de lo que aprenden para crear una conversación continua con los clientes.\n## ¿Por qué?\n En esencia, están descubriendo su producto al mismo tiempo que lo entregan. Esto tiene muchos beneficios, pero quizás los dos más importantes son: \n * La capacidad de aprender, de manera continua y rápida, qué tan bien sus productos están satisfaciendo las necesidades de los clientes.\n * Elevar las expectativas de los clientes en cuanto a la calidad del producto y los tiempos de respuesta de la empresa ante sus inquietudes y comentarios. \n * Además, esta nueva forma de trabajar no se basa en tecnologías costosas. Las plataformas y servicios que lo hacen posible están disponibles de forma gratuita o casi gratuita para prácticamente cualquier equipo emprendedor. \n## ¿Cómo impacta esto en el ambiente o mercado?\n Esto expone a las empresas establecidas a una amenaza que no habían conocido antes. Específicamente, las barreras de entrada—en casi todos los ámbitos—nunca han sido tan bajas. Sin la necesidad de “fabricar” un producto físico, cualquier persona con acceso a la web puede diseñar, programar y desplegar servicios para cualquier otra persona. Ante estas nuevas amenazas, los enfoques tradicionales de “tenerlo todo resuelto primero” simplemente no son viables. Entonces, ¿qué deberían hacer los equipos de producto?\n```\nNOTES/Lean UX (Product).md\n```md\n---\nlibro: \"[[Lean UX (Product) - Libro|Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: \"384\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs la práctica de revelar la verdadera naturaleza de un producto de manera más rápida, colaborativa y multifuncional. Trabajamos para construir una comprensión compartida del cliente, sus necesidades, nuestras soluciones propuestas y nuestra definición de éxito. Priorizamos el aprendizaje sobre la entrega para fundamentar nuestras decisiones con evidencia.\n## ¿Cuáles son sus principios?\n### Principios para Guiar la Organización del Equipo\n* Equipos multifuncionales \n* Equipos pequeños, dedicados, colocalizados \n* Equipos autosuficientes y empoderados \n* Equipos enfocados en resolver problemas\n### Principios para Guiar la Cultura\n### Principios para Guiar el Proceso\n```"},{"type":"text","text":"Hazme un post para compartir mis notas"},{"type":"text","text":"├── ARTICLES/escritas/\n│   ├── Una estrategia de testing para un desarrollo productivo y eficaz.md#\n│   ├── Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests\n│   ├── Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{1}\n│   ├── Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{5}\n│   └── Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{8}\n└── NOTES/\n    ├── Ciclos de refactorización.md##¿Qué son?\n    ├── Ciclos de refactorización.md##¿Qué son?#{1}\n    ├── Desarrollo de software iterativo-incremental (1).md##¿Qué es?#{1}\n    ├── Desarrollo de software iterativo-incremental (1).md##Opinión#{1}\n    └── Los beneficios del testing (1).md#\n\nNOTES/Ciclos de refactorización.md##¿Qué son?#{1}\n```md##¿Qué son?#{1}\nSon momentos donde podemos introducir la práctica de la refactorización dentro de un ciclo de trabajo. En este caso, hablamos de una introducción que cuyo consumo de tiempo sea muy bajo pero que tiene una gran rentabilidad a largo plazo. Esto permite que el mayor tiempo se dedique a funcionalidades nuevas  y no al contrario, si no se hace ocurriría lo contrario.\nEjemplos de esto son:\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md#\n```md#\nEl desarrollo de software guiado por tests requiere un elemento fundamental para ser efectivo: un feedback rápido. Esto es crucial para la ejecución continua de los tests, especialmente durante la etapa de mejora del diseño o refactorización. Sin embargo, lograrlo en un proyecto real no es tarea fácil, ya que el número de tests puede superar el centenar, con diferentes tiempos de ejecución. En mi experiencia, he enfrentado esta dificultad, lo que complicaba la realización de cambios en el código. Con el tiempo, aprendí que no era necesario ejecutar todos los tests al trabajar en una sección específica de la aplicación; bastaba con asegurarme de que el conjunto de elementos acoplados continuaran pasando los tests. Esto representó una mejora, y durante un tiempo fue el mejor enfoque que tenía, hasta que comencé a ver los webinars de \"Diseño a la gorra\" de 10pines, dirigidos por Hernán Wilkinson. Estos tuvieron un gran impacto en mí, pues ampliaron mi perspectiva sobre el desarrollo guiado por tests. Aprendí a enfocar los tests para aliviar el dolor de la ejecución prolongada y, además, pude conectar estos conocimientos con otros relacionados con el diseño orientado a objetos y el testing. El resultado es una estrategia que actualmente en el equipo que estoy estamos aplicando, puesnos permite facilitar el cambio y, lo más importante, obtener un feedback rápido. A continuación, te explicaré esta estrategia en detalle.\n```\nNOTES/Ciclos de refactorización.md##¿Qué son?\n```md##¿Qué son?\n## ¿Qué son?\nSon momentos donde podemos introducir la práctica de la refactorización dentro de un ciclo de trabajo. En este caso, hablamos de una introducción que cuyo consumo de tiempo sea muy bajo pero que tiene una gran rentabilidad a largo plazo. Esto permite que el mayor tiempo se dedique a funcionalidades nuevas  y no al contrario, si no se hace ocurriría lo contrario.\nEjemplos de esto son:\n* Conforme se termina de escribir un bloque y funciona, podemos volver a leerlo buscando si se puede hacer más explicito\n* Cada día al empezar la jornada dedica diez minutos a leer el código del día anterior\n* Al terminar una funcionalidad repasa el código para identificar posibles sorpresas o mejorar.\n> Regla del Boy Scout: Mejorar algo el código cuando se tiene que cambiar el código. Mejora continúa\n```\nNOTES/Desarrollo de software iterativo-incremental (1).md##Opinión#{1}\n```md##Opinión#{1}\nEn el  capítulo que se menciona esto me parece interesante y alineado con la perspectiva Agile, pero propone una forma de trabajar que se basa  en el tipo de testing que se basa en el alcance del código. No se si es la mejor manera de momento.\n```\nNOTES/Desarrollo de software iterativo-incremental (1).md##¿Qué es?#{1}\n```md##¿Qué es?#{1}\nEs un enfoque de desarrollo de software donde se entregan en ciclos de desarrollo funcionalidades completas de punto a punto (e2e) como una porción de un sistema (incrementos). sobre cada funcionalidad desplegada hay un proceso de refinamiento de la implementación tras contrastar los que ofrece la funcionalidad contra las necesidades de los usuarios por medio del feedback (iteración) reduciendo la diferencia entre estos o errores. Por otro lado, esto permite cuantificar el trabajo, ver el progreso del desarrollo, así cómo poder facilitar ajustes a los planes de desarrollo.\n \n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests\n```md##Un cambio de perspectiva sobre los tests\n## Un cambio de perspectiva sobre los tests\nAl trabajar con tests, es común hablar de los **Niveles de testing**, que incluyen: **Test unitario**, **Test de integración** y **Test end to end**. Aunque esta es una forma extendida de categorizar los tests, otra perspectiva interesante es la que proponen [[Steve Freeman]] y [[Nat Pryce]] en su libro [[_Growing Object-Oriented Software, Guided by Tests_]]:\n- **[[Test unitario (1)|Test solitario]]s**: Verifican que un objeto se comporte como se espera. Si el objeto colabora con otros, estos deben ser simulados.\n- **[[Test de integración (1)]]**: Confirman que nuestro código interactúa correctamente con código de terceros que no podemos modificar.\n- **T[[Test end to end (1)|Test de Aceptación]]**: Evalúan de manera indirecta si el sistema en su totalidad (a través de flujos completos) funciona correctamente.\nAunque este enfoque es razonable, se centra principalmente en la granularidad o el alcance del código. En el webinar [[Todo lo que quisiste saber sobre los tests]], [[Hernan Wilkinson]] presenta una visión más interesante sobre los tests: la distinción entre tests para programadores y tests de infraestructura o integración. Este enfoque proporciona una manera simple y útil de entender los tests:\n- **Tests para programadores**: Se enfocan en cumplir los requisitos funcionales y tienen como principal característica el proporcionar un ciclo de retroalimentación rápido.\n- **Tests de infraestructura o integración**: Verifican que nuestro código se integre correctamente con tecnologías externas de las que depende nuestra aplicación.\nResulta interesante que [[Robert C. Martin]] también aborda esta visión en su libro [[Clean Craftsmanship Disciplines, Standards and Ethics]]:\n> [[Test de programador (1)]]: Test escrito por y para programadores con el propósito de especificar el comportamiento del sistema.\nEsta visión forma la base de la estrategia que propongo. Ahora queda por resolver: ¿Cómo se implementa esto? Veamos los puntos clave.\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{8}\n```md##Un cambio de perspectiva sobre los tests#{8}\nResulta interesante que [[Robert C. Martin]] también aborda esta visión en su libro [[Clean Craftsmanship Disciplines, Standards and Ethics]]:\n> [[Test de programador (1)]]: Test escrito por y para programadores con el propósito de especificar el comportamiento del sistema.\nEsta visión forma la base de la estrategia que propongo. Ahora queda por resolver: ¿Cómo se implementa esto? Veamos los puntos clave.\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{1}\n```md##Un cambio de perspectiva sobre los tests#{1}\nAl trabajar con tests, es común hablar de los **Niveles de testing**, que incluyen: **Test unitario**, **Test de integración** y **Test end to end**. Aunque esta es una forma extendida de categorizar los tests, otra perspectiva interesante es la que proponen [[Steve Freeman]] y [[Nat Pryce]] en su libro [[_Growing Object-Oriented Software, Guided by Tests_]]:\n```\nARTICLES/escritas/Una estrategia de testing para un desarrollo productivo y eficaz.md##Un cambio de perspectiva sobre los tests#{5}\n```md##Un cambio de perspectiva sobre los tests#{5}\nAunque este enfoque es razonable, se centra principalmente en la granularidad o el alcance del código. En el webinar [[Todo lo que quisiste saber sobre los tests]], [[Hernan Wilkinson]] presenta una visión más interesante sobre los tests: la distinción entre tests para programadores y tests de infraestructura o integración. Este enfoque proporciona una manera simple y útil de entender los tests:\n```\nNOTES/Los beneficios del testing (1).md#\n```md#\n* Encontrar bugs\n* Documentación viva del diseño\n* Permite aplazar decisiones de diseño\n* Soportar el aumento del nivel de abstracción a medida que nuevos requerimientos aparecen\n* Exponen los defectos de diseño \n\t* Un setup que cuesta escribir\n\t* Muchas dependencias\n\t* Dificultar de testear en definitiva\n```"}]},{"role":"assistant","content":""}]},"responses":[{"timestamp":1749510297346,"id":"chatcmpl-BgfpohUikFOOk7beM3mVuYLSatvZ5","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"¡Hola a todos! 👋\n\nQuiero compartir con ustedes algunas **notas y aprendizajes clave** que he estado recopilando sobre Lean UX, desarrollo ágil, y testing efectivo para crear productos más eficientes y orientados al cliente. 🚀\n\n---\n\n### 1. **Bases de Lean UX**  \nLean UX es una metodología que integra los principios de Lean Startup, Design Thinking y Agile para crear productos con ciclos cortos de feedback.  \n- Usamos productos mínimos viables (MVP) para validar hipótesis con el menor desperdicio posible.  \n- Priorizamos la colaboración, iteración rápida y el aprendizaje continuo por encima de la documentación extensa.  \n- La clave está en **iterar rápido y ajustar el rumbo con feedback real del mercado**.\n\n### 2. **Ciclos cortos de trabajo: ventaja competitiva**  \nTrabajar en ciclos cortos y lanzar frecuentemente no solo permite aprender rápidamente si el producto satisface las necesidades reales, sino que también eleva las expectativas del cliente sobre tiempos de respuesta y calidad.  \nEsto reduce las barreras de entrada y obliga a ser más ágiles para competir en mercados actuales.\n\n### 3. **No esperar demasiado para obtener feedback**  \nEsperar mucho para validar tus ideas es un desperdicio de tiempo y recursos. La retroalimentación temprana es fundamental para ajustar rápidamente lo que no funciona y apostar por lo que sí.\n\n### 4. **Una estrategia de testing para un desarrollo productivo y eficaz**  \nEl testing es fundamental para mantener la calidad y facilitar cambios en el código, pero los tests deben proveer retroalimentación rápida.  \n- No es necesario ejecutar todos los tests para cada cambio, sino los que cubren el área afectada.  \n- Distinguir entre tests para programadores (ciclos rápidos y funcionales) y tests de infraestructura o integración (más lentos y amplios).  \n- Esto permite acelerar el desarrollo sin sacrificar la confiabilidad.\n\n---\n\n📚 Estos apuntes me han ayudado a mejorar mi forma de trabajar, enfocándome en la eficiencia, colaboración, aprendizaje y calidad continua. Si alguno quiere profundizar en alguno de estos temas, ¡con gusto comparto más detalles!\n\nGracias por leer y seguir aprendiendo juntos 🙌.\n\n---\n\n#LeanUX #Agile #Testing #DesarrolloDeSoftware #Productividad #CicloDeFeedback #Innovación #CalidadDeSoftware\n\n---\n\n¿Te interesa que comparta más notas o artículos específicos? ¡Déjamelo saber! 😊\n\n---\n\n¡Listo para seguir construyendo mejor y más rápido! 💡✨"}}],"usage":{},"raw":{"id":"chatcmpl-BgfpohUikFOOk7beM3mVuYLSatvZ5","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"¡Hola a todos! 👋\n\nQuiero compartir con ustedes algunas **notas y aprendizajes clave** que he estado recopilando sobre Lean UX, desarrollo ágil, y testing efectivo para crear productos más eficientes y orientados al cliente. 🚀\n\n---\n\n### 1. **Bases de Lean UX**  \nLean UX es una metodología que integra los principios de Lean Startup, Design Thinking y Agile para crear productos con ciclos cortos de feedback.  \n- Usamos productos mínimos viables (MVP) para validar hipótesis con el menor desperdicio posible.  \n- Priorizamos la colaboración, iteración rápida y el aprendizaje continuo por encima de la documentación extensa.  \n- La clave está en **iterar rápido y ajustar el rumbo con feedback real del mercado**.\n\n### 2. **Ciclos cortos de trabajo: ventaja competitiva**  \nTrabajar en ciclos cortos y lanzar frecuentemente no solo permite aprender rápidamente si el producto satisface las necesidades reales, sino que también eleva las expectativas del cliente sobre tiempos de respuesta y calidad.  \nEsto reduce las barreras de entrada y obliga a ser más ágiles para competir en mercados actuales.\n\n### 3. **No esperar demasiado para obtener feedback**  \nEsperar mucho para validar tus ideas es un desperdicio de tiempo y recursos. La retroalimentación temprana es fundamental para ajustar rápidamente lo que no funciona y apostar por lo que sí.\n\n### 4. **Una estrategia de testing para un desarrollo productivo y eficaz**  \nEl testing es fundamental para mantener la calidad y facilitar cambios en el código, pero los tests deben proveer retroalimentación rápida.  \n- No es necesario ejecutar todos los tests para cada cambio, sino los que cubren el área afectada.  \n- Distinguir entre tests para programadores (ciclos rápidos y funcionales) y tests de infraestructura o integración (más lentos y amplios).  \n- Esto permite acelerar el desarrollo sin sacrificar la confiabilidad.\n\n---\n\n📚 Estos apuntes me han ayudado a mejorar mi forma de trabajar, enfocándome en la eficiencia, colaboración, aprendizaje y calidad continua. Si alguno quiere profundizar en alguno de estos temas, ¡con gusto comparto más detalles!\n\nGracias por leer y seguir aprendiendo juntos 🙌.\n\n---\n\n#LeanUX #Agile #Testing #DesarrolloDeSoftware #Productividad #CicloDeFeedback #Innovación #CalidadDeSoftware\n\n---\n\n¿Te interesa que comparta más notas o artículos específicos? ¡Déjamelo saber! 😊\n\n---\n\n¡Listo para seguir construyendo mejor y más rápido! 💡✨"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749508539908-1749510275396","thread_key":"Untitled Chat 1749508539908","stream":true,"context_key":"1749510275393","class_name":"SmartCompletion"},
"smart_completions:Untitled Chat 1749558763963-1749558787935": {"completion":{"request":{"messages":[{"role":"assistant","content":""},{"role":"user","content":[{"type":"text","text":"¿Qué tienen en común estas notas?"},{"type":"text","text":"└── NOTES/\n    ├── Alfabeto proposicional alternativo.md\n    ├── Bases de Lean UX (Product).md\n    └── Cada test es un transición de un finitos estado de máquina que describe el comportamiento del sistema.md\n\nNOTES/Alfabeto proposicional alternativo.md\n```md\n---\nlibro: \"[[Lógica y estructuras discretas 2024-2025]]\"\ncapítulo: 1-Logica Proposicional\npaginas: Notaciones alternativas\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuál puede ser?\nHay alternativas a la simbología propuesta en el [[Alfabeto Proposicional]]. \nPara las proposiciones se pueden usar letras del alfabeto como  {p,q,r,s,t…} en lugar de {p1,p2,p3,…} para evitar el uso de subíndices\nPara las conectivas, en según donde se mire, se pueden encontrar símbolos distintos para nombrarlas:\n- Entre otras opciones, se utiliza & para la conjunción, | para la disyunción o ∼ para la negación.\n- La Electrónica Digital permite materializar fórmulas lógicas en forma de circuitos combinacionales. Y en ese contexto, es habitual notar la disyunción como una suma (P+Q), la conjunción como un producto (P⋅Q) y la negación con una sobrelínea P― (P con el sombrerito.\n```\nNOTES/Bases de Lean UX (Product).md\n```md\n---\nlibro: \"[[BIBLIOGRAPHY/BOOKS/Lean UX (Product) - Libro]]\"\ncapítulo: \"1-Lean UX: More Important Now Than Ever Before\"\npaginas: 366-\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n### Lean Startup \n Lean Startup utiliza un ciclo de retroalimentación llamado “construir-medir-aprender” para minimizar el riesgo del proyecto y lograr que los equipos comiencen a construir y aprender rápidamente. Los equipos crean Productos Mínimos Viables (MVP, por sus siglas en inglés) y los lanzan rápidamente para iniciar el proceso de aprendizaje lo antes posible. \n \n Como dice Eric, “Lean Startup aboga inicialmente por la creación de prototipos rápidos diseñados para probar suposiciones de mercado y utiliza la retroalimentación de los clientes para evolucionarlos mucho más rápido que mediante prácticas tradicionales de ingeniería de software”. Continúa: “Los procesos Lean Startup reducen el desperdicio al aumentar la frecuencia de contacto con clientes reales, probando y evitando así suposiciones de mercado incorrectas lo antes posible”. \n \n Lean UX es una aplicación directa de esta filosofía a la práctica del diseño de productos. Cada diseño es una solución empresarial propuesta: una hipótesis. Tu objetivo es validar la solución propuesta de la manera más eficiente posible utilizando la retroalimentación de los clientes. Lo más pequeño que puedes construir para probar cada hipótesis es tu MVP. El MVP no necesita estar hecho de código: puede ser una aproximación a la experiencia final; ¡incluso podría no ser un producto! Recoges lo que aprendes de tu MVP y desarrollas tus ideas. Luego, lo vuelves a hacer.\n### Design Thinking\n El Design Thinking observa los sistemas y nos ayuda a aplicar herramientas de diseño a problemas más amplios. Se basa en la colaboración, la iteración, la creación y la empatía como elementos centrales para la resolución de problemas desde una perspectiva holística.  \n### Agile\nLean UX aplica los cuatro valores principales del desarrollo ágil al diseño de productos:\n* **Individuos e interacciones sobre procesos y herramientas**\n\t* favorecer la colaboración y la conversación por encima de los entregables y los procesos rígidos. \n\t* Involucra a todo el equipo para generar ideas desde diversos puntos de vista. \n\t* Fomenta el intercambio libre y frecuente de ideas para que el equipo pueda debatir, decidir y avanzar rápidamente.\n* **Software funcionando sobre documentación exhaustiva**: \n\t* Cada problema de negocio tiene infinitas soluciones, y cada miembro del equipo tendrá una opinión sobre cuál es la mejor. \n\t* El reto es averiguar cuál solución es la más viable. A veces, es difícil o imposible predecir de antemano qué solución funcionará. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a través de software funcional) antes, el equipo puede evaluar rápidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboración con el cliente sobre negociación contractual**\n\t* Colaborar con tus compañeros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n\t* Crea consenso detrás de las decisiones. ¿El resultado? Iteraciones más rápidas, participación real en la creación del producto e inversión del equipo en el aprendizaje validado. \n\t* También reduce la dependencia de la documentación extensa porque todos en el equipo ya han participado en la toma de decisiones.\n\t* La colaboración genera alineación de manera más efectiva que la comunicación escrita, la discusión y la defensa elaborada.\nResponder al cambio sobre seguir un plan. La suposición en Lean UX es que los diseños iniciales del producto estarán equivocados, por lo que el objetivo del equipo debe ser descubrir lo que está mal lo antes posible. Tan pronto como el equipo descubre qué está funcionando y qué no, ajustan sus propuestas y prueban de nuevo. Esta retroalimentación del mercado mantiene a los equipos ágiles, guiándolos constantemente en una dirección “más correcta”.\n## UX (User Experience)\nUX abarca varios campos del diseño, incluyendo el diseño de interacción, la arquitectura de la información, el diseño gráfico y muchos otros. Pero el corazón de la práctica de UX es que comienza identificando las necesidades humanas—las necesidades de los usuarios del sistema.\n```\nNOTES/Cada test es un transición de un finitos estado de máquina que describe el comportamiento del sistema.md\n```md\n---\nlibro: \"[[Clean Craftsmanship Disciplines, Standards and Ethics]]\"\ncapítulo: 1-The Disciplines\npaginas: 135-136\ntags:\n  - TDD\n  - Testing\n  - Observación\n---\n>we can deduce from this is that every test you write is a transition of  the finite state machine that describes the behavior of the system. \n## ¿Por qué?\nCada programa es una máquina de estados finitos porque el ordenador en sí hace transiciones de un estado a otro tras cada ejecución de instrucción en el procesador\n```"},{"type":"text","text":"¿Qué tienen en común estas notas?"}]}]},"responses":[{"timestamp":1749558816300,"id":"chatcmpl-BgsSNGcwMYeM0FQCeFUKY91GXhrAm","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Las tres notas que muestras tienen en común que son **extractos o resúmenes tomados de libros o fuentes especializadas, con el formato de notas de estudio o fichas para organizar conocimiento** dentro de un sistema de gestión de notas (como Obsidian o similar). Esto se puede deducir de varios aspectos:\n\n1. **Metadatos frontmatter (YAML)**\n   - Cada nota inicia con un bloque `---` que contiene campos como:\n     - `libro` (el título o referencia del libro o fuente).\n     - `capítulo`.\n     - `páginas`.\n     - `tags`.\n     - `num_veces_leida`.\n   Esto indica que son fragmentos organizados y referenciados para un trabajo de estudio o investigación.\n\n2. **Formato Markdown enriquecido con enlaces internos**\n   - Uso de enlaces internos tipo `[[Lógica y estructuras discretas 2024-2025]]`, algo típico de apps como Obsidian para conectar notas.\n   - Uso de encabezados `##` para marcar secciones.\n\n3. **Temática centrada en conocimiento técnico o científico**\n   - La primera nota es sobre lógica proposicional y notaciones alternativas en matemáticas o lógica computacional.\n   - La segunda nota se refiere a metodologías ágiles, específicamente Lean UX, Lean Startup, Agile y Design Thinking, enfocado en producto y diseño.\n   - La tercera nota trata de programación, tests y modelos de máquina de estados finitos, relacionado con ingeniería de software.\n\n4. **Objetivo: comprender, sintetizar y aplicar conocimiento**\n   - Son explicaciones breves que a modo de resumen recogen ideas clave de un capítulo o texto mayor.\n   - Las notas buscan servir como referencias rápidas para revisar conceptos esenciales.\n\n---\n\n**En resumen:**\n\n- Son notas de estudio tomadas de fuentes bibliográficas.\n- Usan un formato estructurado (frontmatter YAML + Markdown).\n- Contienen conocimiento técnico o especializado.\n- Están pensadas para ser usadas en un sistema enlazado de notas (PKM, Obsidian, Zettelkasten).\n- Sirven como resúmenes, extractos o anotaciones para aprendizaje y consulta futura.\n\n---\n\nSi quieres puedo ayudarte a extraer la idea principal de cada nota, encontrar etiquetas comunes, o sugerir cómo mejorar su organización. ¿Quieres?"}}],"usage":{},"raw":{"id":"chatcmpl-BgsSNGcwMYeM0FQCeFUKY91GXhrAm","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Las tres notas que muestras tienen en común que son **extractos o resúmenes tomados de libros o fuentes especializadas, con el formato de notas de estudio o fichas para organizar conocimiento** dentro de un sistema de gestión de notas (como Obsidian o similar). Esto se puede deducir de varios aspectos:\n\n1. **Metadatos frontmatter (YAML)**\n   - Cada nota inicia con un bloque `---` que contiene campos como:\n     - `libro` (el título o referencia del libro o fuente).\n     - `capítulo`.\n     - `páginas`.\n     - `tags`.\n     - `num_veces_leida`.\n   Esto indica que son fragmentos organizados y referenciados para un trabajo de estudio o investigación.\n\n2. **Formato Markdown enriquecido con enlaces internos**\n   - Uso de enlaces internos tipo `[[Lógica y estructuras discretas 2024-2025]]`, algo típico de apps como Obsidian para conectar notas.\n   - Uso de encabezados `##` para marcar secciones.\n\n3. **Temática centrada en conocimiento técnico o científico**\n   - La primera nota es sobre lógica proposicional y notaciones alternativas en matemáticas o lógica computacional.\n   - La segunda nota se refiere a metodologías ágiles, específicamente Lean UX, Lean Startup, Agile y Design Thinking, enfocado en producto y diseño.\n   - La tercera nota trata de programación, tests y modelos de máquina de estados finitos, relacionado con ingeniería de software.\n\n4. **Objetivo: comprender, sintetizar y aplicar conocimiento**\n   - Son explicaciones breves que a modo de resumen recogen ideas clave de un capítulo o texto mayor.\n   - Las notas buscan servir como referencias rápidas para revisar conceptos esenciales.\n\n---\n\n**En resumen:**\n\n- Son notas de estudio tomadas de fuentes bibliográficas.\n- Usan un formato estructurado (frontmatter YAML + Markdown).\n- Contienen conocimiento técnico o especializado.\n- Están pensadas para ser usadas en un sistema enlazado de notas (PKM, Obsidian, Zettelkasten).\n- Sirven como resúmenes, extractos o anotaciones para aprendizaje y consulta futura.\n\n---\n\nSi quieres puedo ayudarte a extraer la idea principal de cada nota, encontrar etiquetas comunes, o sugerir cómo mejorar su organización. ¿Quieres?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1749558763963-1749558787935","thread_key":"Untitled Chat 1749558763963","stream":true,"context_key":"1749558787935","class_name":"SmartCompletion","user_message":"¿Qué tienen en común estas notas?","new_user_message":true},
"smart_completions:Untitled Chat 1752161883212-1752161883212": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero que me hagas un artículo con todo este contenido"},{"type":"text","text":"├── BIBLIOGRAPHY/CONFERENCE-TALKS/\n│   └── Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n└── NOTES/\n    ├── Beneficios de escribir código puro para la lógica de dominio.md\n    ├── Code smells en tu código core.md\n    ├── Dependency injection.md\n    ├── Dependency interpretation.md\n    ├── Dependency parametrization.md\n    ├── Dependency rejection.md\n    ├── Domain-centric workflow.md\n    ├── En la lógica de dominio hay que seguir los principios de diseño para generar código  puro .md\n    ├── Estrategias para gestionar dependencias.md\n    ├── Functional Core, Imperative Shell Architecture.md\n    ├── Hay mantener el código IO alejado de la lógica de negocio.md\n    ├── Las dependencias son elementos que introducen no-determinismo a una operación.md\n    ├── Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ├── Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    └── Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n\nNOTES/Code smells en tu código core.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Que son?\nSon síntomas de que tu código tiene alguna operación IO oculta o al menos no explítica.\n## ¿Cuáles son?\n* Hay algún proceso asíncrono\n* Se lanza alguna excepción\n* Tienes lanzamiento de excepciones para gestionar el flujo de ejecución en lugar de retornar un valor \n```\nNOTES/Hay mantener el código IO alejado de la lógica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\n* El código IO no forma parte del dominio. Además, cuando se entremezclan dificulta la comprensión de la lógica de negocio.\n* El código IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El código IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Domain-centric workflow.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"2.44\"\nminutoFin: \"6.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nUn workflow es equivalente a una historia de usuario. Desde esto, [[Scott Wlaschin]] propone trabajar en una arquitectura [[Domain Driving Desing]] porque pone la lógica de dominio en el centro y la lógica IO en los bordes. Por tanto un domain-centric workflow se trata de un \"slice\" cómo se ilustra en la siguiente imagen:\n![[Pasted image 20250709203856.png]]\nCon esta arquitectura, [[Scott Wlaschin]] consigue cumplir principio de diseño de [[Hay mantener el código IO alejado de la lógica de negocio]]  de una manera efectiva.\nUn caso de uso se ilustra a continuación:\n![[Pasted image 20250709204031.png]]\n```\nNOTES/En la lógica de dominio hay que seguir los principios de diseño para generar código  puro .md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"6.17\"\nminutoFin: \"10.45\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son los principios?\n* El código debe ser comprensible. Esto significa que:\n\t* Todo debe ser explicitamente dado por los inputs para que no nos preguntemos ¿Qué es lo que necesitamos para que se haga la operación X?\n\t* Debe haber un output, para que entendamos cual es el resultado de la operación y podamos verificarlo\n* El código debe ser determinista: Dados unos inputs, siempre debemos obtener los mismos outputs\n* No tiene side-effects: No se produce ningún proceso adicional que salga del ámbito del proceso y que además no vaya al \"exterior\" de la applicación (IO)\n```\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el código de domino está en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enfásis en que [[En la lógica de dominio hay que seguir los principios de diseño para generar código \"puro\"]] y [[Hay mantener el código IO alejado de la lógica de negocio]] y este será impuro e imperativo.\nAdemás, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicación en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el código es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el código de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"18.32\"\nminutoFin: \"21.42\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es esto?\n[[Scott Wlaschin]] propone, en lugar de crear una interfaz o abstracción desde la cual hacer varias implementaciones, simplemente reemplazar el código IO de los bordes y mantener el código de dominio. De esta manera, propone trabajar como si piezas de lego se trataran. Al final, el reemplazo de código IO seguiran recuperando o mandando los mismos datos y por tanto el código de dominio le dará igual mientras estos den los inputs y procesen los outputs de este.\nUn ejemplo de esto es lo siguiente:\n![[Pasted image 20250709212804.png]]\n![[Pasted image 20250709212824.png]]\n![[Pasted image 20250709212849.png]]\n```\nNOTES/Beneficios de escribir código puro para la lógica de dominio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"21.54\"\nminutoFin: \"33.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n* Los inputs y output son explicitos y por tanto es comprensible cómo usarlo\n* Es fácil de hacer testing\n* No tiene que lidiar con procesos asincronos porque no hay procesos IO\n* Dado que no trabaja con procesos IO que pueden fallar, no hay que lidiar con excepciones\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la lógica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enfásis en que [[System Under Test (SUT)]] debe ser una unidad lógica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nSegún [[Scott Wlaschin]], esto no pertenece a la lógica de negocio, y debe ocurrir antes de entrar en juego la lógica de negocio. Esto evita realizar programación defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el código porque se separa operaciones de valor para el negocio de las validaciones.\n## ¿Qué ocurre si no hay algo válido?\nSe hace skip de la lógica de negocio porque se entiende que no tiene sentido procesar información invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situación\n![[Pasted image 20250709232523.png]]\n```\nNOTES/Las dependencias son elementos que introducen no-determinismo a una operación.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"43.47\"\nminutoFin: \"44.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nPor qué las necesitamos para completar los [[Domain-centric workflow]] y dar valor verdadero, es decir, son elementos que involucran procesos IO.\n```\nNOTES/Estrategias para gestionar dependencias.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"44.45\"\nminutoFin: \"45.49\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n* [[Dependency rejection]]: No tener, mantener el código puro\n* [[Dependency retention]]: No preocuparse por esto\n* [[Dependency injection]]:  Pasarlas por constructor a las clases\n* [[Dependency parametrization]]: Pasarlas como input a las funciones o métodos\n* [[Dependency interpretation]]: Crear un lenguaje de dominio específico e interpretarlo\n```\nNOTES/Dependency rejection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"45.53\"\nminutoFin: \"46.57\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]] donde [[Mark Seeman]] enuncia lo siguiente:\n>No tener dependencias en el código puro core\nLa ventaja de esto es que es fácil de comprender y de testear. Y aunque [[Scott Wlaschin]] expone como desventaja la necesidad de crear código (enum y records) para exponer las decisiones para que le el código Shell imperativo sepa que operación IO ejecutar, para él es una ventaja porque genera documentación viva y hace más fácil de entender el código\n```\nNOTES/Dependency injection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n>Pasar las dependencias por constructor a una clase como un todo\nHacer esto puede provocar que una clase tenga una serie de dependencias que aparentemente no tienen sentido juntas pero es necesario porque la clase tiene algún método que usa cada una de una manera separada.\nPor otro lado, al tener que borrar algo de una interfaz, no es tan directo saber si en otra parte donde es injectada se usa y por tanto puede ocasionar un miedo a la  rotura y por tanto en lugar de optimizarlo, crecen hasta ser insostenibles y es necesario hacer un análisis importante para poder realizarlo.\n![[Pasted image 20250710001420.png]]\nEs por esto, que este en lugar de este enfoque clásico, [[Scott Wlaschin]] prefiere [[Dependency parametrization]].\nNo obstante, es posiblemente la estrategia más conocida y estándar (la aplican los frameworks normalmente)\n```\nNOTES/Dependency parametrization.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n> Pasar solo las dependencias necesarias para una particular función/método\nLas dependencias en este caso no son interfaces, sino cosas que hace una operación concreta:\n![[Pasted image 20250710001117.png]]\nDe esta manera, el código se autodocumenta y queda claro lo que necesita de inputs la operación y lo que devuelve.\nSin embargo, con código que anidado se complica, [[Scott Wlaschin]] aconseja usar esta estrategia en lugar de [[Dependecy Rejection]] cuando no es posible mover a los border los procesos IO por la razón que sea\n```\nNOTES/Dependency interpretation.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"55.45\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]]. Esta propone:\n>Reemplazar las llamadas a las dependencias con instrucciones que serán interpretadas después por un \"interprete\" que será el que ejecutara el código IO\n![[Pasted image 20250710002445.png]]\nLa ventaja de esto es que se crea una API orientado al dominio, no hay IO pues se sustituye por una instrucción con la cual se puede operar y se puede hacer un proceso de optimización, pues puede mergearse estructura de datos  \nLo malo es que terriblemente complicado y solo soporta un conjunto limitado de operaciones. Twitter Stich y Facebook Haxl \n```\nBIBLIOGRAPHY/CONFERENCE-TALKS/Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: NDC Conferences London 2024\n```\n## Notas\n|File15|minutoInicio|minutoFin|\n|---|---|---|\n|[Code smells en tu código core](NOTES/Code smells en tu código core.md)|-|-|\n|[Hay mantener el código IO alejado de la lógica de negocio](NOTES/Hay mantener el código IO alejado de la lógica de negocio.md)|0.00|2.40|\n|[Domain-centric workflow](NOTES/Domain-centric workflow.md)|2.44|6.10|\n|[En la lógica de dominio hay que seguir los principios de diseño para generar código puro](NOTES/En la lógica de dominio hay que seguir los principios de diseño para generar código  puro .md)|6.17|10.45|\n|[Functional Core, Imperative Shell Architecture](NOTES/Functional Core, Imperative Shell Architecture.md)|12.00|-|\n|[Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones](NOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md)|18.32|21.42|\n|[Beneficios de escribir código puro para la lógica de dominio](NOTES/Beneficios de escribir código puro para la lógica de dominio.md)|21.54|33.10|\n|[Los unit tests prueban el core funcional y las integration tests prueban los workflows](NOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md)|33.07|36.23|\n|[Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio)](NOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core \\(dominio\\).md)|36.27|-|\n|[Las dependencias son elementos que introducen no-determinismo a una operación](NOTES/Las dependencias son elementos que introducen no-determinismo a una operación.md)|43.47|44.44|\n|[Estrategias para gestionar dependencias](NOTES/Estrategias para gestionar dependencias.md)|44.45|45.49|\n|[Dependency rejection](NOTES/Dependency rejection.md)|45.53|46.57|\n|[Dependency injection](NOTES/Dependency injection.md)|48.05|55.44|\n|[Dependency parametrization](NOTES/Dependency parametrization.md)|48.05|55.44|\n|[Dependency interpretation](NOTES/Dependency interpretation.md)|55.45|-|\n```"},{"type":"text","text":"Quiero que me hagas un artículo con todo este contenido"}]}]},"responses":[{"timestamp":1752162043987,"id":"chatcmpl-BrnfRWBQPqaxYVcFJ8lsWTwlMfKs6","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"# Arquitectura Functional Core, Imperative Shell: Cómo Mover el Código IO a los Bordes de tu Aplicación\n\nEn el desarrollo de software, especialmente en sistemas complejos, separar la lógica de negocio de los efectos secundarios (como operaciones de entrada/salida o IO) es crucial para mantener el código limpio, comprensible y testeable. Esta separación se vuelve más importante cuando pretendemos que nuestra aplicación sea robusta, predecible y fácil de mantener. En este sentido, Scott Wlaschin, en su charla para NDC Conferences London 2024 titulada *\"Moving IO to the edges of your app - Functional Core Imperative Shell\"*, propone un enfoque arquitectónico muy efectivo que nos ayuda a conseguir este objetivo.\n\nEste artículo resume las ideas principales de esta charla y aporta una visión clara de cómo implementar esta arquitectura y gestionar sus dependencias adecuadamente.\n\n---\n\n## ¿Qué es la Arquitectura Functional Core, Imperative Shell?\n\nLa arquitectura **Functional Core, Imperative Shell** es un patrón que sitúa el **código funcional puro (core)** en el centro de la aplicación, y el código **imperativo y con efectos secundarios (shell)** en los bordes o periferia. Esto es similar en espíritu a la Arquitectura Hexagonal, pero hace especial hincapié en la pureza y determinismo del núcleo.\n\n- **Core funcional puro:** Es la lógica de negocio. Debe seguir principios de diseño que garanticen que el código sea **determinista**, **sin efectos secundarios**, y **totalmente comprensible**. Es decir, dados ciertos inputs, siempre entrega los mismos outputs, sin interactuar con el mundo exterior.\n\n- **Shell imperativo:** Es la parte que interactúa con el entorno: llamadas a bases de datos, servicios externos, operaciones IO, manejo de excepciones externas, asincronía, etc. Esta capa es inherentemente no determinista y produce efectos secundarios.\n\nSeparando las responsabilidades de esta forma, podemos beneficiar la mantenibilidad, el testing y la comprensión del sistema.\n\n---\n\n## Por qué mantener el código IO alejado de la lógica de negocio\n\nSegún Scott, es fundamental tener bien separadas las responsabilidades porque:\n\n- El código IO **no forma parte del dominio** y entremezclarlo con la lógica de negocio dificulta su comprensión.\n- El código IO es **no determinista**: la misma operación con los mismos inputs puede arrojar distintos resultados.\n- El código IO puede fallar y lanzar excepciones, lo que requiere una lógica de manejo diferente que puede ensuciar la lógica de negocio.\n\nSeparando, garantizamos que el dominio sea siempre predecible y testeable.\n\n---\n\n## Principios para escribir código puro en la lógica de dominio\n\nPara que un código sea considerado *puro* dentro del dominio, debe seguir ciertos principios de diseño:\n\n- **Comprensible:** toda la información necesaria para ejecutar una operación debe estar explícitamente dada como entrada. No debe haber dependencias ocultas ni variables globales.\n- **Determinista:** para un conjunto de inputs, siempre debe producir los mismos outputs.\n- **Sin efectos secundarios:** no debe realizar operaciones que modifiquen el estado fuera de su ámbito o ejecuten IO.\n\nAplicando estos principios se reduce la complejidad y se facilita el testing.\n\n---\n\n## Domain-centric workflow: el workflow centrado en el dominio\n\nUn *workflow* puede verse como una historia de usuario. Scott propone abordar la lógica organizando el workflow centrado en el dominio, donde toda la lógica de negocio está en el núcleo, y el resto (como leer o guardar datos) está fuera.\n\n![Domain-centric workflow](Pasted_image_20250709203856.png)\n\nEsta técnica ayuda a mantener el principio de mantener el código IO alejado del dominio, y facilita que el sistema evolucione y mantenga claridad.\n\n---\n\n## Beneficios de escribir código puro para la lógica de dominio\n\n- **Inputs y outputs explícitos:** mejora la comprensión.\n- **Facilidad para testing:** no necesita mocks ni dobles de prueba complicados.\n- **No lidiar con asincronía:** ya que toda la asincronía está confinada a la shell imperativa.\n- **No manejo de excepciones por fallas IO:** que simplifica la lógica interna.\n\n---\n\n## Code smells o olores de código en tu core funcional\n\nAlgunos síntomas que indican que tu core contiene procesos IO o efectos secundarios no deseados son:\n\n- Presencia de procesos asíncronos directamente en el core.\n- Lanzamiento de excepciones para controlar el flujo (en lugar de retornar valores).\n- Cualquier efecto que afecte el estado externo o que no sea determinista.\n\nDetectar estos olores es importante para mantener el core limpio.\n\n---\n\n## Validaciones en la frontera entre IO y el core\n\nLas validaciones de datos deben realizarse al **ingresar a la frontera entre IO y el core** de dominio. Esto evita hacer programación defensiva dentro del dominio y garantiza que éste trabaje siempre con datos válidos, simplificando el código de negocio.\n\nSi los datos no son válidos, el flujo debe saltarse la lógica del dominio y manejar el error o la comunicación con el usuario desde la parte IO.\n\n---\n\n## Testing: unit tests y integration tests según la arquitectura\n\nEn este enfoque:\n\n- Los **unit tests** prueban exclusivamente el core funcional, porque es puramente funcional y determinista.\n- Las **integration tests** prueban los workflows completos, incluyendo el shell imperativo.\n\nEsta división evita la necesidad de mocks complejos para la lógica de negocio. El principal sujeto bajo prueba (SUT) debe ser siempre una unidad lógica que aporta valor real al negocio.\n\n---\n\n## Gestión de dependencias en el código funcional\n\nLas dependencias son aquellas partes del sistema que introducen no-determinismo y generalmente involucran IO. Scott Wlaschin describe varias estrategias para gestionarlas:\n\n1. **Dependency Rejection (rechazo de dependencias):**  \n   No tener dependencias en el core funcional. Esto simplifica la comprensión y testing, aunque puede requerir crear estructuras específicas para comunicar al shell qué IO ejecutar.\n\n2. **Dependency Injection:**  \n   Pasar las dependencias por constructor a las clases. Esta es la estrategia clásica y ampliamente usada, pero puede generar acoplamientos y crecimiento descontrolado de dependencias en las clases.\n\n3. **Dependency Parametrization:**  \n   Pasar solo las dependencias necesarias para una función o método específico. Ayuda a una mejor autodocumentación y manejo granular, y Scott la prefiere sobre la inyección tradicional.\n\n4. **Dependency Interpretation:**  \n   En lugar de ejecutar directamente IO, generar instrucciones que serán interpretadas posteriormente por un \"intérprete\" que realizará el IO. Esto crea un API orientado al dominio, que puede optimizar operaciones, pero es complejo y limitado en scope.\n\n---\n\n## Reemplazo del código IO sin interfaces\n\nEn lugar de crear interfaces abstractas para permitir la variabilidad de implementaciones IO, Scott sugiere simplemente **reemplazar el código IO en los bordes**. Mientras el core funcional reciba los mismos inputs y produzca los mismos outputs, no importa cómo se haga el IO.\n\nEsto funciona como piezas de LEGO: el código puro permanece inalterado mientras se intercambian los bloques de IO según necesidades.\n\n---\n\n## Conclusión\n\nLa arquitectura **Functional Core, Imperative Shell** promueve un diseño claramente separado donde:\n\n- La lógica de negocio se mantiene pura, determinista y fácilmente testeable.\n- El código imperativo y no determinista, con efectos secundarios, se aísla en los bordes.\n- Las dependencias con IO se gestionan con estrategias pensadas para minimizar el impacto en el core.\n- Las validaciones y excepciones se gestionan antes de que los datos ingresen a la lógica de dominio.\n\nAdoptar este patrón no solo mejora la calidad del software sino que facilita el desarrollo iterativo, la mantenibilidad y la escalabilidad de sistemas complejos.\n\nPara profundizar en este enfoque, se recomienda consultar la charla original de Scott Wlaschin en NDC Conferences London 2024 ([enlace aquí](https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2)) y explorar ejemplos prácticos que ilustren cada uno de estos conceptos.\n\n---\n\n**Referencias:**\n\n- Wlaschin, Scott. *Moving IO to the edges of your app - Functional Core Imperative Shell*, NDC Conferences London 2024.\n- Seeman, Mark. Estrategias para gestionar dependencias.\n\n---\n\nEste artículo sintetiza y organiza los conceptos y recomendaciones que Scott Wlaschin expone para ayudarnos a construir aplicaciones más limpias, robustas y mantenibles siguiendo el patrón Functional Core, Imperative Shell."}}],"usage":{},"raw":{"id":"chatcmpl-BrnfRWBQPqaxYVcFJ8lsWTwlMfKs6","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"# Arquitectura Functional Core, Imperative Shell: Cómo Mover el Código IO a los Bordes de tu Aplicación\n\nEn el desarrollo de software, especialmente en sistemas complejos, separar la lógica de negocio de los efectos secundarios (como operaciones de entrada/salida o IO) es crucial para mantener el código limpio, comprensible y testeable. Esta separación se vuelve más importante cuando pretendemos que nuestra aplicación sea robusta, predecible y fácil de mantener. En este sentido, Scott Wlaschin, en su charla para NDC Conferences London 2024 titulada *\"Moving IO to the edges of your app - Functional Core Imperative Shell\"*, propone un enfoque arquitectónico muy efectivo que nos ayuda a conseguir este objetivo.\n\nEste artículo resume las ideas principales de esta charla y aporta una visión clara de cómo implementar esta arquitectura y gestionar sus dependencias adecuadamente.\n\n---\n\n## ¿Qué es la Arquitectura Functional Core, Imperative Shell?\n\nLa arquitectura **Functional Core, Imperative Shell** es un patrón que sitúa el **código funcional puro (core)** en el centro de la aplicación, y el código **imperativo y con efectos secundarios (shell)** en los bordes o periferia. Esto es similar en espíritu a la Arquitectura Hexagonal, pero hace especial hincapié en la pureza y determinismo del núcleo.\n\n- **Core funcional puro:** Es la lógica de negocio. Debe seguir principios de diseño que garanticen que el código sea **determinista**, **sin efectos secundarios**, y **totalmente comprensible**. Es decir, dados ciertos inputs, siempre entrega los mismos outputs, sin interactuar con el mundo exterior.\n\n- **Shell imperativo:** Es la parte que interactúa con el entorno: llamadas a bases de datos, servicios externos, operaciones IO, manejo de excepciones externas, asincronía, etc. Esta capa es inherentemente no determinista y produce efectos secundarios.\n\nSeparando las responsabilidades de esta forma, podemos beneficiar la mantenibilidad, el testing y la comprensión del sistema.\n\n---\n\n## Por qué mantener el código IO alejado de la lógica de negocio\n\nSegún Scott, es fundamental tener bien separadas las responsabilidades porque:\n\n- El código IO **no forma parte del dominio** y entremezclarlo con la lógica de negocio dificulta su comprensión.\n- El código IO es **no determinista**: la misma operación con los mismos inputs puede arrojar distintos resultados.\n- El código IO puede fallar y lanzar excepciones, lo que requiere una lógica de manejo diferente que puede ensuciar la lógica de negocio.\n\nSeparando, garantizamos que el dominio sea siempre predecible y testeable.\n\n---\n\n## Principios para escribir código puro en la lógica de dominio\n\nPara que un código sea considerado *puro* dentro del dominio, debe seguir ciertos principios de diseño:\n\n- **Comprensible:** toda la información necesaria para ejecutar una operación debe estar explícitamente dada como entrada. No debe haber dependencias ocultas ni variables globales.\n- **Determinista:** para un conjunto de inputs, siempre debe producir los mismos outputs.\n- **Sin efectos secundarios:** no debe realizar operaciones que modifiquen el estado fuera de su ámbito o ejecuten IO.\n\nAplicando estos principios se reduce la complejidad y se facilita el testing.\n\n---\n\n## Domain-centric workflow: el workflow centrado en el dominio\n\nUn *workflow* puede verse como una historia de usuario. Scott propone abordar la lógica organizando el workflow centrado en el dominio, donde toda la lógica de negocio está en el núcleo, y el resto (como leer o guardar datos) está fuera.\n\n![Domain-centric workflow](Pasted_image_20250709203856.png)\n\nEsta técnica ayuda a mantener el principio de mantener el código IO alejado del dominio, y facilita que el sistema evolucione y mantenga claridad.\n\n---\n\n## Beneficios de escribir código puro para la lógica de dominio\n\n- **Inputs y outputs explícitos:** mejora la comprensión.\n- **Facilidad para testing:** no necesita mocks ni dobles de prueba complicados.\n- **No lidiar con asincronía:** ya que toda la asincronía está confinada a la shell imperativa.\n- **No manejo de excepciones por fallas IO:** que simplifica la lógica interna.\n\n---\n\n## Code smells o olores de código en tu core funcional\n\nAlgunos síntomas que indican que tu core contiene procesos IO o efectos secundarios no deseados son:\n\n- Presencia de procesos asíncronos directamente en el core.\n- Lanzamiento de excepciones para controlar el flujo (en lugar de retornar valores).\n- Cualquier efecto que afecte el estado externo o que no sea determinista.\n\nDetectar estos olores es importante para mantener el core limpio.\n\n---\n\n## Validaciones en la frontera entre IO y el core\n\nLas validaciones de datos deben realizarse al **ingresar a la frontera entre IO y el core** de dominio. Esto evita hacer programación defensiva dentro del dominio y garantiza que éste trabaje siempre con datos válidos, simplificando el código de negocio.\n\nSi los datos no son válidos, el flujo debe saltarse la lógica del dominio y manejar el error o la comunicación con el usuario desde la parte IO.\n\n---\n\n## Testing: unit tests y integration tests según la arquitectura\n\nEn este enfoque:\n\n- Los **unit tests** prueban exclusivamente el core funcional, porque es puramente funcional y determinista.\n- Las **integration tests** prueban los workflows completos, incluyendo el shell imperativo.\n\nEsta división evita la necesidad de mocks complejos para la lógica de negocio. El principal sujeto bajo prueba (SUT) debe ser siempre una unidad lógica que aporta valor real al negocio.\n\n---\n\n## Gestión de dependencias en el código funcional\n\nLas dependencias son aquellas partes del sistema que introducen no-determinismo y generalmente involucran IO. Scott Wlaschin describe varias estrategias para gestionarlas:\n\n1. **Dependency Rejection (rechazo de dependencias):**  \n   No tener dependencias en el core funcional. Esto simplifica la comprensión y testing, aunque puede requerir crear estructuras específicas para comunicar al shell qué IO ejecutar.\n\n2. **Dependency Injection:**  \n   Pasar las dependencias por constructor a las clases. Esta es la estrategia clásica y ampliamente usada, pero puede generar acoplamientos y crecimiento descontrolado de dependencias en las clases.\n\n3. **Dependency Parametrization:**  \n   Pasar solo las dependencias necesarias para una función o método específico. Ayuda a una mejor autodocumentación y manejo granular, y Scott la prefiere sobre la inyección tradicional.\n\n4. **Dependency Interpretation:**  \n   En lugar de ejecutar directamente IO, generar instrucciones que serán interpretadas posteriormente por un \"intérprete\" que realizará el IO. Esto crea un API orientado al dominio, que puede optimizar operaciones, pero es complejo y limitado en scope.\n\n---\n\n## Reemplazo del código IO sin interfaces\n\nEn lugar de crear interfaces abstractas para permitir la variabilidad de implementaciones IO, Scott sugiere simplemente **reemplazar el código IO en los bordes**. Mientras el core funcional reciba los mismos inputs y produzca los mismos outputs, no importa cómo se haga el IO.\n\nEsto funciona como piezas de LEGO: el código puro permanece inalterado mientras se intercambian los bloques de IO según necesidades.\n\n---\n\n## Conclusión\n\nLa arquitectura **Functional Core, Imperative Shell** promueve un diseño claramente separado donde:\n\n- La lógica de negocio se mantiene pura, determinista y fácilmente testeable.\n- El código imperativo y no determinista, con efectos secundarios, se aísla en los bordes.\n- Las dependencias con IO se gestionan con estrategias pensadas para minimizar el impacto en el core.\n- Las validaciones y excepciones se gestionan antes de que los datos ingresen a la lógica de dominio.\n\nAdoptar este patrón no solo mejora la calidad del software sino que facilita el desarrollo iterativo, la mantenibilidad y la escalabilidad de sistemas complejos.\n\nPara profundizar en este enfoque, se recomienda consultar la charla original de Scott Wlaschin en NDC Conferences London 2024 ([enlace aquí](https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2)) y explorar ejemplos prácticos que ilustren cada uno de estos conceptos.\n\n---\n\n**Referencias:**\n\n- Wlaschin, Scott. *Moving IO to the edges of your app - Functional Core Imperative Shell*, NDC Conferences London 2024.\n- Seeman, Mark. Estrategias para gestionar dependencias.\n\n---\n\nEste artículo sintetiza y organiza los conceptos y recomendaciones que Scott Wlaschin expone para ayudarnos a construir aplicaciones más limpias, robustas y mantenibles siguiendo el patrón Functional Core, Imperative Shell."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752161883212-1752161883212","thread_key":"Untitled Chat 1752161883212","stream":true,"context_key":"1752161883212","class_name":"SmartCompletion","user_message":"Quiero que me hagas un artículo con todo este contenido","new_user_message":true},
"smart_completions:Untitled Chat 1752161929380-1752163917737": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero que me hagas un artículo con todo este contenido"},{"type":"text","text":"├── BIBLIOGRAPHY/CONFERENCE-TALKS/\n│   └── Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n└── NOTES/\n    ├── Beneficios de escribir código puro para la lógica de dominio.md\n    ├── Code smells en tu código core.md\n    ├── Dependency injection.md\n    ├── Dependency interpretation.md\n    ├── Dependency parametrization.md\n    ├── Dependency rejection.md\n    ├── Domain-centric workflow.md\n    ├── En la lógica de dominio hay que seguir los principios de diseño para generar código  puro .md\n    ├── Estrategias para gestionar dependencias.md\n    ├── Functional Core, Imperative Shell Architecture.md\n    ├── Hay mantener el código IO alejado de la lógica de negocio.md\n    ├── Las dependencias son elementos que introducen no-determinismo a una operación.md\n    ├── Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ├── Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    └── Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n\nNOTES/Code smells en tu código core.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Que son?\nSon síntomas de que tu código tiene alguna operación IO oculta o al menos no explítica.\n## ¿Cuáles son?\n* Hay algún proceso asíncrono\n* Se lanza alguna excepción\n* Tienes lanzamiento de excepciones para gestionar el flujo de ejecución en lugar de retornar un valor \n```\nNOTES/Hay mantener el código IO alejado de la lógica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\n* El código IO no forma parte del dominio. Además, cuando se entremezclan dificulta la comprensión de la lógica de negocio.\n* El código IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El código IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Domain-centric workflow.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"2.44\"\nminutoFin: \"6.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nUn workflow es equivalente a una historia de usuario. Desde esto, [[Scott Wlaschin]] propone trabajar en una arquitectura [[Domain Driving Desing]] porque pone la lógica de dominio en el centro y la lógica IO en los bordes. Por tanto un domain-centric workflow se trata de un \"slice\" cómo se ilustra en la siguiente imagen:\n![[Pasted image 20250709203856.png]]\nCon esta arquitectura, [[Scott Wlaschin]] consigue cumplir principio de diseño de [[Hay mantener el código IO alejado de la lógica de negocio]]  de una manera efectiva.\nUn caso de uso se ilustra a continuación:\n![[Pasted image 20250709204031.png]]\n```\nNOTES/En la lógica de dominio hay que seguir los principios de diseño para generar código  puro .md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"6.17\"\nminutoFin: \"10.45\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son los principios?\n* El código debe ser comprensible. Esto significa que:\n\t* Todo debe ser explicitamente dado por los inputs para que no nos preguntemos ¿Qué es lo que necesitamos para que se haga la operación X?\n\t* Debe haber un output, para que entendamos cual es el resultado de la operación y podamos verificarlo\n* El código debe ser determinista: Dados unos inputs, siempre debemos obtener los mismos outputs\n* No tiene side-effects: No se produce ningún proceso adicional que salga del ámbito del proceso y que además no vaya al \"exterior\" de la applicación (IO)\n```\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el código de domino está en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enfásis en que [[En la lógica de dominio hay que seguir los principios de diseño para generar código \"puro\"]] y [[Hay mantener el código IO alejado de la lógica de negocio]] y este será impuro e imperativo.\nAdemás, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicación en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el código es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el código de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"18.32\"\nminutoFin: \"21.42\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es esto?\n[[Scott Wlaschin]] propone, en lugar de crear una interfaz o abstracción desde la cual hacer varias implementaciones, simplemente reemplazar el código IO de los bordes y mantener el código de dominio. De esta manera, propone trabajar como si piezas de lego se trataran. Al final, el reemplazo de código IO seguiran recuperando o mandando los mismos datos y por tanto el código de dominio le dará igual mientras estos den los inputs y procesen los outputs de este.\nUn ejemplo de esto es lo siguiente:\n![[Pasted image 20250709212804.png]]\n![[Pasted image 20250709212824.png]]\n![[Pasted image 20250709212849.png]]\n```\nNOTES/Beneficios de escribir código puro para la lógica de dominio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"21.54\"\nminutoFin: \"33.10\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n* Los inputs y output son explicitos y por tanto es comprensible cómo usarlo\n* Es fácil de hacer testing\n* No tiene que lidiar con procesos asincronos porque no hay procesos IO\n* Dado que no trabaja con procesos IO que pueden fallar, no hay que lidiar con excepciones\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la lógica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enfásis en que [[System Under Test (SUT)]] debe ser una unidad lógica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nSegún [[Scott Wlaschin]], esto no pertenece a la lógica de negocio, y debe ocurrir antes de entrar en juego la lógica de negocio. Esto evita realizar programación defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el código porque se separa operaciones de valor para el negocio de las validaciones.\n## ¿Qué ocurre si no hay algo válido?\nSe hace skip de la lógica de negocio porque se entiende que no tiene sentido procesar información invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situación\n![[Pasted image 20250709232523.png]]\n```\nNOTES/Las dependencias son elementos que introducen no-determinismo a una operación.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"43.47\"\nminutoFin: \"44.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nPor qué las necesitamos para completar los [[Domain-centric workflow]] y dar valor verdadero, es decir, son elementos que involucran procesos IO.\n```\nNOTES/Estrategias para gestionar dependencias.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"44.45\"\nminutoFin: \"45.49\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cuáles son?\n* [[Dependency rejection]]: No tener, mantener el código puro\n* [[Dependency retention]]: No preocuparse por esto\n* [[Dependency injection]]:  Pasarlas por constructor a las clases\n* [[Dependency parametrization]]: Pasarlas como input a las funciones o métodos\n* [[Dependency interpretation]]: Crear un lenguaje de dominio específico e interpretarlo\n```\nNOTES/Dependency rejection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"45.53\"\nminutoFin: \"46.57\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]] donde [[Mark Seeman]] enuncia lo siguiente:\n>No tener dependencias en el código puro core\nLa ventaja de esto es que es fácil de comprender y de testear. Y aunque [[Scott Wlaschin]] expone como desventaja la necesidad de crear código (enum y records) para exponer las decisiones para que le el código Shell imperativo sepa que operación IO ejecutar, para él es una ventaja porque genera documentación viva y hace más fácil de entender el código\n```\nNOTES/Dependency injection.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n>Pasar las dependencias por constructor a una clase como un todo\nHacer esto puede provocar que una clase tenga una serie de dependencias que aparentemente no tienen sentido juntas pero es necesario porque la clase tiene algún método que usa cada una de una manera separada.\nPor otro lado, al tener que borrar algo de una interfaz, no es tan directo saber si en otra parte donde es injectada se usa y por tanto puede ocasionar un miedo a la  rotura y por tanto en lugar de optimizarlo, crecen hasta ser insostenibles y es necesario hacer un análisis importante para poder realizarlo.\n![[Pasted image 20250710001420.png]]\nEs por esto, que este en lugar de este enfoque clásico, [[Scott Wlaschin]] prefiere [[Dependency parametrization]].\nNo obstante, es posiblemente la estrategia más conocida y estándar (la aplican los frameworks normalmente)\n```\nNOTES/Dependency parametrization.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"48.05\"\nminutoFin: \"55.44\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]] que propone:\n> Pasar solo las dependencias necesarias para una particular función/método\nLas dependencias en este caso no son interfaces, sino cosas que hace una operación concreta:\n![[Pasted image 20250710001117.png]]\nDe esta manera, el código se autodocumenta y queda claro lo que necesita de inputs la operación y lo que devuelve.\nSin embargo, con código que anidado se complica, [[Scott Wlaschin]] aconseja usar esta estrategia en lugar de [[Dependecy Rejection]] cuando no es posible mover a los border los procesos IO por la razón que sea\n```\nNOTES/Dependency interpretation.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"55.45\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una de las [[Estrategias para gestionar dependencias]]. Esta propone:\n>Reemplazar las llamadas a las dependencias con instrucciones que serán interpretadas después por un \"interprete\" que será el que ejecutara el código IO\n![[Pasted image 20250710002445.png]]\nLa ventaja de esto es que se crea una API orientado al dominio, no hay IO pues se sustituye por una instrucción con la cual se puede operar y se puede hacer un proceso de optimización, pues puede mergearse estructura de datos  \nLo malo es que terriblemente complicado y solo soporta un conjunto limitado de operaciones. Twitter Stich y Facebook Haxl \n```\nBIBLIOGRAPHY/CONFERENCE-TALKS/Moving IO to the edges of your app -  Functional Core Imperative Shell.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: NDC Conferences London 2024\n```\n## Notas\n|File15|minutoInicio|minutoFin|\n|---|---|---|\n|[Code smells en tu código core](NOTES/Code smells en tu código core.md)|-|-|\n|[Hay mantener el código IO alejado de la lógica de negocio](NOTES/Hay mantener el código IO alejado de la lógica de negocio.md)|0.00|2.40|\n|[Domain-centric workflow](NOTES/Domain-centric workflow.md)|2.44|6.10|\n|[En la lógica de dominio hay que seguir los principios de diseño para generar código puro](NOTES/En la lógica de dominio hay que seguir los principios de diseño para generar código  puro .md)|6.17|10.45|\n|[Functional Core, Imperative Shell Architecture](NOTES/Functional Core, Imperative Shell Architecture.md)|12.00|-|\n|[Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones](NOTES/Reemplaza simplemente el tipo de IO en lugar de crear interfaces para cambiar diferentes implementaciones.md)|18.32|21.42|\n|[Beneficios de escribir código puro para la lógica de dominio](NOTES/Beneficios de escribir código puro para la lógica de dominio.md)|21.54|33.10|\n|[Los unit tests prueban el core funcional y las integration tests prueban los workflows](NOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md)|33.07|36.23|\n|[Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio)](NOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core \\(dominio\\).md)|36.27|-|\n|[Las dependencias son elementos que introducen no-determinismo a una operación](NOTES/Las dependencias son elementos que introducen no-determinismo a una operación.md)|43.47|44.44|\n|[Estrategias para gestionar dependencias](NOTES/Estrategias para gestionar dependencias.md)|44.45|45.49|\n|[Dependency rejection](NOTES/Dependency rejection.md)|45.53|46.57|\n|[Dependency injection](NOTES/Dependency injection.md)|48.05|55.44|\n|[Dependency parametrization](NOTES/Dependency parametrization.md)|48.05|55.44|\n|[Dependency interpretation](NOTES/Dependency interpretation.md)|55.45|-|\n```"},{"type":"text","text":"Quiero que me hagas un artículo con todo este contenido"}]},{"role":"assistant","content":"# Arquitectura Functional Core, Imperative Shell: Cómo Mover el Código IO a los Bordes de tu Aplicación\n\nEn el desarrollo de software, especialmente en sistemas complejos, separar la lógica de negocio de los efectos secundarios (como operaciones de entrada/salida o IO) es crucial para mantener el código limpio, comprensible y testeable. Esta separación se vuelve más importante cuando pretendemos que nuestra aplicación sea robusta, predecible y fácil de mantener. En este sentido, Scott Wlaschin, en su charla para NDC Conferences London 2024 titulada *\"Moving IO to the edges of your app - Functional Core Imperative Shell\"*, propone un enfoque arquitectónico muy efectivo que nos ayuda a conseguir este objetivo.\n\nEste artículo resume las ideas principales de esta charla y aporta una visión clara de cómo implementar esta arquitectura y gestionar sus dependencias adecuadamente.\n\n---\n\n## ¿Qué es la Arquitectura Functional Core, Imperative Shell?\n\nLa arquitectura **Functional Core, Imperative Shell** es un patrón que sitúa el **código funcional puro (core)** en el centro de la aplicación, y el código **imperativo y con efectos secundarios (shell)** en los bordes o periferia. Esto es similar en espíritu a la Arquitectura Hexagonal, pero hace especial hincapié en la pureza y determinismo del núcleo.\n\n- **Core funcional puro:** Es la lógica de negocio. Debe seguir principios de diseño que garanticen que el código sea **determinista**, **sin efectos secundarios**, y **totalmente comprensible**. Es decir, dados ciertos inputs, siempre entrega los mismos outputs, sin interactuar con el mundo exterior.\n\n- **Shell imperativo:** Es la parte que interactúa con el entorno: llamadas a bases de datos, servicios externos, operaciones IO, manejo de excepciones externas, asincronía, etc. Esta capa es inherentemente no determinista y produce efectos secundarios.\n\nSeparando las responsabilidades de esta forma, podemos beneficiar la mantenibilidad, el testing y la comprensión del sistema.\n\n---\n\n## Por qué mantener el código IO alejado de la lógica de negocio\n\nSegún Scott, es fundamental tener bien separadas las responsabilidades porque:\n\n- El código IO **no forma parte del dominio** y entremezclarlo con la lógica de negocio dificulta su comprensión.\n- El código IO es **no determinista**: la misma operación con los mismos inputs puede arrojar distintos resultados.\n- El código IO puede fallar y lanzar excepciones, lo que requiere una lógica de manejo diferente que puede ensuciar la lógica de negocio.\n\nSeparando, garantizamos que el dominio sea siempre predecible y testeable.\n\n---\n\n## Principios para escribir código puro en la lógica de dominio\n\nPara que un código sea considerado *puro* dentro del dominio, debe seguir ciertos principios de diseño:\n\n- **Comprensible:** toda la información necesaria para ejecutar una operación debe estar explícitamente dada como entrada. No debe haber dependencias ocultas ni variables globales.\n- **Determinista:** para un conjunto de inputs, siempre debe producir los mismos outputs.\n- **Sin efectos secundarios:** no debe realizar operaciones que modifiquen el estado fuera de su ámbito o ejecuten IO.\n\nAplicando estos principios se reduce la complejidad y se facilita el testing.\n\n---\n\n## Domain-centric workflow: el workflow centrado en el dominio\n\nUn *workflow* puede verse como una historia de usuario. Scott propone abordar la lógica organizando el workflow centrado en el dominio, donde toda la lógica de negocio está en el núcleo, y el resto (como leer o guardar datos) está fuera.\n\n![Domain-centric workflow](Pasted_image_20250709203856.png)\n\nEsta técnica ayuda a mantener el principio de mantener el código IO alejado del dominio, y facilita que el sistema evolucione y mantenga claridad.\n\n---\n\n## Beneficios de escribir código puro para la lógica de dominio\n\n- **Inputs y outputs explícitos:** mejora la comprensión.\n- **Facilidad para testing:** no necesita mocks ni dobles de prueba complicados.\n- **No lidiar con asincronía:** ya que toda la asincronía está confinada a la shell imperativa.\n- **No manejo de excepciones por fallas IO:** que simplifica la lógica interna.\n\n---\n\n## Code smells o olores de código en tu core funcional\n\nAlgunos síntomas que indican que tu core contiene procesos IO o efectos secundarios no deseados son:\n\n- Presencia de procesos asíncronos directamente en el core.\n- Lanzamiento de excepciones para controlar el flujo (en lugar de retornar valores).\n- Cualquier efecto que afecte el estado externo o que no sea determinista.\n\nDetectar estos olores es importante para mantener el core limpio.\n\n---\n\n## Validaciones en la frontera entre IO y el core\n\nLas validaciones de datos deben realizarse al **ingresar a la frontera entre IO y el core** de dominio. Esto evita hacer programación defensiva dentro del dominio y garantiza que éste trabaje siempre con datos válidos, simplificando el código de negocio.\n\nSi los datos no son válidos, el flujo debe saltarse la lógica del dominio y manejar el error o la comunicación con el usuario desde la parte IO.\n\n---\n\n## Testing: unit tests y integration tests según la arquitectura\n\nEn este enfoque:\n\n- Los **unit tests** prueban exclusivamente el core funcional, porque es puramente funcional y determinista.\n- Las **integration tests** prueban los workflows completos, incluyendo el shell imperativo.\n\nEsta división evita la necesidad de mocks complejos para la lógica de negocio. El principal sujeto bajo prueba (SUT) debe ser siempre una unidad lógica que aporta valor real al negocio.\n\n---\n\n## Gestión de dependencias en el código funcional\n\nLas dependencias son aquellas partes del sistema que introducen no-determinismo y generalmente involucran IO. Scott Wlaschin describe varias estrategias para gestionarlas:\n\n1. **Dependency Rejection (rechazo de dependencias):**  \n   No tener dependencias en el core funcional. Esto simplifica la comprensión y testing, aunque puede requerir crear estructuras específicas para comunicar al shell qué IO ejecutar.\n\n2. **Dependency Injection:**  \n   Pasar las dependencias por constructor a las clases. Esta es la estrategia clásica y ampliamente usada, pero puede generar acoplamientos y crecimiento descontrolado de dependencias en las clases.\n\n3. **Dependency Parametrization:**  \n   Pasar solo las dependencias necesarias para una función o método específico. Ayuda a una mejor autodocumentación y manejo granular, y Scott la prefiere sobre la inyección tradicional.\n\n4. **Dependency Interpretation:**  \n   En lugar de ejecutar directamente IO, generar instrucciones que serán interpretadas posteriormente por un \"intérprete\" que realizará el IO. Esto crea un API orientado al dominio, que puede optimizar operaciones, pero es complejo y limitado en scope.\n\n---\n\n## Reemplazo del código IO sin interfaces\n\nEn lugar de crear interfaces abstractas para permitir la variabilidad de implementaciones IO, Scott sugiere simplemente **reemplazar el código IO en los bordes**. Mientras el core funcional reciba los mismos inputs y produzca los mismos outputs, no importa cómo se haga el IO.\n\nEsto funciona como piezas de LEGO: el código puro permanece inalterado mientras se intercambian los bloques de IO según necesidades.\n\n---\n\n## Conclusión\n\nLa arquitectura **Functional Core, Imperative Shell** promueve un diseño claramente separado donde:\n\n- La lógica de negocio se mantiene pura, determinista y fácilmente testeable.\n- El código imperativo y no determinista, con efectos secundarios, se aísla en los bordes.\n- Las dependencias con IO se gestionan con estrategias pensadas para minimizar el impacto en el core.\n- Las validaciones y excepciones se gestionan antes de que los datos ingresen a la lógica de dominio.\n\nAdoptar este patrón no solo mejora la calidad del software sino que facilita el desarrollo iterativo, la mantenibilidad y la escalabilidad de sistemas complejos.\n\nPara profundizar en este enfoque, se recomienda consultar la charla original de Scott Wlaschin en NDC Conferences London 2024 ([enlace aquí](https://www.youtube.com/watch?v=P1vES9AgfC4&list=PLMwE8LaxttZepye91Lrtw7qN7htmRjZFE&index=2)) y explorar ejemplos prácticos que ilustren cada uno de estos conceptos.\n\n---\n\n**Referencias:**\n\n- Wlaschin, Scott. *Moving IO to the edges of your app - Functional Core Imperative Shell*, NDC Conferences London 2024.\n- Seeman, Mark. Estrategias para gestionar dependencias.\n\n---\n\nEste artículo sintetiza y organiza los conceptos y recomendaciones que Scott Wlaschin expone para ayudarnos a construir aplicaciones más limpias, robustas y mantenibles siguiendo el patrón Functional Core, Imperative Shell."},{"role":"user","content":[{"type":"text","text":"de la gestión de dependencias, desde un caso en concreto genera un ejemplo por cada estrategia"}]}]},"responses":[{"timestamp":1752163949762,"id":"chatcmpl-BroAJ1QpM5YHYhVnuIJPdg8382AH5","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, a continuación detallo cada estrategia para la gestión de dependencias con un ejemplo práctico basado en un caso concreto. Supongamos que tenemos una aplicación que realiza una operación de **envío de correo electrónico** como parte de un workflow, donde el **core funcional** define la lógica para decidir cuándo mandar el mail, pero la operación real de envío es IO y está en el shell imperativo.\n\n---\n\n### Contexto:  \n**Caso:** Enviar un correo de notificación solo si se cumple cierta condición de negocio en el core funcional.  \n**Dependencia:** Servicio de envío de correo (IO).\n\n---\n\n## 1. Dependency Rejection (Rechazo de dependencias)\n\n**Concepto:** No tener dependencias en el core funcional. El core no sabe nada del envío de correos ni tiene referencias a servicios externos. En lugar de eso, el core devuelve un valor que describe la acción a realizar para el shell.\n\n**Ejemplo:**\n\n```fsharp\n// Core funcional: pura lógica\ntype NotificationAction = \n    | SendEmail of recipient:string * message:string\n    | NoAction\n\nlet decideNotification (user : User) : NotificationAction =\n    if user.IsActive then\n        SendEmail(user.Email, \"Bienvenido!\")\n    else\n        NoAction\n\n// Shell imperativo: interpreta la acción\nlet performNotification action =\n    match action with\n    | SendEmail (email, msg) -> emailService.Send(email, msg)  // código IO\n    | NoAction -> ()\n\n// Uso\nlet action = decideNotification someUser\nperformNotification action\n```\n\n**Ventajas:**  \n- Core puro, sin dependencias de IO.  \n- Fácil de testear y comprender.  \n- El core documenta \"qué debe pasar\" en lugar de \"cómo\".\n\n**Desventajas:**  \n- Se necesita definir tipos para las acciones que el shell interpretará, lo que puede ser tedioso.\n\n---\n\n## 2. Dependency Injection (Inyección de dependencias)\n\n**Concepto:** El core funcional o las clases que contienen la lógica reciben por constructor el servicio o interfaz que representa la dependencia.\n\n**Ejemplo:**\n\n```csharp\npublic interface IEmailSender\n{\n    void Send(string recipient, string message);\n}\n\npublic class NotificationService\n{\n    private readonly IEmailSender _emailSender;\n\n    public NotificationService(IEmailSender emailSender)\n    {\n        _emailSender = emailSender;\n    }\n\n    public void NotifyUser(User user)\n    {\n        if (user.IsActive)\n        {\n            _emailSender.Send(user.Email, \"Bienvenido!\");\n        }\n    }\n}\n\n// Shell inicializa la dependencia y la inyecta\nvar emailSender = new SmtpEmailSender();\nvar notificationService = new NotificationService(emailSender);\n\nnotificationService.NotifyUser(user);\n```\n\n**Ventajas:**  \n- Común y muy utilizada con frameworks de IoC.  \n- Centraliza configuración de dependencias.\n\n**Desventajas:**  \n- Clases pueden tener muchas dependencias mezcladas.  \n- A veces interfaz y dependencias crecen sin control.  \n- Dificulta saber qué dependencias usa cada método individual.\n\n---\n\n## 3. Dependency Parametrization (Parametrización de dependencias)\n\n**Concepto:** Pasar solo las dependencias necesarias como parámetros específicos a cada función o método que las utiliza.\n\n**Ejemplo:**\n\n```fsharp\n// Define función que recibe explícitamente el \"sendEmail\" como función\nlet notifyUser (sendEmail: string -> string -> unit) (user: User) =\n    if user.IsActive then\n        sendEmail user.Email \"Bienvenido!\"\n\n// Shell imperativo pasa función concreta\nlet smtpSendEmail recipient message =\n    // Código imperativo que envía el email\n    emailService.Send(recipient, message)\n\n// Uso\nnotifyUser smtpSendEmail someUser\n```\n\n**Ventajas:**  \n- El código se autodocumenta: queda claro qué inputs se necesitan.  \n- Reduce acoplamientos y hace explícitas las dependencias.  \n- Permite reemplazar fácilmente la función IO para tests o diferentes implementaciones.\n\n**Desventajas:**  \n- Puede complicarse si hay muchas dependencias múltiples anidadas.  \n- Requiere disciplina para no pasar argumentos innecesarios.\n\n---\n\n## 4. Dependency Interpretation (Interpretación de dependencias)\n\n**Concepto:** En lugar de ejecutar directamente el IO, el core produce una estructura de datos (instrucciones o comandos) que luego son interpretados por un intérprete en el shell imperativo.\n\n**Ejemplo:**\n\n```fsharp\n// Define un lenguaje de dominio para las acciones\ntype EmailCommand =\n    | SendEmail of recipient:string * message:string\n\ntype WorkflowInstruction =\n    | Email of EmailCommand\n    | NoOp\n\n// Core crea una lista de instrucciones\nlet buildInstructions (user: User) : WorkflowInstruction list =\n    if user.IsActive then\n        [ Email (SendEmail(user.Email, \"Bienvenido!\")) ]\n    else\n        [ NoOp ]\n\n// Intérprete que ejecuta instrucciones\nlet rec interpret instructions =\n    instructions |> List.iter (function\n        | Email (SendEmail (email, msg)) -> emailService.Send(email, msg)\n        | NoOp -> ())\n\n// Uso:\nlet instructions = buildInstructions someUser\ninterpret instructions\n```\n\n**Ventajas:**  \n- Crea una API orientada al dominio que se puede optimizar y analizar antes de ejecutar.  \n- Permite combinar y transformar instrucciones para optimizaciones.\n\n**Desventajas:**  \n- Complejidad elevada para implementaciones.  \n- Solo factible para dominios específicos y conjuntos limitados de operaciones.\n\n---\n\n# Resumen\n\n| Estrategia              | ¿Dónde está la dependencia?         | Ejemplo breve                             | Ventaja clave                   | Desventaja principal               |\n|------------------------|------------------------------------|-----------------------------------------|---------------------------------|----------------------------------|\n| Dependency Rejection     | Ninguna en el core, solo resultado | Core devuelve acciones, shell las ejecuta | Core puro, muy testeable        | Necesita modelar acciones         |\n| Dependency Injection     | En constructor de clase            | Servicio inyectado en clase              | Framework-friendly, claro       | Acoplamiento, crecimiento dependencias |\n| Dependency Parametrization | Parámetros individuales en función | Función recibe función `sendEmail`       | Transparente y modular          | Complejo si dependencias muchas  |\n| Dependency Interpretation | Core produce instrucciones, shell interpreta | Core crea lista de instrucciones         | Optimizable, DSL de dominio     | Alta complejidad, limitado scope |\n\nCada estrategia es útil dependiendo del contexto y tamaño del proyecto. La recomendación de Scott Wlaschin es preferir la pureza y parametrización para el core funcional, manteniendo el código IO separado y cambiado en los bordes.\n\n---\n\nSi quieres, puedo ayudarte a implementar estas estrategias en un lenguaje específico o con un caso más avanzado. ¿Quieres que continúe?"}}],"usage":{},"raw":{"id":"chatcmpl-BroAJ1QpM5YHYhVnuIJPdg8382AH5","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, a continuación detallo cada estrategia para la gestión de dependencias con un ejemplo práctico basado en un caso concreto. Supongamos que tenemos una aplicación que realiza una operación de **envío de correo electrónico** como parte de un workflow, donde el **core funcional** define la lógica para decidir cuándo mandar el mail, pero la operación real de envío es IO y está en el shell imperativo.\n\n---\n\n### Contexto:  \n**Caso:** Enviar un correo de notificación solo si se cumple cierta condición de negocio en el core funcional.  \n**Dependencia:** Servicio de envío de correo (IO).\n\n---\n\n## 1. Dependency Rejection (Rechazo de dependencias)\n\n**Concepto:** No tener dependencias en el core funcional. El core no sabe nada del envío de correos ni tiene referencias a servicios externos. En lugar de eso, el core devuelve un valor que describe la acción a realizar para el shell.\n\n**Ejemplo:**\n\n```fsharp\n// Core funcional: pura lógica\ntype NotificationAction = \n    | SendEmail of recipient:string * message:string\n    | NoAction\n\nlet decideNotification (user : User) : NotificationAction =\n    if user.IsActive then\n        SendEmail(user.Email, \"Bienvenido!\")\n    else\n        NoAction\n\n// Shell imperativo: interpreta la acción\nlet performNotification action =\n    match action with\n    | SendEmail (email, msg) -> emailService.Send(email, msg)  // código IO\n    | NoAction -> ()\n\n// Uso\nlet action = decideNotification someUser\nperformNotification action\n```\n\n**Ventajas:**  \n- Core puro, sin dependencias de IO.  \n- Fácil de testear y comprender.  \n- El core documenta \"qué debe pasar\" en lugar de \"cómo\".\n\n**Desventajas:**  \n- Se necesita definir tipos para las acciones que el shell interpretará, lo que puede ser tedioso.\n\n---\n\n## 2. Dependency Injection (Inyección de dependencias)\n\n**Concepto:** El core funcional o las clases que contienen la lógica reciben por constructor el servicio o interfaz que representa la dependencia.\n\n**Ejemplo:**\n\n```csharp\npublic interface IEmailSender\n{\n    void Send(string recipient, string message);\n}\n\npublic class NotificationService\n{\n    private readonly IEmailSender _emailSender;\n\n    public NotificationService(IEmailSender emailSender)\n    {\n        _emailSender = emailSender;\n    }\n\n    public void NotifyUser(User user)\n    {\n        if (user.IsActive)\n        {\n            _emailSender.Send(user.Email, \"Bienvenido!\");\n        }\n    }\n}\n\n// Shell inicializa la dependencia y la inyecta\nvar emailSender = new SmtpEmailSender();\nvar notificationService = new NotificationService(emailSender);\n\nnotificationService.NotifyUser(user);\n```\n\n**Ventajas:**  \n- Común y muy utilizada con frameworks de IoC.  \n- Centraliza configuración de dependencias.\n\n**Desventajas:**  \n- Clases pueden tener muchas dependencias mezcladas.  \n- A veces interfaz y dependencias crecen sin control.  \n- Dificulta saber qué dependencias usa cada método individual.\n\n---\n\n## 3. Dependency Parametrization (Parametrización de dependencias)\n\n**Concepto:** Pasar solo las dependencias necesarias como parámetros específicos a cada función o método que las utiliza.\n\n**Ejemplo:**\n\n```fsharp\n// Define función que recibe explícitamente el \"sendEmail\" como función\nlet notifyUser (sendEmail: string -> string -> unit) (user: User) =\n    if user.IsActive then\n        sendEmail user.Email \"Bienvenido!\"\n\n// Shell imperativo pasa función concreta\nlet smtpSendEmail recipient message =\n    // Código imperativo que envía el email\n    emailService.Send(recipient, message)\n\n// Uso\nnotifyUser smtpSendEmail someUser\n```\n\n**Ventajas:**  \n- El código se autodocumenta: queda claro qué inputs se necesitan.  \n- Reduce acoplamientos y hace explícitas las dependencias.  \n- Permite reemplazar fácilmente la función IO para tests o diferentes implementaciones.\n\n**Desventajas:**  \n- Puede complicarse si hay muchas dependencias múltiples anidadas.  \n- Requiere disciplina para no pasar argumentos innecesarios.\n\n---\n\n## 4. Dependency Interpretation (Interpretación de dependencias)\n\n**Concepto:** En lugar de ejecutar directamente el IO, el core produce una estructura de datos (instrucciones o comandos) que luego son interpretados por un intérprete en el shell imperativo.\n\n**Ejemplo:**\n\n```fsharp\n// Define un lenguaje de dominio para las acciones\ntype EmailCommand =\n    | SendEmail of recipient:string * message:string\n\ntype WorkflowInstruction =\n    | Email of EmailCommand\n    | NoOp\n\n// Core crea una lista de instrucciones\nlet buildInstructions (user: User) : WorkflowInstruction list =\n    if user.IsActive then\n        [ Email (SendEmail(user.Email, \"Bienvenido!\")) ]\n    else\n        [ NoOp ]\n\n// Intérprete que ejecuta instrucciones\nlet rec interpret instructions =\n    instructions |> List.iter (function\n        | Email (SendEmail (email, msg)) -> emailService.Send(email, msg)\n        | NoOp -> ())\n\n// Uso:\nlet instructions = buildInstructions someUser\ninterpret instructions\n```\n\n**Ventajas:**  \n- Crea una API orientada al dominio que se puede optimizar y analizar antes de ejecutar.  \n- Permite combinar y transformar instrucciones para optimizaciones.\n\n**Desventajas:**  \n- Complejidad elevada para implementaciones.  \n- Solo factible para dominios específicos y conjuntos limitados de operaciones.\n\n---\n\n# Resumen\n\n| Estrategia              | ¿Dónde está la dependencia?         | Ejemplo breve                             | Ventaja clave                   | Desventaja principal               |\n|------------------------|------------------------------------|-----------------------------------------|---------------------------------|----------------------------------|\n| Dependency Rejection     | Ninguna en el core, solo resultado | Core devuelve acciones, shell las ejecuta | Core puro, muy testeable        | Necesita modelar acciones         |\n| Dependency Injection     | En constructor de clase            | Servicio inyectado en clase              | Framework-friendly, claro       | Acoplamiento, crecimiento dependencias |\n| Dependency Parametrization | Parámetros individuales en función | Función recibe función `sendEmail`       | Transparente y modular          | Complejo si dependencias muchas  |\n| Dependency Interpretation | Core produce instrucciones, shell interpreta | Core crea lista de instrucciones         | Optimizable, DSL de dominio     | Alta complejidad, limitado scope |\n\nCada estrategia es útil dependiendo del contexto y tamaño del proyecto. La recomendación de Scott Wlaschin es preferir la pureza y parametrización para el core funcional, manteniendo el código IO separado y cambiado en los bordes.\n\n---\n\nSi quieres, puedo ayudarte a implementar estas estrategias en un lenguaje específico o con un caso más avanzado. ¿Quieres que continúe?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752161929380-1752163917737","thread_key":"Untitled Chat 1752161929380","stream":true,"user_message":"de la gestión de dependencias, desde un caso en concreto genera un ejemplo por cada estrategia","new_user_message":true,"class_name":"SmartCompletion"},
"smart_completions:Untitled Chat 1752608594239-1752608594240": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Genera notas de conocimiento para guardarlas para generar un curso"},{"type":"text","text":"├── BIBLIOGRAPHY/CONFERENCE-TALKS/\n│   └── The Power of Composition.md\n└── NOTES/\n    ├── Composición de Types.md\n    ├── Guía de diseño de funciones para realizar composición.md\n    ├── Los Types no son clases, son solo un nombre para un conjunto de cosas.md\n    ├── Una función es una  cosa  independiente (reusable) que no pertenece o está ligada a una clase.md\n    ├── Una función es una  cosa  que transforma inputs en outputs.md\n    └── Una función puede ser usada como input o output de otras funciones.md\n\nNOTES/Guía de diseño de funciones para realizar composición.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"2.50\"\nminutoFin: \"17.17\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cúal es?\nPara aplicar composición de funciones, estas deben seguir la siguiente guía de diseño:\n* Todas las funciones deben estar diseñadas para ser conectadas. De esta manera, no debería ser necesario usar patrones como el adapter.\n* Las funciones son reusables en diferentes contextos. Esto funciona por que cada función es autocontenida o independientes\n* Al conectar dos o más funciones, la resultante función debe ser también conectable. Esto permite una composición sin límites\n## ¿Por qué es importante\nCon esta guía se puede, desde funciones pequeñas, ir contruyendo piezas cada vez más grandes hasta tener una aplicación web. Empezando desde operaciones de bajo nivel, componer estas para crear servicios, combinando servicios crear un caso de uso, y con un dispatcher o controllador elegir que caso de uso ejecutar a modo de workflow. Lo importante es que todas las funciones creadas, son creadas por medio de la guía mencionada, así de simple\nAdemás, por compleja que sea la aplicación, los datos fluyen siempre solo en una dirección\n```\nNOTES/Una función es una  cosa  que transforma inputs en outputs.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"7.33\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una función es una  cosa  independiente (reusable) que no pertenece o está ligada a una clase.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.12\"\nminutoFin: \"8.42\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una función puede ser usada como input o output de otras funciones.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.42\"\nminutoFin: \"10.15\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Los Types no son clases, son solo un nombre para un conjunto de cosas.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"17.13\"\nminutoFin: \"19.02\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué significa?\nSe trata de poner nombre, dada una característica común,  a un conjunto de elementos. Esto aplica también a las funciones, dado que una cosa. Normalmente se entiende bien bajo el contexto de una función, ya que una función recibe un conjunto posibles cosas de un tipo y es capaz de devolver un conjunto de posibles cosas como output. Por tanto, tienen sentido en tanto y cuanto sean parte de un proceso de una función.\n```\nNOTES/Composición de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es?\nPara la composición se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento está separado de los datos.\nPara construir types \"más grandes/complejos\" se empieza desde types más simples/pequeños por medio de:\n* Composición  con \"AND\"  (record)\n\t* es una agrupación de types en un objeto, record, struct...\n*  Composición con \"OR\" (choice)\n\t* Es una elección entre diferentes opciones. una forma de hacerlo es usando enums\n## ¿Por qué es interesante?\nEsto permite generar una documentación que es ejecutable. Desde la declaración de types, su composición se puede inferir la definición de los elementos del negocio que están en juego y como se relacionan. Además al ser ligero, en un mismo fichero es fácil de inferir todo más directo\n## ¿Cómo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita información adicional\n>Para `Paypal` se necesita un correo electrónico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementación:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```\nBIBLIOGRAPHY/CONFERENCE-TALKS/The Power of Composition.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=rCKPgu4DvcE\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: NDC Conferences Oslo 2020\n```\n## Notas\n|File6|minutoInicio|minutoFin|\n|---|---|---|\n|[Guía de diseño de funciones para realizar composición](NOTES/Guía de diseño de funciones para realizar composición.md)|2.50|17.17|\n|[Una función es una cosa que transforma inputs en outputs](NOTES/Una función es una  cosa  que transforma inputs en outputs.md)|7.33|-|\n|[Una función es una cosa independiente (reusable) que no pertenece o está ligada a una clase](NOTES/Una función es una  cosa  independiente \\(reusable\\) que no pertenece o está ligada a una clase.md)|8.12|8.42|\n|[Una función puede ser usada como input o output de otras funciones](NOTES/Una función puede ser usada como input o output de otras funciones.md)|8.42|10.15|\n|[Los Types no son clases, son solo un nombre para un conjunto de cosas](NOTES/Los Types no son clases, son solo un nombre para un conjunto de cosas.md)|17.13|19.02|\n|[Composición de Types](NOTES/Composición de Types.md)|19.00|25.01|\n```"},{"type":"text","text":"Genera notas de conocimiento para guardarlas para generar un curso"}]}]},"responses":[{"timestamp":1752608658921,"id":"chatcmpl-BtfrEncCdhjtB7jFG6yv0qs5KEGTl","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Aquí tienes una recopilación estructurada de notas de conocimiento basadas en el material proporcionado, organizadas para facilitar la creación de un curso sobre composición funcional y diseño de tipos. Las notas incluyen definiciones clave, principios importantes, ejemplos y conceptos para explicar en el curso.\n\n---\n\n# Curso: Fundamentos de Composición Funcional y Diseño de Tipos\n\n---\n\n## 1. Introducción a la Composición Funcional\n\n### ¿Qué es la composición de funciones?\n- La composición consiste en conectar funciones que transforman datos, donde la salida de una función es la entrada de otra.\n- Esta técnica permite construir sistemas complejos agregando funcionalidades simples de forma modular y escalable.\n\n### Principios básicos:\n- Las funciones deben ser independientes y autocontenidas.\n- Deben poder reutilizarse en diferentes contextos sin depender de implementaciones externas.\n- La salida de la composición debe ser a su vez una función conectable, permitiendo composición ilimitada.\n\n---\n\n## 2. Guía de Diseño para Funciones Componibles  \n\n### Características que deben cumplir:\n- **Diseñadas para ser conectadas:** sincronización perfecta sin necesidad de adaptadores.\n- **Reutilizables:** independencia del contexto o clase.\n- **Composables recursivamente:** la composición de funciones genera nuevas funciones que pueden a su vez ser compuestas.\n\n### Importancia\n- Permite crear aplicaciones completas desde funciones simples.\n- Facilita flujos de datos unidireccionales, haciendo el sistema predecible y mantenible.\n  \n---\n\n## 3. Conceptos Clave sobre Funciones\n\n### Una función es...\n- Una cosa que **transforma inputs en outputs.**\n- Una cosa **independiente (reusable)** que no está ligada a una clase.\n- Una cosa que **puede usarse como input u output** de otras funciones.\n\nEstas cualidades facilitan la composición y reutilización.\n\n---\n\n## 4. Concepto de Types (Tipos)\n\n### ¿Qué son los types?\n- No son clases ni definiciones rígidas, sino **nombres para conjuntos de elementos que comparten características comunes.**\n- Se utilizan para **poner nombre a conjuntos de datos o funciones** en el contexto de la composición.\n\n---\n\n## 5. Composición de Types (Tipos Algebraicos)\n\n### Sistemas de composición:\n- **Composición \"AND\" (record/registro):** agrupa propiedades múltiples en un solo objeto.\n- **Composición \"OR\" (choice/elección):** representa alternativas usando enumeraciones o sumas de tipos.\n\n### Ventajas:\n- Documentación ejecutable.\n- Claridad al describir entidades de dominio y sus relaciones.\n- Ligereza del código al fusionar definiciones.\n\n### Cómo nombrar los types:\n- Pueden ser sustantivos (para valores/datos) o verbos (para funciones/operaciones).\n\n---\n\n## 6. Ejemplo Práctico: Modelado de Formas de Pago\n\n```fsharp\ntype EmailAddress = string  // tipo primitivo\ntype CardNumber = string    // tipo primitivo\ntype CardType = Visa | MasterCard  // tipo enumerado (choice)\n\ntype CreditCardInfo = {   // tipo record (AND)\n  CardNumber: CardNumber\n  CardType: CardType\n}\n\ntype PaymentMethod =       // tipo choice (OR)\n  | Cash\n  | Paypal of EmailAddress\n  | Card of CreditCardInfo\n\ntype PaymentAmount = decimal    // tipo primitivo\n\ntype Currency = EUR | USD | RUB // tipo choice\n\ntype Payment = {                // tipo record (AND)\n  Amount: PaymentAmount\n  Currency: Currency\n  Method: PaymentMethod\n}\n```\n\nEste ejemplo muestra cómo combinar tipos simples en tipos complejos que representan un dominio de negocio real.\n\n---\n\n## 7. Referencias y Profundización\n\n- **Conferencia:** [The Power of Composition - Scott Wlaschin - NDC Oslo 2020](https://www.youtube.com/watch?v=rCKPgu4DvcE)\n- Notas clave están relacionadas con los minutos indicados para un estudio detallado y un mejor aprovechamiento.\n\n---\n\n# Resumen para la generación del curso\n\nEl curso puede estructurarse en módulos:\n\n1. **Introducción a la composición funcional**\n2. **Diseño guía para funciones componibles**\n3. **Naturaleza y uso de las funciones**\n4. **Concepto y composición de Types**\n5. **Ejemplos prácticos con tipos algebraicos**\n6. **Estudio de caso y ejercicio práctico**\n7. **Conclusiones y recursos adicionales**\n\n---\n\nSi quieres, puedo ayudarte a desglosar estos puntos en lecciones, presentaciones o ejercicios prácticos. ¿Quieres que prepare ese material?"}}],"usage":{},"raw":{"id":"chatcmpl-BtfrEncCdhjtB7jFG6yv0qs5KEGTl","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Aquí tienes una recopilación estructurada de notas de conocimiento basadas en el material proporcionado, organizadas para facilitar la creación de un curso sobre composición funcional y diseño de tipos. Las notas incluyen definiciones clave, principios importantes, ejemplos y conceptos para explicar en el curso.\n\n---\n\n# Curso: Fundamentos de Composición Funcional y Diseño de Tipos\n\n---\n\n## 1. Introducción a la Composición Funcional\n\n### ¿Qué es la composición de funciones?\n- La composición consiste en conectar funciones que transforman datos, donde la salida de una función es la entrada de otra.\n- Esta técnica permite construir sistemas complejos agregando funcionalidades simples de forma modular y escalable.\n\n### Principios básicos:\n- Las funciones deben ser independientes y autocontenidas.\n- Deben poder reutilizarse en diferentes contextos sin depender de implementaciones externas.\n- La salida de la composición debe ser a su vez una función conectable, permitiendo composición ilimitada.\n\n---\n\n## 2. Guía de Diseño para Funciones Componibles  \n\n### Características que deben cumplir:\n- **Diseñadas para ser conectadas:** sincronización perfecta sin necesidad de adaptadores.\n- **Reutilizables:** independencia del contexto o clase.\n- **Composables recursivamente:** la composición de funciones genera nuevas funciones que pueden a su vez ser compuestas.\n\n### Importancia\n- Permite crear aplicaciones completas desde funciones simples.\n- Facilita flujos de datos unidireccionales, haciendo el sistema predecible y mantenible.\n  \n---\n\n## 3. Conceptos Clave sobre Funciones\n\n### Una función es...\n- Una cosa que **transforma inputs en outputs.**\n- Una cosa **independiente (reusable)** que no está ligada a una clase.\n- Una cosa que **puede usarse como input u output** de otras funciones.\n\nEstas cualidades facilitan la composición y reutilización.\n\n---\n\n## 4. Concepto de Types (Tipos)\n\n### ¿Qué son los types?\n- No son clases ni definiciones rígidas, sino **nombres para conjuntos de elementos que comparten características comunes.**\n- Se utilizan para **poner nombre a conjuntos de datos o funciones** en el contexto de la composición.\n\n---\n\n## 5. Composición de Types (Tipos Algebraicos)\n\n### Sistemas de composición:\n- **Composición \"AND\" (record/registro):** agrupa propiedades múltiples en un solo objeto.\n- **Composición \"OR\" (choice/elección):** representa alternativas usando enumeraciones o sumas de tipos.\n\n### Ventajas:\n- Documentación ejecutable.\n- Claridad al describir entidades de dominio y sus relaciones.\n- Ligereza del código al fusionar definiciones.\n\n### Cómo nombrar los types:\n- Pueden ser sustantivos (para valores/datos) o verbos (para funciones/operaciones).\n\n---\n\n## 6. Ejemplo Práctico: Modelado de Formas de Pago\n\n```fsharp\ntype EmailAddress = string  // tipo primitivo\ntype CardNumber = string    // tipo primitivo\ntype CardType = Visa | MasterCard  // tipo enumerado (choice)\n\ntype CreditCardInfo = {   // tipo record (AND)\n  CardNumber: CardNumber\n  CardType: CardType\n}\n\ntype PaymentMethod =       // tipo choice (OR)\n  | Cash\n  | Paypal of EmailAddress\n  | Card of CreditCardInfo\n\ntype PaymentAmount = decimal    // tipo primitivo\n\ntype Currency = EUR | USD | RUB // tipo choice\n\ntype Payment = {                // tipo record (AND)\n  Amount: PaymentAmount\n  Currency: Currency\n  Method: PaymentMethod\n}\n```\n\nEste ejemplo muestra cómo combinar tipos simples en tipos complejos que representan un dominio de negocio real.\n\n---\n\n## 7. Referencias y Profundización\n\n- **Conferencia:** [The Power of Composition - Scott Wlaschin - NDC Oslo 2020](https://www.youtube.com/watch?v=rCKPgu4DvcE)\n- Notas clave están relacionadas con los minutos indicados para un estudio detallado y un mejor aprovechamiento.\n\n---\n\n# Resumen para la generación del curso\n\nEl curso puede estructurarse en módulos:\n\n1. **Introducción a la composición funcional**\n2. **Diseño guía para funciones componibles**\n3. **Naturaleza y uso de las funciones**\n4. **Concepto y composición de Types**\n5. **Ejemplos prácticos con tipos algebraicos**\n6. **Estudio de caso y ejercicio práctico**\n7. **Conclusiones y recursos adicionales**\n\n---\n\nSi quieres, puedo ayudarte a desglosar estos puntos en lecciones, presentaciones o ejercicios prácticos. ¿Quieres que prepare ese material?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752608594239-1752608594240","thread_key":"Untitled Chat 1752608594239","stream":true,"context_key":"1752608594240","class_name":"SmartCompletion","user_message":"Genera notas de conocimiento para guardarlas para generar un curso","new_user_message":true},
"smart_completions:Untitled Chat 1752608985407-1752608985407": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"transforma el ejemplo de código a typescript"},{"type":"text","text":"└── NOTES/\n    └── Composición de Types.md\n\nNOTES/Composición de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es?\nPara la composición se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento está separado de los datos.\nPara construir types \"más grandes/complejos\" se empieza desde types más simples/pequeños por medio de:\n* Composición  con \"AND\"  (record)\n\t* es una agrupación de types en un objeto, record, struct...\n*  Composición con \"OR\" (choice)\n\t* Es una elección entre diferentes opciones. una forma de hacerlo es usando enums\n## ¿Por qué es interesante?\nEsto permite generar una documentación que es ejecutable. Desde la declaración de types, su composición se puede inferir la definición de los elementos del negocio que están en juego y como se relacionan. Además al ser ligero, en un mismo fichero es fácil de inferir todo más directo\n## ¿Cómo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita información adicional\n>Para `Paypal` se necesita un correo electrónico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementación:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```"},{"type":"text","text":"transforma el ejemplo de código a typescript"}]}]},"responses":[{"timestamp":1752609005311,"id":"chatcmpl-Btfx2iUBuYkDfxxXweH5U1bcs2rsL","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, aquí tienes la transformación del ejemplo dado en F# a TypeScript, respetando las composiciones con tipos \"AND\" (objetos) y \"OR\" (uniones / enums):\n\n```typescript\n// Tipos primitivos alias (TypeScript no necesita alias para string/number pero se ponen para claridad)\ntype EmailAddress = string;\ntype CardNumber = string;\ntype PaymentAmount = number; // decimal se representa con number en TypeScript\n\n// Tipo \"choice\" usando enum para CardType\nenum CardType {\n  Visa = \"Visa\",\n  MasterCard = \"MasterCard\",\n}\n\n// Tipo \"record\" (AND) para la información de la tarjeta\ninterface CreditCardInfo {\n  cardNumber: CardNumber;\n  cardType: CardType;\n}\n\n// Tipo \"choice\" (OR) representado con tipos discriminados en TypeScript\ntype PaymentMethod =\n  | { type: \"Cash\" }\n  | { type: \"Paypal\"; email: EmailAddress }\n  | { type: \"Card\"; cardInfo: CreditCardInfo };\n\n// Tipo \"choice\" usando enum para Currency\nenum Currency {\n  EUR = \"EUR\",\n  USD = \"USD\",\n  RUB = \"RUB\",\n}\n\n// Tipo \"record\" (AND) para el pago completo\ninterface Payment {\n  amount: PaymentAmount;\n  currency: Currency;\n  method: PaymentMethod;\n}\n```\n\n---\n\n### Explicación breve\n- Usamos `enum` para representar opciones limitadas, como `CardType` y `Currency` (OR/choice types).\n- Representamos tipos \"record\" como `interface` (AND/composición de propiedades).\n- Para el discriminated union de `PaymentMethod`, usamos objetos con un campo `type` para identificar la variante y los datos asociados correspondiente a cada una.\n\nSi quieres, puedo ayudarte también con ejemplos de funciones que usen estos tipos en TypeScript."}}],"usage":{},"raw":{"id":"chatcmpl-Btfx2iUBuYkDfxxXweH5U1bcs2rsL","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, aquí tienes la transformación del ejemplo dado en F# a TypeScript, respetando las composiciones con tipos \"AND\" (objetos) y \"OR\" (uniones / enums):\n\n```typescript\n// Tipos primitivos alias (TypeScript no necesita alias para string/number pero se ponen para claridad)\ntype EmailAddress = string;\ntype CardNumber = string;\ntype PaymentAmount = number; // decimal se representa con number en TypeScript\n\n// Tipo \"choice\" usando enum para CardType\nenum CardType {\n  Visa = \"Visa\",\n  MasterCard = \"MasterCard\",\n}\n\n// Tipo \"record\" (AND) para la información de la tarjeta\ninterface CreditCardInfo {\n  cardNumber: CardNumber;\n  cardType: CardType;\n}\n\n// Tipo \"choice\" (OR) representado con tipos discriminados en TypeScript\ntype PaymentMethod =\n  | { type: \"Cash\" }\n  | { type: \"Paypal\"; email: EmailAddress }\n  | { type: \"Card\"; cardInfo: CreditCardInfo };\n\n// Tipo \"choice\" usando enum para Currency\nenum Currency {\n  EUR = \"EUR\",\n  USD = \"USD\",\n  RUB = \"RUB\",\n}\n\n// Tipo \"record\" (AND) para el pago completo\ninterface Payment {\n  amount: PaymentAmount;\n  currency: Currency;\n  method: PaymentMethod;\n}\n```\n\n---\n\n### Explicación breve\n- Usamos `enum` para representar opciones limitadas, como `CardType` y `Currency` (OR/choice types).\n- Representamos tipos \"record\" como `interface` (AND/composición de propiedades).\n- Para el discriminated union de `PaymentMethod`, usamos objetos con un campo `type` para identificar la variante y los datos asociados correspondiente a cada una.\n\nSi quieres, puedo ayudarte también con ejemplos de funciones que usen estos tipos en TypeScript."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1752608985407-1752608985407","thread_key":"Untitled Chat 1752608985407","stream":true,"context_key":"1752608985407","class_name":"SmartCompletion","user_message":"transforma el ejemplo de código a typescript","new_user_message":true},
"smart_completions:Untitled Chat 1753470938123-1753470938123": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"genera una conclusión"},{"type":"text","text":"└── NOTES/\n    └── Razones por las cuáles los lenguajes de programación se vuelven populares.md\n\nNOTES/Razones por las cuáles los lenguajes de programación se vuelven populares.md\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Construyeron o se asocian a una aplicación/framework revolucionario\nEstos lenguajes se vuelven populares porque esas aplicaciones resuelve un problema significativo y/o satisface una gran demanda. Por tanto, la trayectoria de estas aplicaciones y estas applicaciones/frameworks queda ligada porque el lenguaje ofrece la forma más rápida, fácil o, en su momento, la única viable para utilizar la aplicación deseada. No se trata de que el lenguaje sea inherentemente superior o más atractivo, sino de que es la puerta de entrada a algo que los usuarios _realmente_ necesitan o quieren.\nEjemplos de lo anterior son:\n* VisiCalc para el Apple II\n* Ruby on Rails para Ruby\n* PHP para HTML dinámico, WordPress y Drupal\n* C para la programación de sistemas:*\n## Tienen exclusividad de plataforma\nUn lenguaje se convierte en la **forma preferida o, a menudo, la única viable para desarrollar en un ecosistema de software o hardware muy grande y dominante**. La inmensidad de la plataforma en sí misma es suficiente para impulsar el lenguaje a la cima, **independientemente de su diseño intrínseco** (ya sea funcional, imperativo, o orientado a objetos).\nPodemos ver esto manifestado con\n* Objective-C y Swift para Apple, la pura escala de la plataforma Apple garantiza su popularidad\n* JavaScript para la web: Se convirtió en el estándar de facto.\n* C# para Microsoft Windows:  Su éxito se debió a la exclusividad de las herramientas de Microsoft en su plataforma.\n## Dan facilidad de una adopción rápida y/o reutilización de código existente\nHay lenguajes que se han creado con vistas a atraer o ofrecer a comunidades una alternativa su lenguaje actual de una manera que sea fácil y/o también que les permita no tener que hacer una reescritura de sus proyectos. Todo con el argumento de que al hacer la migración tendrán grandes beneficios. En resumen, estos lenguajes tratan de aprovechar la familiaridad del desarrollador (reducción del coste de aprendizaje) y reducir las barreras de entrada.\nVeamos cómo algunos lenguajes exitosos han utilizado esta estrategia:\n• **CoffeeScript**: Uno de los primeros lenguajes en prosperar con esta filosofía.\n   * Su eslogan era \"es solo JavaScript\".\n   * Prometía que, si ya eras programador de JavaScript, podías aprenderlo en **aproximadamente media hora**.\n   * Ofrecía scripts para **convertir automáticamente** tu código JavaScript existente a CoffeeScript, lo que minimizaba drásticamente el **esfuerzo de migración** y reforzaba la idea de que era \"solo\" JavaScript.\n   * Esto fue suficiente para impulsarlo a ser el 11º lenguaje más popular en GitHub en su apogeo.\n• **TypeScript**: Un ejemplo fuerte de esta estrategia.\n * Es un **superconjunto estricto de JavaScript**, lo que significa que el código JavaScript válido es, por definición, también código TypeScript válido.\n * La migración puede ser tan simple como **renombrar un archivo** **.js** **a** **.ts**, y \"se supone que simplemente funciona\". A partir de ahí, los desarrolladores pueden añadir incrementalmente las características de TypeScript.\n * Ofrece **beneficios** (como el tipado estático) con un **costo percibido mínimo** (\"solo tienes que renombrar el archivo\"), lo que ha llevado a que mucha gente lo adopte.\n• **C++**:  El primer gran éxito de esta estrategia.\n* Era un \"casi superconjunto\" de C.\n* Permitió a los programadores de C tomar sus archivos `.c`, renombrarlos a `.cpp` y comenzar a acceder a los **beneficios adicionales** de C++. Esto facilitó una transición y adopción exitosa.\n• **Kotlin**: Un ejemplo moderno que, aunque es un lenguaje \"sustancialmente diferente\" de Java, capitaliza la misma idea.\n* Enfatiza su **\"interoperabilidad del 100% con las bases de código Java existentes\"** y la disponibilidad de scripts para **convertir Java a Kotlin**.\n* Esto reduce el **esfuerzo de migración** y el riesgo percibido para las empresas y desarrolladores con grandes bases de código Java, contribuyendo a su gran éxito.\n## Marketing\nHay lenguajes donde hubo detrás inversiones monetarias masivas como en el caso de Java por parte de Sun Microsystems invirtió **500 millones de dólares en una nueva campaña de marketing solo para Java**. Con ello obtuvo una omnipresencia en diversos medios que hicieron que fuera un elemento muy reconocible por parte de las personas que desarrollan.\nPor otro lado, JavaScript es el resultado de aprovechar la ola de popularidad de Java. originalmente concebido como un Lisp funcional basado en Scheme, fue forzado por Mozilla a adoptar una sintaxis y un enfoque orientado a objetos similares a Java**. Incluso su nombre contiene \"Java\"...\n## Otros factores secundarios\n• **Mercado Laboral**\n\tlos desarrolladores dudan en aprender un lenguaje si no hay trabajos disponibles que lo requieran, y los empleadores dudan en adoptar un lenguaje si no pueden encontrar desarrolladores para él. Este **refuerza la popularidad de los lenguajes que ya son dominantes**, ya que el gran volumen de trabajos existentes valida su aprendizaje, y la oferta de desarrolladores refuerza su uso por parte de las empresas.\n• **Comunidad**\n\tLa comunidad alrededor de un lenguaje puede ser un activo importante o un pasivo. Una comunidad acogedora y colaborativa puede atraer y retener a desarrolladores. Además, de lo que genera la comunidad. Un ejemplo de esto último es Python con diferentes ámbitos donde la comunidad tiene casi que una tool para cada caso de uso. Y donde más ha explotado es en el ámbito de la inteligencia artificial.\n• **Rendimiento**\n\tSe considera una **preocupación secundaria** que influye más en los **dominios de uso** de un lenguaje que en su popularidad general. Para ciertas aplicaciones, como la **programación de sistemas** (sistemas operativos, utilidades de bajo nivel), es **crítico tener control sobre la memoria**, lo que favorece lenguajes como C, C++ y, más recientemente, Rust. Sin embargo, para una vasta cantidad de dominios, el rendimiento absoluto no es el factor decisivo. Python, por ejemplo, es un lenguaje \"perfectamente aceptable\" para servidores de backend, incluso si no es el más rápido, porque el rendimiento suele estar limitado por factores externos como la red o la base de datos.\n```"},{"type":"text","text":"genera una conclusión"}]}]},"responses":[{"timestamp":1753470956539,"id":"chatcmpl-BxIBRdiyItoaZ6uwK7ALuMpE84H8Q","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"En conclusión, la popularidad de los lenguajes de programación no depende únicamente de sus características técnicas o su diseño intrínseco, sino que está estrechamente ligada a factores externos y estratégicos. Lenguajes que se asocian con aplicaciones o frameworks revolucionarios, que poseen exclusividad en plataformas dominantes, o que facilitan una adopción rápida mediante la reutilización y compatibilidad con código existente, tienden a consolidar su uso masivo. Además, el marketing y la inversión en promoción juegan un papel fundamental para aumentar su visibilidad y aceptación. Otros elementos como la disponibilidad de empleo, la fortaleza de la comunidad y consideraciones de rendimiento también influyen, aunque con menor peso en la popularidad general. En definitiva, la elección y éxito de un lenguaje es un fenómeno multidimensional que responde tanto a necesidades prácticas del mercado como a dinámicas sociales y comerciales dentro del ecosistema tecnológico."}}],"usage":{},"raw":{"id":"chatcmpl-BxIBRdiyItoaZ6uwK7ALuMpE84H8Q","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"En conclusión, la popularidad de los lenguajes de programación no depende únicamente de sus características técnicas o su diseño intrínseco, sino que está estrechamente ligada a factores externos y estratégicos. Lenguajes que se asocian con aplicaciones o frameworks revolucionarios, que poseen exclusividad en plataformas dominantes, o que facilitan una adopción rápida mediante la reutilización y compatibilidad con código existente, tienden a consolidar su uso masivo. Además, el marketing y la inversión en promoción juegan un papel fundamental para aumentar su visibilidad y aceptación. Otros elementos como la disponibilidad de empleo, la fortaleza de la comunidad y consideraciones de rendimiento también influyen, aunque con menor peso en la popularidad general. En definitiva, la elección y éxito de un lenguaje es un fenómeno multidimensional que responde tanto a necesidades prácticas del mercado como a dinámicas sociales y comerciales dentro del ecosistema tecnológico."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1753470938123-1753470938123","thread_key":"Untitled Chat 1753470938123","stream":true,"context_key":"1753470938123","class_name":"SmartCompletion","user_message":"genera una conclusión","new_user_message":true},
"smart_completions:Untitled Chat 1753472583163-1753472583163": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"puedes mejorar la redacción?"},{"type":"text","text":"├── BIBLIOGRAPHY/VIDEOS/\n│   └── Why Isn't Functional Programming the Norm.md\n└── NOTES/\n    └── Razones por las cuáles los lenguajes de programación se vuelven populares.md\n\nNOTES/Razones por las cuáles los lenguajes de programación se vuelven populares.md\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Construyeron o se asocian a una aplicación/framework revolucionario\nEstos lenguajes se vuelven populares porque esas aplicaciones resuelve un problema significativo y/o satisface una gran demanda. Por tanto, la trayectoria de estas aplicaciones y estas applicaciones/frameworks queda ligada porque el lenguaje ofrece la forma más rápida, fácil o, en su momento, la única viable para utilizar la aplicación deseada. No se trata de que el lenguaje sea inherentemente superior o más atractivo, sino de que es la puerta de entrada a algo que los usuarios _realmente_ necesitan o quieren.\nEjemplos de lo anterior son:\n* VisiCalc para el Apple II\n* Ruby on Rails para Ruby\n* PHP para HTML dinámico, WordPress y Drupal\n* C para la programación de sistemas:*\n## Tienen exclusividad de plataforma\nUn lenguaje se convierte en la **forma preferida o, a menudo, la única viable para desarrollar en un ecosistema de software o hardware muy grande y dominante**. La inmensidad de la plataforma en sí misma es suficiente para impulsar el lenguaje a la cima, **independientemente de su diseño intrínseco** (ya sea funcional, imperativo, o orientado a objetos).\nPodemos ver esto manifestado con\n* Objective-C y Swift para Apple, la pura escala de la plataforma Apple garantiza su popularidad\n* JavaScript para la web: Se convirtió en el estándar de facto.\n* C# para Microsoft Windows:  Su éxito se debió a la exclusividad de las herramientas de Microsoft en su plataforma.\n## Dan facilidad de una adopción rápida y/o reutilización de código existente\nHay lenguajes que se han creado con vistas a atraer o ofrecer a comunidades una alternativa su lenguaje actual de una manera que sea fácil y/o también que les permita no tener que hacer una reescritura de sus proyectos. Todo con el argumento de que al hacer la migración tendrán grandes beneficios. En resumen, estos lenguajes tratan de aprovechar la familiaridad del desarrollador (reducción del coste de aprendizaje) y reducir las barreras de entrada.\nVeamos cómo algunos lenguajes exitosos han utilizado esta estrategia:\n• **CoffeeScript**: Uno de los primeros lenguajes en prosperar con esta filosofía.\n   * Su eslogan era \"es solo JavaScript\".\n   * Prometía que, si ya eras programador de JavaScript, podías aprenderlo en **aproximadamente media hora**.\n   * Ofrecía scripts para **convertir automáticamente** tu código JavaScript existente a CoffeeScript, lo que minimizaba drásticamente el **esfuerzo de migración** y reforzaba la idea de que era \"solo\" JavaScript.\n   * Esto fue suficiente para impulsarlo a ser el 11º lenguaje más popular en GitHub en su apogeo.\n• **TypeScript**: Un ejemplo fuerte de esta estrategia.\n * Es un **superconjunto estricto de JavaScript**, lo que significa que el código JavaScript válido es, por definición, también código TypeScript válido.\n * La migración puede ser tan simple como **renombrar un archivo** **.js** **a** **.ts**, y \"se supone que simplemente funciona\". A partir de ahí, los desarrolladores pueden añadir incrementalmente las características de TypeScript.\n * Ofrece **beneficios** (como el tipado estático) con un **costo percibido mínimo** (\"solo tienes que renombrar el archivo\"), lo que ha llevado a que mucha gente lo adopte.\n• **C++**:  El primer gran éxito de esta estrategia.\n* Era un \"casi superconjunto\" de C.\n* Permitió a los programadores de C tomar sus archivos `.c`, renombrarlos a `.cpp` y comenzar a acceder a los **beneficios adicionales** de C++. Esto facilitó una transición y adopción exitosa.\n• **Kotlin**: Un ejemplo moderno que, aunque es un lenguaje \"sustancialmente diferente\" de Java, capitaliza la misma idea.\n* Enfatiza su **\"interoperabilidad del 100% con las bases de código Java existentes\"** y la disponibilidad de scripts para **convertir Java a Kotlin**.\n* Esto reduce el **esfuerzo de migración** y el riesgo percibido para las empresas y desarrolladores con grandes bases de código Java, contribuyendo a su gran éxito.\n## Marketing\nHay lenguajes donde hubo detrás inversiones monetarias masivas como en el caso de Java por parte de Sun Microsystems invirtió **500 millones de dólares en una nueva campaña de marketing solo para Java**. Con ello obtuvo una omnipresencia en diversos medios que hicieron que fuera un elemento muy reconocible por parte de las personas que desarrollan.\nPor otro lado, JavaScript es el resultado de aprovechar la ola de popularidad de Java. originalmente concebido como un Lisp funcional basado en Scheme, fue forzado por Mozilla a adoptar una sintaxis y un enfoque orientado a objetos similares a Java**. Incluso su nombre contiene \"Java\"...\n## Otros factores secundarios\n• **Mercado Laboral**\n\tlos desarrolladores dudan en aprender un lenguaje si no hay trabajos disponibles que lo requieran, y los empleadores dudan en adoptar un lenguaje si no pueden encontrar desarrolladores para él. Este **refuerza la popularidad de los lenguajes que ya son dominantes**, ya que el gran volumen de trabajos existentes valida su aprendizaje, y la oferta de desarrolladores refuerza su uso por parte de las empresas.\n• **Comunidad**\n\tLa comunidad alrededor de un lenguaje puede ser un activo importante o un pasivo. Una comunidad acogedora y colaborativa puede atraer y retener a desarrolladores. Además, de lo que genera la comunidad. Un ejemplo de esto último es Python con diferentes ámbitos donde la comunidad tiene casi que una tool para cada caso de uso. Y donde más ha explotado es en el ámbito de la inteligencia artificial.\n• **Rendimiento**\n\tSe considera una **preocupación secundaria** que influye más en los **dominios de uso** de un lenguaje que en su popularidad general. Para ciertas aplicaciones, como la **programación de sistemas** (sistemas operativos, utilidades de bajo nivel), es **crítico tener control sobre la memoria**, lo que favorece lenguajes como C, C++ y, más recientemente, Rust. Sin embargo, para una vasta cantidad de dominios, el rendimiento absoluto no es el factor decisivo. Python, por ejemplo, es un lenguaje \"perfectamente aceptable\" para servidores de backend, incluso si no es el más rápido, porque el rendimiento suele estar limitado por factores externos como la red o la base de datos.\n```\nBIBLIOGRAPHY/VIDEOS/Why Isn't Functional Programming the Norm.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=QyJZzq0v7Z4&t=16s\nautores:\n  - \"[[Richard Feldman]]\"\ntype: CONFERENCE-TALK\nconferencia: Clojutre 2019\n```\n## Notas\n|File8|minutoInicio|minutoFin|\n|---|---|---|\n|[Razones por las cuáles los lenguajes de programación se vuelven populares](NOTES/Razones por las cuáles los lenguajes de programación se vuelven populares.md)|01:53|18:45|\n|[Aplicaciones o frameworks revolucionarios hacen los lenguajes de programación, que los han construido o con las cuales se pueden utilizar, tengan una popularidad asociada a estas](NOTES/Aplicaciones o frameworks revolucionarios hacen los lenguajes de programación, que los han construido o con las cuales se pueden utilizar, tengan una popularidad asociada a estas.md)|01:45|06:22|\n|[Hay lenguajes de programación que se vuelven populares por la exclusividad en una plataforma popular](NOTES/Hay lenguajes de programación que se vuelven populares por la exclusividad en una plataforma popular.md)|06:22|10:22|\n|[Los lenguajes de programación que permiten una adopción rápida (familiaridad), reutilización de código existente (fácil migración) y dan beneficios, se vuelven populares](NOTES/Los lenguajes de programación que permiten una adopción rápida \\(familiaridad\\), reutilización de código existente \\(fácil migración\\) y dan beneficios, se vuelven populares.md)|10:22|13:14|\n|[El marketing puede hacer a un lenguaje popular o conocido](NOTES/El marketing puede hacer a un lenguaje popular o conocido.md)|13:14|16:15|\n|[El mercado laboral es un factor para decidir usar un lenguaje de programación](NOTES/El mercado laboral es un factor para decidir usar un lenguaje de programación.md)|17:46|18:46|\n|[Las comunidades de un lenguaje de programación pueden influir para cambiar o empezar a usar un lenguaje de programación](NOTES/Las comunidades de un lenguaje de programación pueden influir para cambiar o empezar a usar un lenguaje de programación.md)|17:46|18:46|\n|[La elección de un lenguaje de programación en ciertos contextos puede estar determinado por su rendimiento](NOTES/La elección de un lenguaje de programación en ciertos contextos puede estar determinado por su rendimiento.md)|17:46|18:46|\n```"},{"type":"text","text":"puedes mejorar la redacción?"}]}]},"responses":[{"timestamp":1753472609810,"id":"chatcmpl-BxIc4PLfu6qSTabJWQmzht7g7TIks","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, aquí tienes una versión mejorada y más fluida del texto:\n\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Asociados a una aplicación o framework revolucionario\nUn lenguaje se vuelve popular cuando está ligado a una aplicación o framework que resuelve un problema significativo o satisface una gran demanda. La trayectoria de estos proyectos queda estrechamente vinculada con el lenguaje, ya que este ofrece la forma más rápida, sencilla o, en su momento, la única manera viable de utilizarlos. No se trata de que el lenguaje sea inherentemente superior o más atractivo, sino de que actúa como la puerta de entrada a algo que los usuarios _realmente_ necesitan o desean.  \nEjemplos claros incluyen:\n* VisiCalc para Apple II  \n* Ruby on Rails para Ruby  \n* PHP para HTML dinámico, WordPress y Drupal  \n* C para programación de sistemas  \n\n## Exclusividad en plataformas dominantes\nUn lenguaje puede convertirse en la **opción preferida o incluso la única viable para desarrollar dentro de un ecosistema de software o hardware muy grande y dominante**. La magnitud de la plataforma es suficiente para catapultar su popularidad, **sin importar su diseño intrínseco** (funcional, imperativo u orientado a objetos).  \nEsto se refleja en casos como:  \n* Objective-C y Swift para Apple, cuya escala de plataforma garantiza su uso masivo  \n* JavaScript para la web, que se convirtió en el estándar de facto  \n* C# para Windows, impulsado por la exclusividad de las herramientas Microsoft en su plataforma  \n\n## Facilidad de adopción rápida y reutilización del código existente\nAlgunos lenguajes se crearon para atraer comunidades ofreciendo una transición sencilla, permitiendo reutilizar código existente y evitar reescrituras completas, argumentando que la migración conlleva beneficios sustanciales. En resumen, estos lenguajes aprovechan la familiaridad del desarrollador (reduciendo el coste de aprendizaje) y eliminan barreras de entrada.  \n\nEjemplos destacados:  \n* **CoffeeScript**:   \n  - Su lema era \"es solo JavaScript\".  \n  - Prometía que un programador JavaScript podía aprenderlo en **aproximadamente media hora**.  \n  - Disponía de scripts para **convertir automáticamente** código JavaScript a CoffeeScript, minimizando el esfuerzo de migración y reforzando la idea de que \"solo\" era JavaScript.  \n  - Esto le valió llegar a ser el 11º lenguaje más popular en GitHub en su apogeo.  \n* **TypeScript**:  \n  - Es un **superconjunto estricto de JavaScript**, lo que implica que cualquier código JavaScript válido es también código TypeScript.  \n  - La migración puede ser tan simple como renombrar un archivo `.js` a `.ts`, esperando que \"simplemente funcione\". Luego, los desarrolladores pueden añadir funcionalidades TypeScript de forma incremental.  \n  - Proporciona beneficios como el tipado estático con un costo percibido mínimo, facilitando su adopción masiva.  \n* **C++**:  \n  - Fue uno de los primeros éxitos de esta estrategia.  \n  - Es un \"casi superconjunto\" de C, permitiendo renombrar archivos `.c` a `.cpp` para acceder a las ventajas de C++ sin empezar desde cero.  \n* **Kotlin**:  \n  - Aunque significativamente diferente a Java, hace énfasis en su **compatibilidad total con las bases de código Java existentes** y en la disponibilidad de herramientas para convertir código Java a Kotlin.  \n  - Esto reduce el esfuerzo y riesgo de migración para empresas y desarrolladores, contribuyendo a su amplio éxito.  \n\n## Marketing\nAlgunos lenguajes deben su popularidad a fuertes inversiones en marketing. Por ejemplo, Sun Microsystems destinó **500 millones de dólares** para una campaña exclusivamente enfocada en Java, logrando una amplia visibilidad y reconocimiento entre desarrolladores.  \nJavaScript, por su parte, aprovechó la popularidad de Java; aunque inicialmente estaba basado en un Lisp funcional influenciado por Scheme, se vio obligado a adoptar una sintaxis y enfoque orientado a objetos similares a Java. Incluso su nombre incluye \"Java\" para aprovechar ese renombre.\n\n## Factores secundarios\n* **Mercado laboral**  \n  Los desarrolladores dudan en aprender un lenguaje sin demanda laboral, y los empleadores se resisten a adoptarlo si no encuentran talento capacitado. Esto **refuerza la popularidad de lenguajes dominantes**, al validar su aprendizaje por su alta demanda y asegurar la oferta de desarrolladores.  \n* **Comunidad**  \n  Una comunidad activa y acogedora puede ser clave para atraer y retener desarrolladores, además de promover el uso del lenguaje. Python es un buen ejemplo, con una amplia comunidad que ha desarrollado herramientas para prácticamente cualquier caso de uso, destacando en áreas como inteligencia artificial.  \n* **Rendimiento**  \n  Aunque importante en ciertos ámbitos, como la programación de sistemas donde el control de memoria es crítico, el rendimiento suele ser un factor secundario en la popularidad general. Lenguajes como Python resultan \"suficientemente rápidos\" para muchas aplicaciones, donde el verdadero cuello de botella está en la red o la base de datos, no en el lenguaje en sí.  \n\n```\n\nSi quieres, también puedo ayudarte a mejorar la redacción de las notas o del archivo YAML. ¿Quieres que lo haga?"}}],"usage":{},"raw":{"id":"chatcmpl-BxIc4PLfu6qSTabJWQmzht7g7TIks","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, aquí tienes una versión mejorada y más fluida del texto:\n\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Asociados a una aplicación o framework revolucionario\nUn lenguaje se vuelve popular cuando está ligado a una aplicación o framework que resuelve un problema significativo o satisface una gran demanda. La trayectoria de estos proyectos queda estrechamente vinculada con el lenguaje, ya que este ofrece la forma más rápida, sencilla o, en su momento, la única manera viable de utilizarlos. No se trata de que el lenguaje sea inherentemente superior o más atractivo, sino de que actúa como la puerta de entrada a algo que los usuarios _realmente_ necesitan o desean.  \nEjemplos claros incluyen:\n* VisiCalc para Apple II  \n* Ruby on Rails para Ruby  \n* PHP para HTML dinámico, WordPress y Drupal  \n* C para programación de sistemas  \n\n## Exclusividad en plataformas dominantes\nUn lenguaje puede convertirse en la **opción preferida o incluso la única viable para desarrollar dentro de un ecosistema de software o hardware muy grande y dominante**. La magnitud de la plataforma es suficiente para catapultar su popularidad, **sin importar su diseño intrínseco** (funcional, imperativo u orientado a objetos).  \nEsto se refleja en casos como:  \n* Objective-C y Swift para Apple, cuya escala de plataforma garantiza su uso masivo  \n* JavaScript para la web, que se convirtió en el estándar de facto  \n* C# para Windows, impulsado por la exclusividad de las herramientas Microsoft en su plataforma  \n\n## Facilidad de adopción rápida y reutilización del código existente\nAlgunos lenguajes se crearon para atraer comunidades ofreciendo una transición sencilla, permitiendo reutilizar código existente y evitar reescrituras completas, argumentando que la migración conlleva beneficios sustanciales. En resumen, estos lenguajes aprovechan la familiaridad del desarrollador (reduciendo el coste de aprendizaje) y eliminan barreras de entrada.  \n\nEjemplos destacados:  \n* **CoffeeScript**:   \n  - Su lema era \"es solo JavaScript\".  \n  - Prometía que un programador JavaScript podía aprenderlo en **aproximadamente media hora**.  \n  - Disponía de scripts para **convertir automáticamente** código JavaScript a CoffeeScript, minimizando el esfuerzo de migración y reforzando la idea de que \"solo\" era JavaScript.  \n  - Esto le valió llegar a ser el 11º lenguaje más popular en GitHub en su apogeo.  \n* **TypeScript**:  \n  - Es un **superconjunto estricto de JavaScript**, lo que implica que cualquier código JavaScript válido es también código TypeScript.  \n  - La migración puede ser tan simple como renombrar un archivo `.js` a `.ts`, esperando que \"simplemente funcione\". Luego, los desarrolladores pueden añadir funcionalidades TypeScript de forma incremental.  \n  - Proporciona beneficios como el tipado estático con un costo percibido mínimo, facilitando su adopción masiva.  \n* **C++**:  \n  - Fue uno de los primeros éxitos de esta estrategia.  \n  - Es un \"casi superconjunto\" de C, permitiendo renombrar archivos `.c` a `.cpp` para acceder a las ventajas de C++ sin empezar desde cero.  \n* **Kotlin**:  \n  - Aunque significativamente diferente a Java, hace énfasis en su **compatibilidad total con las bases de código Java existentes** y en la disponibilidad de herramientas para convertir código Java a Kotlin.  \n  - Esto reduce el esfuerzo y riesgo de migración para empresas y desarrolladores, contribuyendo a su amplio éxito.  \n\n## Marketing\nAlgunos lenguajes deben su popularidad a fuertes inversiones en marketing. Por ejemplo, Sun Microsystems destinó **500 millones de dólares** para una campaña exclusivamente enfocada en Java, logrando una amplia visibilidad y reconocimiento entre desarrolladores.  \nJavaScript, por su parte, aprovechó la popularidad de Java; aunque inicialmente estaba basado en un Lisp funcional influenciado por Scheme, se vio obligado a adoptar una sintaxis y enfoque orientado a objetos similares a Java. Incluso su nombre incluye \"Java\" para aprovechar ese renombre.\n\n## Factores secundarios\n* **Mercado laboral**  \n  Los desarrolladores dudan en aprender un lenguaje sin demanda laboral, y los empleadores se resisten a adoptarlo si no encuentran talento capacitado. Esto **refuerza la popularidad de lenguajes dominantes**, al validar su aprendizaje por su alta demanda y asegurar la oferta de desarrolladores.  \n* **Comunidad**  \n  Una comunidad activa y acogedora puede ser clave para atraer y retener desarrolladores, además de promover el uso del lenguaje. Python es un buen ejemplo, con una amplia comunidad que ha desarrollado herramientas para prácticamente cualquier caso de uso, destacando en áreas como inteligencia artificial.  \n* **Rendimiento**  \n  Aunque importante en ciertos ámbitos, como la programación de sistemas donde el control de memoria es crítico, el rendimiento suele ser un factor secundario en la popularidad general. Lenguajes como Python resultan \"suficientemente rápidos\" para muchas aplicaciones, donde el verdadero cuello de botella está en la red o la base de datos, no en el lenguaje en sí.  \n\n```\n\nSi quieres, también puedo ayudarte a mejorar la redacción de las notas o del archivo YAML. ¿Quieres que lo haga?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1753472583163-1753472583163","thread_key":"Untitled Chat 1753472583163","stream":true,"context_key":"1753472583163","class_name":"SmartCompletion","user_message":"puedes mejorar la redacción?","new_user_message":true},
"smart_completions:Untitled Chat 1753473204102-1753473204102": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"genera una conclusión"},{"type":"text","text":"└── NOTES/\n    └── Razones por las cuáles los lenguajes de programación se vuelven populares.md\n\nNOTES/Razones por las cuáles los lenguajes de programación se vuelven populares.md\n```md\n---\nvideo: \"[[Why Isn't Functional Programming the Norm]]\"\nminutoInicio: 01:53\nminutoFin: 18:45\ntags: \nnum_veces_leida: 0\n---\n## Construyeron o se asocian a una aplicación/framework revolucionario\nEstos lenguajes se vuelven populares porque esas aplicaciones resuelve un problema significativo y/o satisface una gran demanda. Por tanto, la trayectoria de estas aplicaciones y estas applicaciones/frameworks queda ligada porque el lenguaje ofrece la forma más rápida, fácil o, en su momento, la única viable para utilizar la aplicación deseada. No se trata de que el lenguaje sea inherentemente superior o más atractivo, sino de que es la puerta de entrada a algo que los usuarios _realmente_ necesitan o quieren.\nEjemplos de lo anterior son:\n* VisiCalc para el Apple II\n* Ruby on Rails para Ruby\n* PHP para HTML dinámico, WordPress y Drupal\n* C para la programación de sistemas:*\n## Tienen exclusividad de plataforma\nUn lenguaje se convierte en la **forma preferida o, a menudo, la única viable para desarrollar en un ecosistema de software o hardware muy grande y dominante**. La inmensidad de la plataforma en sí misma es suficiente para impulsar el lenguaje a la cima, **independientemente de su diseño intrínseco** (ya sea funcional, imperativo, o orientado a objetos).\nPodemos ver esto manifestado con\n* Objective-C y Swift para Apple, la pura escala de la plataforma Apple garantiza su popularidad\n* JavaScript para la web: Se convirtió en el estándar de facto.\n* C# para Microsoft Windows:  Su éxito se debió a la exclusividad de las herramientas de Microsoft en su plataforma.\n## Dan facilidad de una adopción rápida y/o reutilización de código existente\nHay lenguajes que se han creado con vistas a atraer o ofrecer a comunidades una alternativa su lenguaje actual de una manera que sea fácil y/o también que les permita no tener que hacer una reescritura de sus proyectos. Todo con el argumento de que al hacer la migración tendrán grandes beneficios. En resumen, estos lenguajes tratan de aprovechar la familiaridad del desarrollador (reducción del coste de aprendizaje) y reducir las barreras de entrada.\nVeamos cómo algunos lenguajes exitosos han utilizado esta estrategia:\n• **CoffeeScript**: Uno de los primeros lenguajes en prosperar con esta filosofía.\n   * Su eslogan era \"es solo JavaScript\".\n   * Prometía que, si ya eras programador de JavaScript, podías aprenderlo en **aproximadamente media hora**.\n   * Ofrecía scripts para **convertir automáticamente** tu código JavaScript existente a CoffeeScript, lo que minimizaba drásticamente el **esfuerzo de migración** y reforzaba la idea de que era \"solo\" JavaScript.\n   * Esto fue suficiente para impulsarlo a ser el 11º lenguaje más popular en GitHub en su apogeo.\n• **TypeScript**: Un ejemplo fuerte de esta estrategia.\n * Es un **superconjunto estricto de JavaScript**, lo que significa que el código JavaScript válido es, por definición, también código TypeScript válido.\n * La migración puede ser tan simple como **renombrar un archivo** **.js** **a** **.ts**, y \"se supone que simplemente funciona\". A partir de ahí, los desarrolladores pueden añadir incrementalmente las características de TypeScript.\n * Ofrece **beneficios** (como el tipado estático) con un **costo percibido mínimo** (\"solo tienes que renombrar el archivo\"), lo que ha llevado a que mucha gente lo adopte.\n• **C++**:  El primer gran éxito de esta estrategia.\n* Era un \"casi superconjunto\" de C.\n* Permitió a los programadores de C tomar sus archivos `.c`, renombrarlos a `.cpp` y comenzar a acceder a los **beneficios adicionales** de C++. Esto facilitó una transición y adopción exitosa.\n• **Kotlin**: Un ejemplo moderno que, aunque es un lenguaje \"sustancialmente diferente\" de Java, capitaliza la misma idea.\n* Enfatiza su **\"interoperabilidad del 100% con las bases de código Java existentes\"** y la disponibilidad de scripts para **convertir Java a Kotlin**.\n* Esto reduce el **esfuerzo de migración** y el riesgo percibido para las empresas y desarrolladores con grandes bases de código Java, contribuyendo a su gran éxito.\n## Marketing\nHay lenguajes donde hubo detrás inversiones monetarias masivas como en el caso de Java por parte de Sun Microsystems invirtió **500 millones de dólares en una nueva campaña de marketing solo para Java**. Con ello obtuvo una omnipresencia en diversos medios que hicieron que fuera un elemento muy reconocible por parte de las personas que desarrollan.\nPor otro lado, JavaScript es el resultado de aprovechar la ola de popularidad de Java. originalmente concebido como un Lisp funcional basado en Scheme, fue forzado por Mozilla a adoptar una sintaxis y un enfoque orientado a objetos similares a Java**. Incluso su nombre contiene \"Java\"...\n## Otros factores secundarios\n• **Mercado Laboral**\n\tlos desarrolladores dudan en aprender un lenguaje si no hay trabajos disponibles que lo requieran, y los empleadores dudan en adoptar un lenguaje si no pueden encontrar desarrolladores para él. Este **refuerza la popularidad de los lenguajes que ya son dominantes**, ya que el gran volumen de trabajos existentes valida su aprendizaje, y la oferta de desarrolladores refuerza su uso por parte de las empresas.\n• **Comunidad**\n\tLa comunidad alrededor de un lenguaje puede ser un activo importante o un pasivo. Una comunidad acogedora y colaborativa puede atraer y retener a desarrolladores. Además, de lo que genera la comunidad. Un ejemplo de esto último es Python con diferentes ámbitos donde la comunidad tiene casi que una tool para cada caso de uso. Y donde más ha explotado es en el ámbito de la inteligencia artificial.\n• **Rendimiento**\n\tSe considera una **preocupación secundaria** que influye más en los **dominios de uso** de un lenguaje que en su popularidad general. Para ciertas aplicaciones, como la **programación de sistemas** (sistemas operativos, utilidades de bajo nivel), es **crítico tener control sobre la memoria**, lo que favorece lenguajes como C, C++ y, más recientemente, Rust. Sin embargo, para una vasta cantidad de dominios, el rendimiento absoluto no es el factor decisivo. Python, por ejemplo, es un lenguaje \"perfectamente aceptable\" para servidores de backend, incluso si no es el más rápido, porque el rendimiento suele estar limitado por factores externos como la red o la base de datos.\n```"},{"type":"text","text":"genera una conclusión"}]}]},"responses":[{"timestamp":1753473218017,"id":"chatcmpl-BxIlzIcxTaX6VdlteUlPVR5EmqudC","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"En conclusión, la popularidad de los lenguajes de programación no depende exclusivamente de sus características técnicas o su superioridad inherente, sino que está fuertemente influenciada por factores externos como la asociación con aplicaciones o frameworks revolucionarios, la exclusividad en plataformas dominantes, y la facilidad para la adopción rápida y reutilización de código existente. Además, el marketing estratégico, el mercado laboral, y la comunidad de desarrolladores juegan un papel fundamental en consolidar y mantener su relevancia. Aunque el rendimiento es un aspecto importante en ciertos dominios específicos, en la mayoría de los casos no es el factor decisivo para la popularidad general. Por tanto, la adopción de un lenguaje suele ser un equilibrio entre necesidades prácticas, ecosistemas y estrategias sociales y comerciales."}}],"usage":{},"raw":{"id":"chatcmpl-BxIlzIcxTaX6VdlteUlPVR5EmqudC","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"En conclusión, la popularidad de los lenguajes de programación no depende exclusivamente de sus características técnicas o su superioridad inherente, sino que está fuertemente influenciada por factores externos como la asociación con aplicaciones o frameworks revolucionarios, la exclusividad en plataformas dominantes, y la facilidad para la adopción rápida y reutilización de código existente. Además, el marketing estratégico, el mercado laboral, y la comunidad de desarrolladores juegan un papel fundamental en consolidar y mantener su relevancia. Aunque el rendimiento es un aspecto importante en ciertos dominios específicos, en la mayoría de los casos no es el factor decisivo para la popularidad general. Por tanto, la adopción de un lenguaje suele ser un equilibrio entre necesidades prácticas, ecosistemas y estrategias sociales y comerciales."}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1753473204102-1753473204102","thread_key":"Untitled Chat 1753473204102","stream":true,"context_key":"1753473204102","class_name":"SmartCompletion","user_message":"genera una conclusión","new_user_message":true},
"smart_completions:Untitled Chat 1754602279071-1754602279072": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para diseñar el backend de mi actual proyecto"},{"type":"text","text":"├── BIBLIOGRAPHY/VIDEOS/\n│   └── Functional Desing Patterns.md\n└── NOTES/\n    ├── Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n    ├── Composición con currificación.md\n    ├── Composición de Types.md\n    ├── Functional Core, Imperative Shell Architecture.md\n    ├── Hay mantener el código IO alejado de la lógica de negocio.md\n    ├── La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n    ├── La programación orientada a objetos trata sobre manejo o gestión de dependencias.md\n    ├── Las pipelines al ser componibles, son extensibles.md\n    ├── Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ├── Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    ├── Puedes llamar funciones puras en funciones impuras, pero no lo hagas al revés.md\n    ├── Trabajar en progromación funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n    ├── Una función es una  cosa  independiente (reusable) que no pertenece o está ligada a una clase.md\n    └── Una función puede ser usada como input o output de otras funciones.md\n\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el código de domino está en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enfásis en que [[En la lógica de dominio hay que seguir los principios de diseño para generar código \"puro\"]] y [[Hay mantener el código IO alejado de la lógica de negocio]] y este será impuro e imperativo.\nAdemás, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicación en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el código es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el código de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Hay mantener el código IO alejado de la lógica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\n* El código IO no forma parte del dominio. Además, cuando se entremezclan dificulta la comprensión de la lógica de negocio.\n* El código IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El código IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la lógica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enfásis en que [[System Under Test (SUT)]] debe ser una unidad lógica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Trabajar en progromación funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"57.27\"\nminutoFin: FINAL\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nPor el ideal o guía básica de la [[Programación Funcional]] es crear funciones puras y por tanto funciones aisladas de sus dependencias. Y si están así son testeables por definición.\n![[Pasted image 20250722021843.png]]\nen cambio con [[POO]] ocurre un [[Test-Induced damage]] porque no hay solape sino una intersección que hace opere en un equilibrio más inestable:\n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nSegún [[Scott Wlaschin]], esto no pertenece a la lógica de negocio, y debe ocurrir antes de entrar en juego la lógica de negocio. Esto evita realizar programación defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el código porque se separa operaciones de valor para el negocio de las validaciones.\n## ¿Qué ocurre si no hay algo válido?\nSe hace skip de la lógica de negocio porque se entiende que no tiene sentido procesar información invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situación\n![[Pasted image 20250709232523.png]]\n```\nNOTES/La programación orientada a objetos trata sobre manejo o gestión de dependencias.md\n```md\n---\nlibro: \"[[Practical Object-Oriented Desing (2º Edition)]]\"\ncapítulo: 1-Object-Oriented Design\npaginas: \"27\"\ntags:\n  - POO\n  - Diseño-software\n  - Observación\n---\n## Lo que comenta la autora sobre esto\nLa [[POO]] trabaja con objetos, estos interactuan entre sí por pasos de mensaje, para ello tienen que conocer que mensajes pedir, la gestión de este \"conocimiento\" entre los objetos es la gestión de dependencias. Si estos, saben mucho entre estos ocurre que un cambio tiene mayor impacto del necesario.\n```\nNOTES/Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"29.10\"\nminutoFin: \"33.14\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nEn el [[Ejemplo -> Restaurant Booking]], [[Mark Seeman]] muestra como al escribir funciones puras para la lógica de negocio (Dominio) y la capa de aplicación (donde se adapta el modelo de negocio al exterior y viceversa)  y la parte impura para las operaciones IO. Automáticamente se centra siguiendo el principio de [[Puedes llamar funciones puras en funciones impuras, pero no lo hagas al revés]] a la hora de generar  hacer la composición. Esto se lleva al límite con [[Haskell]] cuando esto te lo fuerza por typing. Es decir, que si intentas romper el principio, el programa no te compilara y te forzará a hacerlo bien sin necesidad de estar vigilando que todo el mundo cumpla las guías\n![[Pasted image 20250722010459.png]]\n```\nNOTES/La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"9.12\"\nminutoFin: \"12.32\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nPrimero hay un esfuerzo importante que hacer para explicar a un equipo de personas que desarrollan que nunca han escuchado sobre la [[Arquitectura Hexagonal]] el por qué necesitamos aplicarla. Sobre todo cuando para aplicarla es necesario entender principios de diseño de la [[Programación Orientada a Objetos]] como pueden ser los [[Principios SOLID]], [[Inyección de dependencias]]... etc. Y para entenderlos con la profundidad necesaria es necesario consumir bibliografía no poco extensa.\nLuego, lo más complicado es mantener en \"orden\" o \"rectitud\" la aplicación de todos esos principios en armonía para que se cumpla la arquitectura. Esto se debe a que esto puede ser \"derrumbado\" ante cada modificación o extensión del sistema (perturbaciones). Por ejemplo, si por urgencia se decide saltar alguna de las capas para que el Dominio tenga \"acceso\" a Infrastructura, nada lo impide y posiblemente sea algo que genere intereses negativos como [[Deuda Técnica]] y sino se ataja mayor es el interés (tiempo a invertir) a pagar con el paso del tiempo. En definitiva, que se pueda hacer esto quiere decir que todo ese edificio de principios y demás pueden caerse porque los cimientos pueden ser quitados sin ninguna red de seguridad más que la convención\n```\nNOTES/Puedes llamar funciones puras en funciones impuras, pero no lo hagas al revés.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"15.15\"\nminutoFin: \"16.50\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\n[[Mark Semman]] hace el siguiente razonamiento\n* Si compones funciones impuras, siguen siendo el resultado impuro. No pasa nada, todo es impuro\n* Si creas un función impura donde funciones de más \"bajo nivel\" son puras no pasa nada porque que sea mas o menos impura no es relevante\n* Pero si la función de \"alto nivel\" quieres que intente ser pura pero tiene alguna de más bajo nivel impura, hay un problema de diseño, se ha colado un [[Side-Effects]] y habría que ver la manera de empujar esa impureza fuera. Hay lenguajes como [[Haskell]] que ni si quiera compila\n```\nNOTES/Composición de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es?\nPara la composición se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento está separado de los datos.\nPara construir types \"más grandes/complejos\" se empieza desde types más simples/pequeños por medio de:\n* Composición  con \"AND\"  (record)\n\t* es una agrupación de types en un objeto, record, struct...\n*  Composición con \"OR\" (choice)\n\t* Es una elección entre diferentes opciones. una forma de hacerlo es usando enums\n## ¿Por qué es interesante?\nEsto permite generar una documentación que es ejecutable. Desde la declaración de types, su composición se puede inferir la definición de los elementos del negocio que están en juego y como se relacionan. Además al ser ligero, en un mismo fichero es fácil de inferir todo más directo\n## ¿Cómo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita información adicional\n>Para `Paypal` se necesita un correo electrónico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementación:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```\nNOTES/Composición con currificación.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"31.00\"\nminutoFin: \"36.35\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una técnica para conectar funciones que no tienen un solo input y tienen un solo output. Esto permite aplicar la [[Guía de diseño de funciones para realizar composición]].\n![[Pasted image 20250716001611.png]]\nLa técnica trata de generar una función intermedia interna permita gestionar el segundo parámetro como un input individual de esta que a su vez da un output individual, una especie de adaptación para conectar con nuevas funciones.\n## Ejemplo\n![[Pasted image 20250716002738.png]]\n![[Pasted image 20250716001854.png]]\n![[Pasted image 20250716002002.png]]\n```\nNOTES/Una función puede ser usada como input o output de otras funciones.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.42\"\nminutoFin: \"10.15\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una función es una  cosa  independiente (reusable) que no pertenece o está ligada a una clase.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.12\"\nminutoFin: \"8.42\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Las pipelines al ser componibles, son extensibles.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"38.25\"\nminutoFin: \"39.00\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nAñadir funcionalidad adicional no requiere modificar el código existente, basta con añadir nuevos segmentos.\n![[Pasted image 20250716003633.png]]\n```\nBIBLIOGRAPHY/VIDEOS/Functional Desing Patterns.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=ucnWLfBA1dc&t=598s\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: DevTernity Conference 2018\n```\n|File0|minutoInicio|minutoFin|\n|---|---|---|\nDataview: No results to show for table query.\n```"},{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para diseñar el backend de mi actual proyecto"}]}],"tools":[{"type":"function","function":{"name":"lookup_context","description":"Common, frequently used. Performs a semantic search of the user's data. Use to respond to 'Based on my notes...' or any other query that might require surfacing unspecified content. Minimum 3 hypothetical notes predicted to be semantically similar to the notes necessary to fulfill the user's request. Each hypothetical is a semantic representation of content that's likely relevant to the user's request. Hypothetical notes always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3.","parameters":{"type":"object","properties":{"hypothetical_1":{"type":"string","description":"Always begin with breadcrumbs containing the hypothetical folder(s) and file name (separated by ' > '). Example: HYPOTHETICAL FOLDER NAME > CHILD FOLDER NAME > FILE NAME: HYPOTHETICAL NOTE CONTENTS. Important: minimum 3."},"hypothetical_2":{"type":"string","description":"Must be distinct from and not share any breadcrumbs with hypothetical_1."},"hypothetical_3":{"type":"string","description":"Must be distinct from hypothetical_1 and hypothetical_2."},"in_folder":{"type":"string","description":"Optional. Only use if requested by the user. Limit the lookup to items in this folder."}},"required":["hypothetical_1","hypothetical_2"]}}}],"tool_choice":{"type":"function","function":{"name":"lookup_context"}}},"responses":[{"timestamp":1754602459060,"id":"chatcmpl-C22Xa1P23XZb9qm2Qa2lTDYM1DH1q","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"","tool_calls":[{"id":"call_KrOYTM3rvw32f90QqWWHVc7q","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"DOCUMENTO BASE > Diseño Backend: Ideas principales desde arquitectura funcional y patterns.md\",\"hypothetical_2\":\"DOCUMENTO BASE > Resumen y síntesis de conceptos de arquitectura y programación funcional.md\",\"hypothetical_3\":\"DOCUMENTO BASE > Guía coherente para diseño de backend usando arquitectura funcional.md\"}"}}]}}],"usage":{},"raw":{"id":"chatcmpl-C22Xa1P23XZb9qm2Qa2lTDYM1DH1q","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"","tool_calls":[{"id":"call_KrOYTM3rvw32f90QqWWHVc7q","type":"function","function":{"name":"lookup_context","arguments":"{\"hypothetical_1\":\"DOCUMENTO BASE > Diseño Backend: Ideas principales desde arquitectura funcional y patterns.md\",\"hypothetical_2\":\"DOCUMENTO BASE > Resumen y síntesis de conceptos de arquitectura y programación funcional.md\",\"hypothetical_3\":\"DOCUMENTO BASE > Guía coherente para diseño de backend usando arquitectura funcional.md\"}"}}]}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1754602279071-1754602279072","thread_key":"Untitled Chat 1754602279071","stream":true,"context_key":"1754602279072","class_name":"SmartCompletion","user_message":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para diseñar el backend de mi actual proyecto","new_user_message":true,"action_key":"lookup_context","actions":{"lookup_context":"1754602459847"}},
"smart_completions:Untitled Chat 1754602279071-1754602459851": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para diseñar el backend de mi actual proyecto"},{"type":"text","text":"├── BIBLIOGRAPHY/VIDEOS/\n│   └── Functional Desing Patterns.md\n└── NOTES/\n    ├── Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n    ├── Composición con currificación.md\n    ├── Composición de Types.md\n    ├── Functional Core, Imperative Shell Architecture.md\n    ├── Hay mantener el código IO alejado de la lógica de negocio.md\n    ├── La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n    ├── La programación orientada a objetos trata sobre manejo o gestión de dependencias.md\n    ├── Las pipelines al ser componibles, son extensibles.md\n    ├── Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n    ├── Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n    ├── Puedes llamar funciones puras en funciones impuras, pero no lo hagas al revés.md\n    ├── Trabajar en progromación funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n    ├── Una función es una  cosa  independiente (reusable) que no pertenece o está ligada a una clase.md\n    └── Una función puede ser usada como input o output de otras funciones.md\n\nNOTES/Functional Core, Imperative Shell Architecture.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"12.00\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el código de domino está en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enfásis en que [[En la lógica de dominio hay que seguir los principios de diseño para generar código \"puro\"]] y [[Hay mantener el código IO alejado de la lógica de negocio]] y este será impuro e imperativo.\nAdemás, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicación en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el código es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el código de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/Hay mantener el código IO alejado de la lógica de negocio.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"0.00\"\nminutoFin: \"2.40\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\n* El código IO no forma parte del dominio. Además, cuando se entremezclan dificulta la comprensión de la lógica de negocio.\n* El código IO es no determinista, pueden ocurrir diferentes resultados con los mismos inputs, lo que dificulta el testing.\n* El código IO puede fallar, lo que hace que haya que hacer un manejo de excepciones, que es diferente al de errores.\n```\nNOTES/Los unit tests prueban el core funcional y las integration tests prueban los workflows.md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"33.07\"\nminutoFin: \"36.23\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es esto?\nLa siguiente imagen es una resumen claro:\n![[Pasted image 20250709231209.png]]\nCon este enfoque no hacen falta usar dobles de tests para la lógica de negocio. Si acaso en los bordes (operaciones IO):\n![[Pasted image 20250709231425.png]]\nCon este enfoque [[Scott Wlaschin]] hace enfásis en que [[System Under Test (SUT)]] debe ser una unidad lógica que aporta valor al negocio. En este sentido, hacer tests de los [[Domain-centric workflow]]s.  \n```\nNOTES/Trabajar en progromación funcional permite alcanzar aislamiento de dependencias y la testabilidad con menor esfuerzo.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"57.27\"\nminutoFin: FINAL\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nPor el ideal o guía básica de la [[Programación Funcional]] es crear funciones puras y por tanto funciones aisladas de sus dependencias. Y si están así son testeables por definición.\n![[Pasted image 20250722021843.png]]\nen cambio con [[POO]] ocurre un [[Test-Induced damage]] porque no hay solape sino una intersección que hace opere en un equilibrio más inestable:\n```\nNOTES/Las validaciones de los datos deben ocurrir en la frontera de los procesos IO y Core (dominio).md\n```md\n---\ncharla: \"[[Moving IO to the edges of your app -> Functional Core Imperative Shell]]\"\nminutoInicio: \"36.27\"\nminutoFin: \ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nSegún [[Scott Wlaschin]], esto no pertenece a la lógica de negocio, y debe ocurrir antes de entrar en juego la lógica de negocio. Esto evita realizar programación defensiva y permite trabajar al dominio con datos validos siempre. Esto permite a fin de cuentas a simplificar el código porque se separa operaciones de valor para el negocio de las validaciones.\n## ¿Qué ocurre si no hay algo válido?\nSe hace skip de la lógica de negocio porque se entiende que no tiene sentido procesar información invalida, y se procede a ejecutar otro proceso IO que \"comunique\" o opere ante esta situación\n![[Pasted image 20250709232523.png]]\n```\nNOTES/La programación orientada a objetos trata sobre manejo o gestión de dependencias.md\n```md\n---\nlibro: \"[[Practical Object-Oriented Desing (2º Edition)]]\"\ncapítulo: 1-Object-Oriented Design\npaginas: \"27\"\ntags:\n  - POO\n  - Diseño-software\n  - Observación\n---\n## Lo que comenta la autora sobre esto\nLa [[POO]] trabaja con objetos, estos interactuan entre sí por pasos de mensaje, para ello tienen que conocer que mensajes pedir, la gestión de este \"conocimiento\" entre los objetos es la gestión de dependencias. Si estos, saben mucho entre estos ocurre que un cambio tiene mayor impacto del necesario.\n```\nNOTES/Arquitectura de Puertos y Adaptadores en un paradigma funcional  surge de manera natural al empujar a los bordes las funciones impuras.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"29.10\"\nminutoFin: \"33.14\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nEn el [[Ejemplo -> Restaurant Booking]], [[Mark Seeman]] muestra como al escribir funciones puras para la lógica de negocio (Dominio) y la capa de aplicación (donde se adapta el modelo de negocio al exterior y viceversa)  y la parte impura para las operaciones IO. Automáticamente se centra siguiendo el principio de [[Puedes llamar funciones puras en funciones impuras, pero no lo hagas al revés]] a la hora de generar  hacer la composición. Esto se lleva al límite con [[Haskell]] cuando esto te lo fuerza por typing. Es decir, que si intentas romper el principio, el programa no te compilara y te forzará a hacerlo bien sin necesidad de estar vigilando que todo el mundo cumpla las guías\n![[Pasted image 20250722010459.png]]\n```\nNOTES/La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"9.12\"\nminutoFin: \"12.32\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nPrimero hay un esfuerzo importante que hacer para explicar a un equipo de personas que desarrollan que nunca han escuchado sobre la [[Arquitectura Hexagonal]] el por qué necesitamos aplicarla. Sobre todo cuando para aplicarla es necesario entender principios de diseño de la [[Programación Orientada a Objetos]] como pueden ser los [[Principios SOLID]], [[Inyección de dependencias]]... etc. Y para entenderlos con la profundidad necesaria es necesario consumir bibliografía no poco extensa.\nLuego, lo más complicado es mantener en \"orden\" o \"rectitud\" la aplicación de todos esos principios en armonía para que se cumpla la arquitectura. Esto se debe a que esto puede ser \"derrumbado\" ante cada modificación o extensión del sistema (perturbaciones). Por ejemplo, si por urgencia se decide saltar alguna de las capas para que el Dominio tenga \"acceso\" a Infrastructura, nada lo impide y posiblemente sea algo que genere intereses negativos como [[Deuda Técnica]] y sino se ataja mayor es el interés (tiempo a invertir) a pagar con el paso del tiempo. En definitiva, que se pueda hacer esto quiere decir que todo ese edificio de principios y demás pueden caerse porque los cimientos pueden ser quitados sin ninguna red de seguridad más que la convención\n```\nNOTES/Puedes llamar funciones puras en funciones impuras, pero no lo hagas al revés.md\n```md\n---\ncharla: \"[[Functional architecture - The pits of success]]\"\nminutoInicio: \"15.15\"\nminutoFin: \"16.50\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\n[[Mark Semman]] hace el siguiente razonamiento\n* Si compones funciones impuras, siguen siendo el resultado impuro. No pasa nada, todo es impuro\n* Si creas un función impura donde funciones de más \"bajo nivel\" son puras no pasa nada porque que sea mas o menos impura no es relevante\n* Pero si la función de \"alto nivel\" quieres que intente ser pura pero tiene alguna de más bajo nivel impura, hay un problema de diseño, se ha colado un [[Side-Effects]] y habría que ver la manera de empujar esa impureza fuera. Hay lenguajes como [[Haskell]] que ni si quiera compila\n```\nNOTES/Composición de Types.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"19.00\"\nminutoFin: \"25.01\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Cómo es?\nPara la composición se aplica el sistema de tipos algebraicos (componible). Para ello, solo es posible si el comportamiento está separado de los datos.\nPara construir types \"más grandes/complejos\" se empieza desde types más simples/pequeños por medio de:\n* Composición  con \"AND\"  (record)\n\t* es una agrupación de types en un objeto, record, struct...\n*  Composición con \"OR\" (choice)\n\t* Es una elección entre diferentes opciones. una forma de hacerlo es usando enums\n## ¿Por qué es interesante?\nEsto permite generar una documentación que es ejecutable. Desde la declaración de types, su composición se puede inferir la definición de los elementos del negocio que están en juego y como se relacionan. Además al ser ligero, en un mismo fichero es fácil de inferir todo más directo\n## ¿Cómo nombramos a los types?\nPueden ser sustantivos (valores) o verbos (funciones)\n## Ejemplo\nCaso de uso:\n> Aceptamos tres formas de pago `Cash`, `Paypal` o `CreditCard`\n>Para `Cash` no se necesita información adicional\n>Para `Paypal` se necesita un correo electrónico\n>Para `CreditCard` necesitamos saber el tipo de card y el card number\nImplementación:\n```Fsharp\ntype EmailAddress = string  // primite type\ntype CardNumber = string  // primite type\ntype CardType = Visa | MasterCard  // choice type (usando 2OR\")\ntype CreditCardInfo = {    // Record Type (usando \"AND\")\n\tCardNumber: CardNumber\n\tCardType: CardType\n}\ntype PaymentMethod =   // choice type (usando \"OR\")\n\t| Cash\n\t| Paypal of EmailAddres\n\t| Card of CreditCardInfo\ntype PaymentAmount = decimal  // primitive type\ntype Currency = EUR | USD | RUB // choice type (usando \"OR\")\ntype Payment = {  // record type (usando \"AND\")\n\tAmount: PaymentAmount\n\tCurrency: Currency\n\tMethod; PaymentMethod\n}\n```\n```\nNOTES/Composición con currificación.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"31.00\"\nminutoFin: \"36.35\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Qué es?\nEs una técnica para conectar funciones que no tienen un solo input y tienen un solo output. Esto permite aplicar la [[Guía de diseño de funciones para realizar composición]].\n![[Pasted image 20250716001611.png]]\nLa técnica trata de generar una función intermedia interna permita gestionar el segundo parámetro como un input individual de esta que a su vez da un output individual, una especie de adaptación para conectar con nuevas funciones.\n## Ejemplo\n![[Pasted image 20250716002738.png]]\n![[Pasted image 20250716001854.png]]\n![[Pasted image 20250716002002.png]]\n```\nNOTES/Una función puede ser usada como input o output de otras funciones.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.42\"\nminutoFin: \"10.15\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Una función es una  cosa  independiente (reusable) que no pertenece o está ligada a una clase.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"8.12\"\nminutoFin: \"8.42\"\ntags: \nnum_veces_leida: 0\n---\n```\nNOTES/Las pipelines al ser componibles, son extensibles.md\n```md\n---\ncharla: \"[[The Power of Composition]]\"\nminutoInicio: \"38.25\"\nminutoFin: \"39.00\"\ntags: \nnum_veces_leida: 0\n---\n## ¿Por qué?\nAñadir funcionalidad adicional no requiere modificar el código existente, basta con añadir nuevos segmentos.\n![[Pasted image 20250716003633.png]]\n```\nBIBLIOGRAPHY/VIDEOS/Functional Desing Patterns.md\n```md\n```yaml\nurl: https://www.youtube.com/watch?v=ucnWLfBA1dc&t=598s\nautores:\n  - \"[[ Scott Wlaschin]]\"\ntype: CONFERENCE-TALK\nconferencia: DevTernity Conference 2018\n```\n|File0|minutoInicio|minutoFin|\n|---|---|---|\nDataview: No results to show for table query.\n```"},{"type":"text","text":"Quiero hacer un documento coherente con todas estas ideas extraidas porque son con las que me he basado para diseñar el backend de mi actual proyecto"},{"type":"text","text":"└── NOTES/\n    ├── Bases de Lean UX (Product).md##¿Cuáles son?#Agile#{3}\n    ├── El diseño es el arte de ordenar código.md##Lo que piensa la autora#{1}\n    ├── El modelaje o diseño de software que sea fácil de mantener es complicado aplicando POO.md##¿Por qué?\n    ├── El modelaje o diseño de software que sea fácil de mantener es complicado aplicando POO.md##¿Por qué?#{1}\n    ├── El modelaje o diseño de software que sea fácil de mantener es complicado aplicando POO.md##¿Por qué?#{4}\n    ├── Functional Core, Imperative Shell Architecture.md##¿Qué es?\n    ├── Functional Core, Imperative Shell Architecture.md##¿Qué es?#{1}\n    ├── RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\n    ├── RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema#{1}\n    └── Testing sobre bases de datos (1).md##Mi opinión#{1}\n\nNOTES/Testing sobre bases de datos (1).md##Mi opinión#{1}\n```md##Mi opinión#{1}\nCiertamente, es algo que práctico creo desde el punto de vista de [[DDD no depende de una arquitectura o patrón de arquitectura concreto, la elección de estas deben estar orientadas solo a satisface los requerimientos de calidad de software y estas no pueden ser determinadas sin los requisitos funcionales]] con el patrón repository (siendo el \"sinonimo\" de Gateway). A mi sinceramente me gusta más crear una implementación de [[Fake Object]] testeado y que este sea utilizado en las pruebas de negocio. Pero concuerdo con la separación y testear de que ese elemento descoplante esté haciendo esa traducción entre objetos de dominio y queries o commandos hacia base de datos\n```\nNOTES/Functional Core, Imperative Shell Architecture.md##¿Qué es?#{1}\n```md##¿Qué es?#{1}\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el código de domino está en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enfásis en que [[En la lógica de dominio hay que seguir los principios de diseño para generar código \"puro\"]] y [[Hay mantener el código IO alejado de la lógica de negocio]] y este será impuro e imperativo.\nAdemás, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicación en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el código es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el código de domino puro logramos:\n```\nNOTES/RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\n```md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\n#### Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema\nEsto se considera un enfoque clásico, ya que considera la interfaz del sistema como un todo cohesivo que simplemente se expone  utilizando abstracciones  de recursos en lugar de servicios  o interfaces remotas\n```\nNOTES/Functional Core, Imperative Shell Architecture.md##¿Qué es?\n```md##¿Qué es?\n## ¿Qué es?\nSe trata de una arquitectura similar a la [[Arquitectura Hexagonal]] en cuanto a que el código de domino está en el centro y la infraestructura alrededor o al borde.\nEsta arquitectura hace enfásis en que [[En la lógica de dominio hay que seguir los principios de diseño para generar código \"puro\"]] y [[Hay mantener el código IO alejado de la lógica de negocio]] y este será impuro e imperativo.\nAdemás, para hacer un desarrollo iterativo incremental, hay que fraccionar la aplicación en [[Domain-centric workflow]]s\nUn ejemplo reflejado en el código es el siguiente:\n![[Pasted image 20250709210948.png]]\nmanteniendo el código de domino puro logramos:\n*  que no tenga que preocuparse por operaciones asincronas, pues estas surgen de operaciones IO y esto ya las hemos alejado. \n```\nNOTES/RESTful HTTP  y DDD.md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema#{1}\n```md####Crear un [[Bounded Context]] separado para la capa de interfaz del sistema y utilizar las estrategias  apropiadas  para acceder  al Dominio principal  real desde el modelo  de interfaz del sistema#{1}\nEsto se considera un enfoque clásico, ya que considera la interfaz del sistema como un todo cohesivo que simplemente se expone  utilizando abstracciones  de recursos en lugar de servicios  o interfaces remotas\n```\nNOTES/El modelaje o diseño de software que sea fácil de mantener es complicado aplicando POO.md##¿Por qué?#{1}\n```md##¿Por qué?#{1}\nEl principio fundamental de la [[POO]] es la encapsulación que significa que pocas palabras: Agrupar en objetos datos y comportamiento y no exponer los datos sino operaciones sobre estos con métodos ([[Tell, Don`t ask]]). Esto ha hecho que aparecieran antipatrones como [[Active Record]] donde operaciones sobre entidades de tipo persistencia se encapsularan sobre objetos de tipo X.\nLuego, [[Eric Evans]] escribió un libro sobre [[Domain Driving Desing]] donde explica patrones de diseño para hacer más fácil mantener software separando objetos en dos categorías:\n```\nNOTES/El modelaje o diseño de software que sea fácil de mantener es complicado aplicando POO.md##¿Por qué?\n```md##¿Por qué?\n## ¿Por qué?\nEl principio fundamental de la [[POO]] es la encapsulación que significa que pocas palabras: Agrupar en objetos datos y comportamiento y no exponer los datos sino operaciones sobre estos con métodos ([[Tell, Don`t ask]]). Esto ha hecho que aparecieran antipatrones como [[Active Record]] donde operaciones sobre entidades de tipo persistencia se encapsularan sobre objetos de tipo X.\nLuego, [[Eric Evans]] escribió un libro sobre [[Domain Driving Desing]] donde explica patrones de diseño para hacer más fácil mantener software separando objetos en dos categorías:\n* Entidades y value objects\n* Servicios\nEn los values objects son elementos que carecen de comportamiento y solo encapsulan conjuntos de datos para dar sentido a dominio cuando están bajo una entidad (elemento importante en el dominio sobre el cual existe un ciclo de vida) y los servicios son los elementos que operan con estos conjuntos de datos.\nDe la manera que [[Eric Evans]], bajo la experiencia de [[Mark Seeman]] se genera un código que tiene éxito porque se mantiene con el tiempo bien. Sin embargo, al igual que pasa que [[La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla]],  esto requiere de mucho esfuerzo para entender por qué esto genera un software más fácil de mantener, cómo aplicar los patrones de diseño y lo más complicado que todas las personas mantengan el mismo mindset.\n```\nNOTES/El diseño es el arte de ordenar código.md##Lo que piensa la autora#{1}\n```md##Lo que piensa la autora#{1}\nNo se trata de anticipar  lo que cambiará en un software, se trata de aceptar que algo cambiará. Se trata de preservar las opción abiertas para acomodar esos posibles cambios. Por  tanto, reducir el coste de cambio.\n```\nNOTES/Bases de Lean UX (Product).md##¿Cuáles son?#Agile#{3}\n```md##¿Cuáles son?#Agile#{3}\n\t* El reto es averiguar cuál solución es la más viable. A veces, es difícil o imposible predecir de antemano qué solución funcionará. \n\t* Al poner nuestras ideas en manos de los clientes (a menudo a través de software funcional) antes, el equipo puede evaluar rápidamente las soluciones para determinar su ajuste al mercado y viabilidad.\n* **Colaboración con el cliente sobre negociación contractual**\n\t* Colaborar con tus compañeros de equipo y clientes construye un entendimiento compartido del espacio del problema y de las soluciones propuestas.\n```\nNOTES/El modelaje o diseño de software que sea fácil de mantener es complicado aplicando POO.md##¿Por qué?#{4}\n```md##¿Por qué?#{4}\nEn los values objects son elementos que carecen de comportamiento y solo encapsulan conjuntos de datos para dar sentido a dominio cuando están bajo una entidad (elemento importante en el dominio sobre el cual existe un ciclo de vida) y los servicios son los elementos que operan con estos conjuntos de datos.\nDe la manera que [[Eric Evans]], bajo la experiencia de [[Mark Seeman]] se genera un código que tiene éxito porque se mantiene con el tiempo bien. Sin embargo, al igual que pasa que [[La arquitectura de puertos y adaptadores en POO requiere de un gran esfuerzo para aplicarla bien y mantenerla]],  esto requiere de mucho esfuerzo para entender por qué esto genera un software más fácil de mantener, cómo aplicar los patrones de diseño y lo más complicado que todas las personas mantengan el mismo mindset.\n```"}]},{"role":"assistant","content":""}]},"responses":[{"timestamp":1754602572809,"id":"chatcmpl-C22Z2xLH6vCXH4q44verGRKjjaMb7","object":"chat.completion","created":null,"choices":[{"message":{"role":"assistant","content":"Claro, aquí tienes un documento coherente que integra y articula las ideas clave extraídas de tus notas y referencias para explicar el diseño del backend de tu proyecto, desde una perspectiva funcional y arquitectónica, comparando enfoques y destacando buenas prácticas:\n\n---\n\n# Diseño del Backend basado en Arquitectura Funcional y Principios del Core Funcional\n\n## Introducción\n\nEl diseño del backend de este proyecto se ha basado en un conjunto de ideas extraídas principalmente de la arquitectura funcional y el patrón **Functional Core, Imperative Shell**, así como en conceptos de arquitectura hexagonal o puertos y adaptadores. A continuación, se presenta una síntesis estructurada de estos conceptos, con especial énfasis en la separación de responsabilidades, la gestión de dependencias y la testabilidad.\n\n---\n\n## 1. Separación clara entre lógica de negocio y efectos secundarios (IO)\n\n### 1.1 Functional Core - Imperative Shell\n\nEste patrón arquitectónico sitúa el código de dominio en el centro del sistema, el cual debe estar escrito como funciones **puras**, siguiendo principios de diseño funcional. Alrededor de este núcleo se encuentra una \"cáscara\" imperativa que maneja todas las operaciones con efectos secundarios o entrada/salida (IO).\n\n**Beneficios clave:**\n\n- **Aislamiento de la lógica de negocio:** La lógica de dominio no se preocupa por la asincronía ni las fallas de IO, lo que simplifica la comprensión y evolución del código.\n- **Facilidad en el testeo:** Al ser puras, las funciones del core son deterministas y fácilmente testeables con tests unitarios.\n- **Manejo explícito de efectos secundarios:** El código IO, que es no determinista y propenso a fallos, se maneja en los bordes, donde se deben implementar mecanismos específicos de error y validación.\n\n---\n\n### 1.2 Mantener el código IO alejado de la lógica de negocio\n\nEl código que realiza operaciones IO debe mantenerse fuera de la lógica del dominio, porque:\n\n- Dificulta la comprensión al mezclar conceptos muy distintos.\n- Introduce no determinismo en el core, dificultando pruebas y mantenibilidad.\n- Requiere manejo de excepciones distinto al de la lógica de negocio.\n\nEste aislamiento es fundamental para aplicar correctamente el patrón Functional Core Imperative Shell.\n\n---\n\n## 2. Arquitectura Hexagonal (Puertos y Adaptadores)\n\nLa arquitectura hexagonal propone que el dominio (core) esté desacoplado de las infraestructuras y tecnologías externas mediante puertos (interfaces abstractas) y adaptadores concretos que implementan esas interfaces.\n\n- Esta arquitectura es muy compatible con la arquitectura funcional, especialmente cuando los bordes contienen el código impuro.\n- En programación **orientada a objetos (POO)**, la implementación de la arquitectura hexagonal demanda un gran esfuerzo para ser bien aplicada y mantenida, requiriendo un entendimiento profundo de principios como SOLID y una disciplina constante para evitar \"atajos\" que generen deuda técnica.\n- En cambio, la arquitectura funcional facilita este desacoplamiento de forma más natural, incluso en lenguajes que fuerzan, como Haskell, la separación entre código puro e impuro a nivel de tipos.\n\n---\n\n## 3. Principios de diseño funcional aplicados\n\n### 3.1 Composición y reutilización de funciones\n\n- Una función es una entidad independiente, reusable y desacoplada de clases o estructuras de datos.\n- Puede ser usada como entrada o salida de otras funciones, facilitando la composición.\n- La currificación es una técnica para adaptar funciones con múltiples argumentos a una cadena de funciones de un solo argumento, que permite conexiones limpias y composables entre ellas.\n- Las pipelines construidas con funciones puras son extensibles, ya que agregar funcionalidad normalmente implica añadir nuevos segmentos sin alterar el código existente.\n\n---\n\n### 3.2 Composición de types algebraicos para modelar dominio\n\nPara representar datos del dominio de forma clara y segura, aplicamos:\n\n- Composición con \"AND\" (records/tuplas): para agrupar datos relacionados.\n- Composición con \"OR\" (uniones / enums): para modelar elecciones o variantes.\n\nEsta técnica no solo documenta de forma precisa los elementos y sus relaciones, sino que también facilita el análisis estático, el mantenimiento y la evolución del dominio, manteniendo la lógica separada de la representación.\n\n---\n\n## 4. Validación y flujo de datos\n\n- Las validaciones deben realizarse en la frontera entre los procesos IO y el core funcional para garantizar que la lógica de negocio solo reciba datos válidos.\n- Esto evite la necesidad de programación defensiva dentro del core y simplifica la lógica.\n- Cuando se detectan datos no válidos, se omite la ejecución del core (skip) y se deben ejecutar procesos alternativos para manejar esos casos.\n\n---\n\n## 5. Testeo\n\n- Los **tests unitarios** se enfocan en el core funcional, donde las funciones puras permiten pruebas deterministas, simples y rápidas.\n- Los **tests de integración** apuntan a validar los flujos de trabajo (workflows) completos, los cuales incluyen las operaciones de IO y la interacción entre múltiples componentes y sistemas.\n\nEste enfoque reduce la necesidad de dobles y mocks complejos en la lógica de negocio y mejora la confianza en la calidad del software.\n\n---\n\n## 6. Comparación con la Programación Orientada a Objetos (POO)\n\n- La POO centra su práctica en la gestión de dependencias entre objetos, los cuales se comunican por mensajes.\n- Esta gestión puede ser compleja y conlleva un mayor esfuerzo para aplicar arquitecturas limpias como la hexagonal y mantener la disciplina asociada.\n- Patrones mal aplicados, como Active Record, mezclan lógica de persistencia con lógica de negocio, complicando el mantenimiento.\n- En la POO, los objetos pueden contener estado y comportamiento, y el acoplamiento accidental puede generar un incremento en la deuda técnica con el tiempo.\n- En cambio, la programación funcional promueve el aislamiento de dependencias mediante funciones puras, que reduce el esfuerzo en testabilidad y mantenibilidad.\n\n---\n\n## 7. Perspectiva de Lean UX y desarrollo ágil\n\n- El diseño y arquitectura deben aceptar que los cambios sucederán, por lo que el código debe preservar flexibilidad y minimizar el costo de cambio.\n- Validar ideas cuanto antes con clientes, es decir, entregar software funcional que permita obtener feedback rápido, ayuda a evaluar la viabilidad de las soluciones.\n- La colaboración estrecha con clientes y el equipo contribuye a un entendimiento común del problema y de las soluciones.\n\n---\n\n## Conclusión\n\nEl diseño del backend se apoya en una arquitectura funcional que conlleva un core de funciones puras rodeado por una capa imperativa que maneja IO. Esta separación garantiza un dominio expresivo, claro y altamente testeable.\n\nLa composición funcional, la utilización correcta de tipos algebraicos para el modelado, la validación en los bordes y el uso consciente de buenas prácticas para testear mejoran la calidad y mantenibilidad del proyecto.\n\nSi bien la arquitectura hexagonal y patrones de diseño similares son aplicables en POO, la arquitectura funcional facilita esta limpieza estructural con menor esfuerzo, a la vez que despliega un modelo mental más simple y alineado con los principios de la programación funcional.\n\n---\n\nSi quieres, puedo ayudarte a elaborar diagramas o ejemplos concretos para ilustrar cualquiera de estos puntos. ¿Quieres continuar con eso?"}}],"usage":{},"raw":{"id":"chatcmpl-C22Z2xLH6vCXH4q44verGRKjjaMb7","object":"chat.completion","created":0,"model":"","choices":[{"message":{"index":0,"role":"assistant","content":"Claro, aquí tienes un documento coherente que integra y articula las ideas clave extraídas de tus notas y referencias para explicar el diseño del backend de tu proyecto, desde una perspectiva funcional y arquitectónica, comparando enfoques y destacando buenas prácticas:\n\n---\n\n# Diseño del Backend basado en Arquitectura Funcional y Principios del Core Funcional\n\n## Introducción\n\nEl diseño del backend de este proyecto se ha basado en un conjunto de ideas extraídas principalmente de la arquitectura funcional y el patrón **Functional Core, Imperative Shell**, así como en conceptos de arquitectura hexagonal o puertos y adaptadores. A continuación, se presenta una síntesis estructurada de estos conceptos, con especial énfasis en la separación de responsabilidades, la gestión de dependencias y la testabilidad.\n\n---\n\n## 1. Separación clara entre lógica de negocio y efectos secundarios (IO)\n\n### 1.1 Functional Core - Imperative Shell\n\nEste patrón arquitectónico sitúa el código de dominio en el centro del sistema, el cual debe estar escrito como funciones **puras**, siguiendo principios de diseño funcional. Alrededor de este núcleo se encuentra una \"cáscara\" imperativa que maneja todas las operaciones con efectos secundarios o entrada/salida (IO).\n\n**Beneficios clave:**\n\n- **Aislamiento de la lógica de negocio:** La lógica de dominio no se preocupa por la asincronía ni las fallas de IO, lo que simplifica la comprensión y evolución del código.\n- **Facilidad en el testeo:** Al ser puras, las funciones del core son deterministas y fácilmente testeables con tests unitarios.\n- **Manejo explícito de efectos secundarios:** El código IO, que es no determinista y propenso a fallos, se maneja en los bordes, donde se deben implementar mecanismos específicos de error y validación.\n\n---\n\n### 1.2 Mantener el código IO alejado de la lógica de negocio\n\nEl código que realiza operaciones IO debe mantenerse fuera de la lógica del dominio, porque:\n\n- Dificulta la comprensión al mezclar conceptos muy distintos.\n- Introduce no determinismo en el core, dificultando pruebas y mantenibilidad.\n- Requiere manejo de excepciones distinto al de la lógica de negocio.\n\nEste aislamiento es fundamental para aplicar correctamente el patrón Functional Core Imperative Shell.\n\n---\n\n## 2. Arquitectura Hexagonal (Puertos y Adaptadores)\n\nLa arquitectura hexagonal propone que el dominio (core) esté desacoplado de las infraestructuras y tecnologías externas mediante puertos (interfaces abstractas) y adaptadores concretos que implementan esas interfaces.\n\n- Esta arquitectura es muy compatible con la arquitectura funcional, especialmente cuando los bordes contienen el código impuro.\n- En programación **orientada a objetos (POO)**, la implementación de la arquitectura hexagonal demanda un gran esfuerzo para ser bien aplicada y mantenida, requiriendo un entendimiento profundo de principios como SOLID y una disciplina constante para evitar \"atajos\" que generen deuda técnica.\n- En cambio, la arquitectura funcional facilita este desacoplamiento de forma más natural, incluso en lenguajes que fuerzan, como Haskell, la separación entre código puro e impuro a nivel de tipos.\n\n---\n\n## 3. Principios de diseño funcional aplicados\n\n### 3.1 Composición y reutilización de funciones\n\n- Una función es una entidad independiente, reusable y desacoplada de clases o estructuras de datos.\n- Puede ser usada como entrada o salida de otras funciones, facilitando la composición.\n- La currificación es una técnica para adaptar funciones con múltiples argumentos a una cadena de funciones de un solo argumento, que permite conexiones limpias y composables entre ellas.\n- Las pipelines construidas con funciones puras son extensibles, ya que agregar funcionalidad normalmente implica añadir nuevos segmentos sin alterar el código existente.\n\n---\n\n### 3.2 Composición de types algebraicos para modelar dominio\n\nPara representar datos del dominio de forma clara y segura, aplicamos:\n\n- Composición con \"AND\" (records/tuplas): para agrupar datos relacionados.\n- Composición con \"OR\" (uniones / enums): para modelar elecciones o variantes.\n\nEsta técnica no solo documenta de forma precisa los elementos y sus relaciones, sino que también facilita el análisis estático, el mantenimiento y la evolución del dominio, manteniendo la lógica separada de la representación.\n\n---\n\n## 4. Validación y flujo de datos\n\n- Las validaciones deben realizarse en la frontera entre los procesos IO y el core funcional para garantizar que la lógica de negocio solo reciba datos válidos.\n- Esto evite la necesidad de programación defensiva dentro del core y simplifica la lógica.\n- Cuando se detectan datos no válidos, se omite la ejecución del core (skip) y se deben ejecutar procesos alternativos para manejar esos casos.\n\n---\n\n## 5. Testeo\n\n- Los **tests unitarios** se enfocan en el core funcional, donde las funciones puras permiten pruebas deterministas, simples y rápidas.\n- Los **tests de integración** apuntan a validar los flujos de trabajo (workflows) completos, los cuales incluyen las operaciones de IO y la interacción entre múltiples componentes y sistemas.\n\nEste enfoque reduce la necesidad de dobles y mocks complejos en la lógica de negocio y mejora la confianza en la calidad del software.\n\n---\n\n## 6. Comparación con la Programación Orientada a Objetos (POO)\n\n- La POO centra su práctica en la gestión de dependencias entre objetos, los cuales se comunican por mensajes.\n- Esta gestión puede ser compleja y conlleva un mayor esfuerzo para aplicar arquitecturas limpias como la hexagonal y mantener la disciplina asociada.\n- Patrones mal aplicados, como Active Record, mezclan lógica de persistencia con lógica de negocio, complicando el mantenimiento.\n- En la POO, los objetos pueden contener estado y comportamiento, y el acoplamiento accidental puede generar un incremento en la deuda técnica con el tiempo.\n- En cambio, la programación funcional promueve el aislamiento de dependencias mediante funciones puras, que reduce el esfuerzo en testabilidad y mantenibilidad.\n\n---\n\n## 7. Perspectiva de Lean UX y desarrollo ágil\n\n- El diseño y arquitectura deben aceptar que los cambios sucederán, por lo que el código debe preservar flexibilidad y minimizar el costo de cambio.\n- Validar ideas cuanto antes con clientes, es decir, entregar software funcional que permita obtener feedback rápido, ayuda a evaluar la viabilidad de las soluciones.\n- La colaboración estrecha con clientes y el equipo contribuye a un entendimiento común del problema y de las soluciones.\n\n---\n\n## Conclusión\n\nEl diseño del backend se apoya en una arquitectura funcional que conlleva un core de funciones puras rodeado por una capa imperativa que maneja IO. Esta separación garantiza un dominio expresivo, claro y altamente testeable.\n\nLa composición funcional, la utilización correcta de tipos algebraicos para el modelado, la validación en los bordes y el uso consciente de buenas prácticas para testear mejoran la calidad y mantenibilidad del proyecto.\n\nSi bien la arquitectura hexagonal y patrones de diseño similares son aplicables en POO, la arquitectura funcional facilita esta limpieza estructural con menor esfuerzo, a la vez que despliega un modelo mental más simple y alineado con los principios de la programación funcional.\n\n---\n\nSi quieres, puedo ayudarte a elaborar diagramas o ejemplos concretos para ilustrar cualquiera de estos puntos. ¿Quieres continuar con eso?"}}],"usage":{}}}],"chat_model":{"model_key":"gpt-4.1-mini","platform_key":"openai"}},"key":"Untitled Chat 1754602279071-1754602459851","thread_key":"Untitled Chat 1754602279071","stream":true,"context_key":"1754602459847","class_name":"SmartCompletion"},